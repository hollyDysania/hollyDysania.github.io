<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F09%2F11%2F%E6%8B%9C%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90Element%E6%BA%90%E7%A0%81-radio%E7%BB%84%E4%BB%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[title: 拜读及分析Element源码-radio组件篇date: 2018-09-10 17:49:27tags: element-uicategories: Vue element-ui源码分析系列 element-ui 单选框radio组件源码分析，也是很常用的一个 单选框组件分为3部分 radio-group: 单选组，适用于多个互斥的选项中选择的场景 radio： 单选 radio-button: 按钮样式的单选 2可以单独使用，也可与1组合使用，3和1要组合使用 radio-group结构很简单相当于是一个父容器，并且提供了键盘上下左右选中的方法 1234567&lt;div class="el-radio-group" role="radiogroup" @keydown="handleKeydown"&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/div&gt; slot接收的内容就是radio或radio-button了 script部分1. 导入mixins1import Emitter from 'element-ui/src/mixins/emitter'; 这是其实就是用到emitter.js里的dispatch 方法（向上找到指定组件并发布指定事件及传递值） 1234567891011121314151617// 接收组件名，事件名，参数dispatch(componentName, eventName, params) &#123; var parent = this.$parent || this.$root; var name = parent.$options.componentName; // 寻找父级，如果父级不是符合的组件名，则循环向上查找 while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.componentName; &#125; &#125; // 找到符合组件名称的父级后，发布其事件。 if (parent) &#123; parent.$emit.apply(parent, [eventName].concat(params)); &#125; 在watch中监听value时用到 123456watch: &#123; // 监听选中值，向上找到from-item组件发布el.form.change（应该是用于表单验证） value(value) &#123; this.dispatch('ElFormItem', 'el.form.change', [this.value]); &#125;&#125; 2.声明 冻结上下左右的keyCode组成的对象123456const keyCode = Object.freeze(&#123; LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40&#125;); Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。该方法返回被冻结的对象。 3.若form-item组件注入属性影响size（默认为空）12345inject: &#123; elFormItem: &#123; default: '' &#125;&#125; size在computed里 123456789// 最终大小computed: &#123; _elFormItemSize() &#123; return (this.elFormItem || &#123;&#125;).elFormItemSize; &#125;, radioGroupSize() &#123; return this.size || this._elFormItemSize || (this.$ELEMENT || &#123;&#125;).size; &#125;&#125; 4.生命周期及watch123456789101112131415created() &#123; // 触发radio组件发布的handleChange事件拿到选中值，发布change事件暴露选中值 this.$on('handleChange', value =&gt; &#123; this.$emit('change', value); &#125;);&#125;,mounted() &#123; // 当radioGroup没有默认选项时，第一个可以选中Tab导航 // 不知为何要这样做 const radios = this.$el.querySelectorAll('[type=radio]'); const firstLabel = this.$el.querySelectorAll('[role=radio]')[0]; if (![].some.call(radios, radio =&gt; radio.checked) &amp;&amp; firstLabel) &#123; firstLabel.tabIndex = 0; &#125;&#125; 5.keyDown事件123456789101112131415161718192021222324252627282930313233343536373839404142434445handleKeydown(e) &#123; // 左右上下按键 可以在radio组内切换不同选项 const target = e.target; // radio || label const className = target.nodeName === 'INPUT' ? '[type=radio]' : '[role=radio]'; const radios = this.$el.querySelectorAll(className); const length = radios.length; const index = [].indexOf.call(radios, target); const roleRadios = this.$el.querySelectorAll('[role=radio]'); switch (e.keyCode) &#123; case keyCode.LEFT: case keyCode.UP: // 上左 阻止冒泡和默认行为 e.stopPropagation(); e.preventDefault(); // 第一个元素 if (index === 0) &#123; // 选中最后一个 roleRadios[length - 1].click(); roleRadios[length - 1].focus(); &#125; else &#123; // 不是第一个 则选中前一个 roleRadios[index - 1].click(); roleRadios[index - 1].focus(); &#125; break; case keyCode.RIGHT: case keyCode.DOWN: // 下右 最后一个元素 if (index === (length - 1)) &#123; // 阻止冒泡和默认行为 e.stopPropagation(); e.preventDefault(); // 选中第一个 roleRadios[0].click(); roleRadios[0].focus(); &#125; else &#123; // 不是最后一个元素 则选中后一个 roleRadios[index + 1].click(); roleRadios[index + 1].focus(); &#125; break; default: break; &#125;&#125; switch case语句没有break默认向下执行，所以上左 和 下右 分别只写了一个执行函数和break(执行相同) radio结构1.外层label,控制整体样式1234567891011121314151617 &lt;label class="el-radio" :class="[ border &amp;&amp; radioSize ? 'el-radio--' + radioSize : '', &#123; 'is-disabled': isDisabled &#125;, &#123; 'is-focus': focus &#125;, &#123; 'is-bordered': border &#125;, &#123; 'is-checked': model === label &#125; ]" role="radio" :aria-checked="model === label" :aria-disabled="isDisabled" :tabindex="tabIndex" @keydown.space.stop.prevent="model = isDisabled ? model : label"&gt;...&lt;/label&gt; role,aria-checked,aria-disabled三个属性是无障碍页面应用的属性（读屏软件会用到）参考 tabindex： 属性规定元素的 tab 键控制次序 ，0为按照顺序，-1为不受tab控制 @keydown.space：空格keydown事件（可查阅vue官网按键修饰符） 2.内层第一个span由span和不可见的input（模拟radio）组成（筛选框）1234567891011121314151617181920212223&lt;!-- 单选框 --&gt; &lt;span class="el-radio__input" :class="&#123; 'is-disabled': isDisabled, 'is-checked': model === label &#125;" &gt; &lt;span class="el-radio__inner"&gt;&lt;/span&gt; &lt;!-- 不可见input模拟radio --&gt; &lt;input class="el-radio__original" :value="label" type="radio" aria-hidden="true" v-model="model" @focus="focus = true" @blur="focus = false" @change="handleChange" :name="name" :disabled="isDisabled" tabindex="-1" &gt; &lt;/span&gt; aria-hidden：也是无障碍页面应用的属性（读屏软件会用到），为true时自动读屏软件会自动跳过，毕竟这是一个隐藏元素 3.内层第二个span显示（筛选框对应的内容）12345678&lt;!-- 单选文字 --&gt;&lt;!-- 阻止冒泡 --&gt;&lt;span class="el-radio__label" @keydown.stop&gt; &lt;!-- 接收到插槽，显示插槽内容 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;!-- 没有接收到插槽，显示label --&gt; &lt;template v-if="!$slots.default"&gt;&#123;&#123;label&#125;&#125;&lt;/template&gt;&lt;/span&gt; $slots.default ：接收匿名插槽内容 script部份1.引入mixins同上 用到的是mixins中的dispatch方法 12// 用到mixins中的dispatch方法，向上寻找对应的组件并发布事件import Emitter from 'element-ui/src/mixins/emitter'; 运用在input的change事件中 12345678handleChange() &#123; this.$nextTick(() =&gt; &#123; // 发布change事件暴露model this.$emit('change', this.model); // 如果被radio-group组件嵌套，向上找到radio-group组件发布handleChange事件暴露model this.isGroup &amp;&amp; this.dispatch('ElRadioGroup', 'handleChange', this.model); &#125;);&#125; $nextTick: 将回调延迟到下次 DOM 更新循环之后执行 2.provide和 inject123456789// form注入inject: &#123; elForm: &#123; default: '' &#125;, elFormItem: &#123; default: '' &#125;&#125; 同上，接收form组件注入属性，影响size及disabled。 (computed中可以看到) 3.computed 是否被radio-group包裹 12345678910111213// 向上找radio-group组件 有则true无则falseisGroup() &#123; let parent = this.$parent; while (parent) &#123; if (parent.$options.componentName !== 'ElRadioGroup') &#123; parent = parent.$parent; &#125; else &#123; this._radioGroup = parent; return true; &#125; &#125; return false;&#125; 实现v-model 123456789101112131415161718// 实现v-modelmodel: &#123; // 取值 get() &#123; // radio-group的value或value return this.isGroup ? this._radioGroup.value : this.value; &#125;, // 赋值 set(val) &#123; // 被radio-group组件包裹 radio-group组件发布input事件数组形式暴露值 if (this.isGroup) &#123; this.dispatch('ElRadioGroup', 'input', [val]); &#125; else &#123; // 没有被radio-group组件包裹，直接发布input事件暴露值 this.$emit('input', val); &#125; &#125;&#125; 控制size,disabled,tabIndex 12345678910111213141516171819202122232425_elFormItemSize() &#123; return (this.elFormItem || &#123;&#125;).elFormItemSize;&#125;,radioSize() &#123; // props的size及form注入的size及全局配置对象（$ELEMENT，此对象由引入时Vue.use()传入的默认空对象）的size const temRadioSize = this.size || this._elFormItemSize || (this.$ELEMENT || &#123;&#125;).size; // 被radio-group组件包裹优先radioGroupSize return this.isGroup ? this._radioGroup.radioGroupSize || temRadioSize : temRadioSize;&#125;,isDisabled() &#123; // 被radio-group组件包裹，radioGroup的disabled || props的disabled || form注入的disabled, // 未被radio-group组件包裹则少第一个条件 return this.isGroup ? this._radioGroup.disabled || this.disabled || (this.elForm || &#123;&#125;).disabled : this.disabled || (this.elForm || &#123;&#125;).disabled;&#125;,// 控制tab是否可以选中tabIndex() &#123; // 当tabindex=0时，该元素可以用tab键获取焦点，且访问的顺序是按照元素在文档中的顺序来focus // 当tabindex=-1时，该元素用tab键获取不到焦点，但是可以通过js获取，这样就便于我们通过js设置上下左右键的响应事件来focus，在widget内部可以用到。 // 当tabindex&gt;=1时，该元素可以用tab键获取焦点，而且优先级大于tabindex=0；不过在tabindex&gt;=1时，数字越小，越先定位到。 return !this.isDisabled ? (this.isGroup ? (this.model === this.label ? 0 : -1) : 0) : -1;&#125; radio-button结构与radio类似，label是button的样式，少了一个单选框的结构（span），input模拟radio并且不可见，另一个依旧是显示对应单选框内容的span 12345678910111213141516171819202122232425262728293031323334&lt;label class="el-radio-button" :class="[ size ? 'el-radio-button--' + size : '', &#123; 'is-active': value === label &#125;, &#123; 'is-disabled': isDisabled &#125;, &#123; 'is-focus': focus &#125; ]" role="radio" :aria-checked="value === label" :aria-disabled="isDisabled" :tabindex="tabIndex" @keydown.space.stop.prevent="value = isDisabled ? value : label"&gt; &lt;input class="el-radio-button__orig-radio" :value="label" type="radio" v-model="value" :name="name" @change="handleChange" :disabled="isDisabled" tabindex="-1" @focus="focus = true" @blur="focus = false" &gt; &lt;span class="el-radio-button__inner" :style="value === label ? activeStyle : null" @keydown.stop&gt; &lt;slot&gt;&lt;/slot&gt; &lt;template v-if="!$slots.default"&gt;&#123;&#123;label&#125;&#125;&lt;/template&gt; &lt;/span&gt;&lt;/label&gt; script部分逻辑与radio基本上一样，来看下有区别的地方 选中时的填充色和边框色 1234567891011121314151617181920212223computed: &#123; // radio-group组件实例 _radioGroup() &#123; let parent = this.$parent; // 向上寻找radio-group组件 有就返回radio-group组件实例 没有返回false while (parent) &#123; if (parent.$options.componentName !== 'ElRadioGroup') &#123; parent = parent.$parent; &#125; else &#123; return parent; &#125; &#125; return false; &#125;, activeStyle() &#123; // 选中时的填充色和边框色 return &#123; backgroundColor: this._radioGroup.fill || '', borderColor: this._radioGroup.fill || '', boxShadow: this._radioGroup.fill ? `-1px 0 0 0 $&#123;this._radioGroup.fill&#125;` : '', color: this._radioGroup.textColor || '' &#125;; &#125; fill：是radio-group组件的属性（颜色）]]></content>
  </entry>
  <entry>
    <title><![CDATA[拜读及分析Element源码-checkbox多选框组件篇]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%8B%9C%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90Element%E6%BA%90%E7%A0%81-checkbox%E5%A4%9A%E9%80%89%E6%A1%86%E7%BB%84%E4%BB%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[element源码分析-checkbox多选框，感觉逻辑跟单选框很像，来看看吧。 checkbox多选框和单选框一样也分为三部分 checkbox-group：适用于多个勾选框绑定到同一个数组的情景，通过是否勾选来表示这一组选项中选中的项。 checkbox：多选。 checkbox-button： 按钮样式的多选。 checkbox-group相当于把checkbox和checkboxButton形成一个组 结构1234&lt;div class="el-checkbox-group" role="group" aria-label="checkbox-group"&gt; &lt;!-- 插槽：用来接收checkbox或checkbox-button --&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/div&gt; script部分1.接收form组件注入默认为空，若在form组件中嵌套使用并form组件注入了elFormItem则有值 12345inject: &#123; elFormItem: &#123; default: '' &#125;&#125; 2.注入的内容会在computed中使用123456789computed: &#123; // 控制大小 _elFormItemSize() &#123; return (this.elFormItem || &#123;&#125;).elFormItemSize; &#125;, checkboxGroupSize() &#123; return this.size || this._elFormItemSize || (this.$ELEMENT || &#123;&#125;).size; &#125;&#125; checkboxGroupSize会在checkbox和checkboxButton中用到 3.监听value123456watch: &#123; // 监听value 向上寻找form组件发布el.form.change事件暴露value（数组） value(value) &#123; this.dispatch('ElFormItem', 'el.form.change', [value]); &#125;&#125; 4.props接收的属性12345678910111213141516props: &#123; // 与v-model绑定 value: &#123;&#125;, // 是否禁用 disabled: Boolean, // 最少勾选长度 min: Number, // 最大勾选长度 max: Number, // 大小 size: String, // 边框及背景填充色 fill: String, // 文字颜色 textColor: String&#125; 有些属性checkbox和checkboxButton组件会用到 checkbox结构1.外层label: 控制外层样式1234567891011121314 &lt;label class="el-checkbox" :class="[ border &amp;&amp; checkboxSize ? 'el-checkbox--' + checkboxSize : '', &#123; 'is-disabled': isDisabled &#125;, &#123; 'is-bordered': border &#125;, &#123; 'is-checked': isChecked &#125; ]" role="checkbox" :aria-checked="indeterminate ? 'mixed': isChecked" :aria-disabled="isDisabled" :id="id" &gt;&lt;/label&gt; role，aria-checked，aria-disabled：无障碍网页应用属性（用于读屏） aria-checked： true代表选中，false代表未选中，mixed代表：元素指示选定和未选择状态 。 2.内层第一个span选择框12345678910111213141516171819202122&lt;span class="el-checkbox__input" :class="&#123; 'is-disabled': isDisabled, 'is-checked': isChecked, 'is-indeterminate': indeterminate, 'is-focus': focus &#125;" aria-checked="mixed"&gt; &lt;span class="el-checkbox__inner"&gt;&lt;/span&gt; &lt;!-- 有trueLabel或falseLabel时展示 --&gt; &lt;input ... v-if="trueLabel || falseLabel" ... &gt; &lt;!-- 无trueLabel和falseLabel时展示 --&gt; &lt;input v-else ... &gt;&lt;/span&gt; 外层span控制选择框的选中未被选中样式 隐藏的input模拟checkbox: 分为有传入trueLable或falseLable与无两种结构 3.内层第二个span-选择框对应的内容12345&lt;span class="el-checkbox__label" v-if="$slots.default || label"&gt; &lt;slot&gt;&lt;/slot&gt; // 有插槽内容显示插槽 无直接显示label &lt;template v-if="!$slots.default"&gt;&#123;&#123;label&#125;&#125;&lt;/template&gt;&lt;/span&gt; script部分从生命周期开始123456789101112created() &#123; // 如果当前勾选 调用addToStore(相当于选中与model值对应) this.checked &amp;&amp; this.addToStore();&#125;,mounted() &#123; // 如果有被选中又不是全选 // 为indeterminate元素 添加aria-controls 属性 if (this.indeterminate) &#123; // controls对应id,表示元素之间的控制关系 this.$el.setAttribute('aria-controls', this.controls); &#125;&#125; addToStore方法 123456789101112addToStore() &#123; // 如果model是数组并且不包含当前的选项，把当前选项push到model中 if ( Array.isArray(this.model) &amp;&amp; this.model.indexOf(this.label) === -1 ) &#123; this.model.push(this.label); // 否则 为传入选中值或true &#125; else &#123; this.model = this.trueLabel || true; &#125;&#125; 一些计算属性 是否被选中 123456789101112131415// 是否被选中isChecked() &#123; // model是Boolean类型 if (&#123;&#125;.toString.call(this.model) === '[object Boolean]') &#123; // 直接返回model return this.model; // 数组类型 &#125; else if (Array.isArray(this.model)) &#123; // 当前的label在model中为true不在为false return this.model.indexOf(this.label) &gt; -1; // model存在 返回是否与props的trueLabel全等 &#125; else if (this.model !== null &amp;&amp; this.model !== undefined) &#123; return this.model === this.trueLabel; &#125;&#125; 是否在多选组中嵌套使用 12345678910111213// 向上找checkbox-group组件找到返回true 未找到返回falseisGroup() &#123; let parent = this.$parent; while (parent) &#123; if (parent.$options.componentName !== 'ElCheckboxGroup') &#123; parent = parent.$parent; &#125; else &#123; this._checkboxGroup = parent; return true; &#125; &#125; return false;&#125; 控制样式的几个属性 12345678910111213141516171819isDisabled() &#123; // 取决于 checkbox-group的disabled props的disabled form注入的disabled return this.isGroup ? this._checkboxGroup.disabled || this.disabled || (this.elForm || &#123;&#125;).disabled : this.disabled || (this.elForm || &#123;&#125;).disabled; &#125;, _elFormItemSize() &#123; return (this.elFormItem || &#123;&#125;).elFormItemSize; &#125;, checkboxSize() &#123; // 取决于传入的size form组件注入的size 全局配置size const temCheckboxSize = this.size || this._elFormItemSize || (this.$ELEMENT || &#123;&#125;).size; // 如果被checkbox-group组件包裹，优先checkbox-group组件的size return this.isGroup ? this._checkboxGroup.checkboxGroupSize || temCheckboxSize : temCheckboxSize; &#125; value 1234// checkbox-group组件实例的value或当前valuestore() &#123; return this._checkboxGroup ? this._checkboxGroup.value : this.value;&#125; v-model对应的值 123456789101112131415161718192021222324252627282930313233// v-model的值model: &#123; // 取值 get() &#123; // 被checkbox-group包裹则取store，当前value有值则取value否则selfModel return this.isGroup ? this.store : this.value !== undefined ? this.value : this.selfModel; &#125;, // 赋值 set(val) &#123; // 被checkbox-group包裹 if (this.isGroup) &#123; this.isLimitExceeded = false; // 若赋值长度小于checkbox-group的min 突破限制 (this._checkboxGroup.min !== undefined &amp;&amp; val.length &lt; this._checkboxGroup.min &amp;&amp; (this.isLimitExceeded = true)); // 若赋值长度大于checkbox-group的max 突破限制 (this._checkboxGroup.max !== undefined &amp;&amp; val.length &gt; this._checkboxGroup.max &amp;&amp; (this.isLimitExceeded = true)); // 没有突破限制 向上找到checkbox-group组件发布input事件暴露val（数组形式） this.isLimitExceeded === false &amp;&amp; this.dispatch('ElCheckboxGroup', 'input', [val]); &#125; else &#123; // 没有被checkbox-group包裹 直接发布input事件暴露val this.$emit('input', val); // 给selfModel赋值val this.selfModel = val; &#125; &#125;&#125; isLimitExceeded: 是否突破限制 与checkbox-group的min和max有关 selfModel: 没有在多选组中使用的model值，默认false input的change事件123456789101112131415161718192021// input的change事件handleChange(ev) &#123; // 突破限制 直接return if (this.isLimitExceeded) return; let value; if (ev.target.checked) &#123; // 被选中 给value赋值 有trueLabel则赋值trueLabel 无则赋值true value = this.trueLabel === undefined ? true : this.trueLabel; &#125; else &#123; // 未被选中 给value赋值 有falseLable则赋值falseLabel 无则false value = this.falseLabel === undefined ? false : this.falseLabel; &#125; // 发布change方法暴露value及和event对象 this.$emit('change', value, ev); // dom渲染完成后 如果被checkbox-group组件包裹 则发布change事件，暴露checkbox-group组件实例的value(数组) this.$nextTick(() =&gt; &#123; if (this.isGroup) &#123; this.dispatch('ElCheckboxGroup', 'change', [this._checkboxGroup.value]); &#125; &#125;);&#125; 监听value，与表单验证相关123456watch: &#123; // 监听value变化，向上找到form组件则发布el.form.change事件暴露出value value(value) &#123; this.dispatch('ElFormItem', 'el.form.change', value); &#125;&#125; dispatch: 从mixins混入进来的方法,向上寻找(指定组件，发布指定事件，暴露指定值) 1import Emitter from 'element-ui/src/mixins/emitter' checkbox-button与checkbox基本一致，多了button相关样式,computed中的activeStyle，受checkbox-group的fill控制]]></content>
      <categories>
        <category>Vue</category>
        <category>element-ui源码分析系列</category>
      </categories>
      <tags>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拜读及分析Element源码-button组件篇]]></title>
    <url>%2F2018%2F09%2F10%2F%E6%8B%9C%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90Element%E6%BA%90%E7%A0%81-button%E7%BB%84%E4%BB%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[button组件开发时用到的频率非常高，一起来看看吧。 button组件相关的有两个文件 button-group（按钮组）按钮组时使用，相当于button的一个父容器,内包含一个匿名插槽，具体的处理在button.vue中 12345678910&lt;template&gt; &lt;div class="el-button-group"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'ElButtonGroup' &#125;;&lt;/script&gt; button (按钮)结构12345678910111213141516171819202122232425&lt;button class="el-button" @click="handleClick" :disabled="buttonDisabled || loading" :autofocus="autofocus" :type="nativeType" :class="[ type ? 'el-button--' + type : '', buttonSize ? 'el-button--' + buttonSize : '', &#123; 'is-disabled': buttonDisabled, 'is-loading': loading, 'is-plain': plain, 'is-round': round, 'is-circle': circle &#125; ]"&gt; &lt;!-- loading --&gt; &lt;i class="el-icon-loading" v-if="loading"&gt;&lt;/i&gt; &lt;!-- icon --&gt; &lt;i :class="icon" v-if="icon &amp;&amp; !loading"&gt;&lt;/i&gt; &lt;!-- 插槽 --&gt; &lt;span v-if="$slots.default"&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/span&gt;&lt;/button&gt; button按钮 属性： disabled：是否禁用 autofocus：是否获取焦点 type：赋值button的原生type（props中接收的nativeType） class: 多条件动态显示（此处用数组嵌套对象的写法 点击跳转官方文档） loading：props接收的loading为真时显示。 icon：props接收的icon为真并且loading为假时显示。 插槽：接收到匿名插槽内容时显示。(也就是使用button-group按钮组时) inject: 接收form组件注入的属性12345678inject: &#123; elForm: &#123; default: '' &#125;, elFormItem: &#123; default: '' &#125;&#125; 这里接收默认为空 如果button组件在form组件内使用，若form向子孙后代注入某些属性。会影响button的一些样式（本组件computed 中可以看到）。 点击查看官方文档: provide 和 inject 那么问题来了，有props为什么还要用 provide 和 inject 呢，因为前者只能用于父子，后者可以子孙后代，层级更深 computed12345678910111213computed: &#123; _elFormItemSize() &#123; return (this.elFormItem || &#123;&#125;).elFormItemSize; &#125;, // 大小样式由props接收的size和formItem组件注入的size以及全局配置对象（$ELEMENT，此对象由引入时Vue.use()传入的默认空对象）的size决定 buttonSize() &#123; return this.size || this._elFormItemSize || (this.$ELEMENT || &#123;&#125;).size; &#125;, // props接收disabled以及form组件注入的disabled决定（loading时也禁止↑） buttonDisabled() &#123; return this.disabled || (this.elForm || &#123;&#125;).disabled; &#125;&#125; size的影响因素 props接收的size form组件provide 的size 全局配置对象$ELEMENT的size： vue.use()时传入的 123import Vue from 'vue';import Element from 'element-ui';Vue.use(Element, &#123; size: 'small', zIndex: 3000 &#125;); disabled的影响因素 props接收的disabled form组件provide 的disabled 事件methods123456methods: &#123; // 点击button向父组件暴露点击事件 handleClick(evt) &#123; this.$emit('click', evt); &#125;&#125; props可以结合element文档看 12345678910111213141516171819202122232425262728293031props: &#123; // 按钮主题样式 type: &#123; type: String, default: 'default' &#125;, // 按钮大小 size: String, // icon icon: &#123; type: String, default: '' &#125;, // 原生button属性 nativeType: &#123; type: String, default: 'button' &#125;, // 按钮的loding动画 loading: Boolean, // 禁用 disabled: Boolean, // 朴素样式 plain: Boolean, // 聚焦 autofocus: Boolean, // 圆角 round: Boolean, // 圆形 circle: Boolean&#125; 学习 slot的使用：插槽 动态class class绑定传送门 数组写法 对象写法 更复杂的情况可以用数组组合对象的写法 $slots.default ： 获取所有匿名插槽分发的内容 $slots官方传送门]]></content>
      <categories>
        <category>Vue</category>
        <category>element-ui源码分析系列</category>
      </categories>
      <tags>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拜读及分析Element源码-alert组件篇]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%8B%9C%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90Element%E6%BA%90%E7%A0%81-alert%E7%BB%84%E4%BB%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[alert组件比较简单，基本上就是展示不同的样式， 只有一个关闭事件。 结构123456789101112131415161718192021222324252627282930313233&lt;transition name="el-alert-fade"&gt; &lt;!-- typeClass：根据传入的type控制样式 center: 根据传入的center控制内容是否居中 role：属性作用是告诉Accessibility类应用（比如屏幕朗读程序，为盲人提供的访问网络的便利程序），这个元素所扮演的角色，主要是供残疾人使用。使用role可以增强文本的可读性和语义化。 --&gt; &lt;div class="el-alert" :class="[typeClass, center ? 'is-center' : '']" v-show="visible" role="alert" &gt; &lt;!-- showIcon: 控制是否显示icon iconClass: 根据传入的type动态控制icon的样式 isBigIcon： 如果传入了description（辅助性文字）或者 插槽内传入了内容 则显示大icon --&gt; &lt;i class="el-alert__icon" :class="[ iconClass, isBigIcon ]" v-if="showIcon"&gt;&lt;/i&gt; &lt;div class="el-alert__content"&gt; &lt;!-- 如果传入了description（辅助性文字）或者 传入了匿名插槽 则显示加粗title --&gt; &lt;span class="el-alert__title" :class="[ isBoldTitle ]" v-if="title"&gt;&#123;&#123; title &#125;&#125;&lt;/span&gt; &lt;!-- 传入插槽内容则显示插槽内容 未传入默认显示slot内的内容description --&gt; &lt;slot&gt; &lt;p class="el-alert__description" v-if="description"&gt;&#123;&#123; description &#125;&#125;&lt;/p&gt; &lt;/slot&gt; &lt;!-- closable: 是否显示关闭按钮，默认显示 closeText： 关闭按钮自定义文字，无显示X有显示文字 --&gt; &lt;i class="el-alert__closebtn" :class="&#123; 'is-customed': closeText !== '', 'el-icon-close': closeText === '' &#125;" v-show="closable" @click="close()"&gt;&#123;&#123;closeText&#125;&#125;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt;&lt;/transition&gt; props1234567891011121314151617181920212223242526272829303132props: &#123; // 接收标题 title: &#123; type: String, default: '', required: true &#125;, // 辅助性文字 description: &#123; type: String, default: '' &#125;, // 接收主题 computed里会根据不同type返回对应的样式 type: &#123; type: String, default: 'info' &#125;, // 关闭按钮显示 closable: &#123; type: Boolean, default: true &#125;, // 关闭按钮自定义文字 closeText: &#123; type: String, default: '' &#125;, // 是否显示icom showIcon: Boolean, // 内容是否居中 center: Boolean&#125; computed123456789101112131415161718computed: &#123; // alert的样式 typeClass() &#123; return `el-alert--$&#123;this.type&#125;` &#125;, // alert里icon的样式 iconClass() &#123; return TYPE_CLASSES_MAP[this.type] || 'el-icon-info' &#125;, // 如果传入了description（辅助性文字）或者 传入了匿名插槽 则显示大icon isBigIcon() &#123; return this.description || this.$slots.default ? 'is-big' : '' &#125;, // 如果传入了description（辅助性文字）或者 传入了匿名插槽 则显示加粗title isBoldTitle() &#123; return this.description || this.$slots.default ? 'is-bold' : '' &#125;&#125; methods123456789methods: &#123; // 关闭alert方法 close() &#123; // v-show隐藏alert this.visible = false // 向父组件暴露close方法 this.$emit('close') &#125;&#125; data123456data() &#123; return &#123; // 组件显示隐藏 visible: true &#125;&#125; 学习 动态class class绑定传送门 数组写法 对象写法 更复杂的情况可以用数组组合对象的写法 role属性：无障碍网页应用,读屏软件会用到。W3c传送门 $slots.default ： 获取所有匿名插槽分发的内容 $slots官方传送门]]></content>
      <categories>
        <category>Vue</category>
        <category>element-ui源码分析系列</category>
      </categories>
      <tags>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拜读及分析Element源码组件-input篇]]></title>
    <url>%2F2018%2F08%2F30%2F%E6%8B%9C%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90Element%E6%BA%90%E7%A0%81-input%E7%BB%84%E4%BB%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[element-ui源码详细分析以及在其中可以学到的东西整理。(有问题欢迎指正与讨论) 首先看生命周期做了什么12345678910111213141516created() &#123; // 与select组件相关联 (若select组件已发布inputSelect事件则触发选中) this.$on('inputSelect', this.select);&#125;,mounted() &#123; // 动态文本域（高度） this.resizeTextarea(); // 前置后置元素偏移（样式） this.updateIconOffset();&#125;,updated() &#123; // 视图重绘完毕后 前置后置偏移（样式） this.$nextTick(this.updateIconOffset);&#125; 外层DIV绑定的一些class插槽及一些props传入的参数控制外层样式 12345678910111213141516171819202122232425262728293031 &lt;div :class="[ type === 'textarea' ? 'el-textarea' : 'el-input', inputSize ? 'el-input--' + inputSize : '', &#123; 'is-disabled': inputDisabled, 'el-input-group': $slots.prepend || $slots.append, 'el-input-group--append': $slots.append, 'el-input-group--prepend': $slots.prepend, 'el-input--prefix': $slots.prefix || prefixIcon, 'el-input--suffix': $slots.suffix || suffixIcon || clearable &#125; ]" @mouseenter="hovering = true" @mouseleave="hovering = false" &gt; &lt;!-- 内部被分为 input结构 与 textarea结构 --&gt;&lt;/div&gt;&lt;!-- 动态class 具名插槽 $slots.prepend: 前置插槽 $slots.append: 后置插槽 $slots.prefix： 前置icon插槽 $slots.suffix： 后置icon插槽 不使用插槽的icon prefixIcon: 前置icon suffixIcon: 后置icon clearable： 后置是否清空 --&gt; 实例属性$slots用来访问被插槽分发的内容 vm.$slots.foo 访问具名插槽foo vm.$slots.default 没有被包含在具名插槽中的节点 有多个条件 class 时: 可以用数组结合对象的写法 内层input结构1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 输入框结构 --&gt; &lt;template v-if="type !== 'textarea'"&gt; &lt;!-- 前置元素 --&gt; &lt;div class="el-input-group__prepend" v-if="$slots.prepend"&gt; ... &lt;/div&gt; &lt;input :tabindex="tabindex" v-if="type !== 'textarea'" class="el-input__inner" v-bind="$attrs" :type="type" :disabled="inputDisabled" :readonly="readonly" :autocomplete="autoComplete" :value="currentValue" ref="input" @compositionstart="handleComposition" @compositionupdate="handleComposition" @compositionend="handleComposition" @input="handleInput" @focus="handleFocus" @blur="handleBlur" @change="handleChange" :aria-label="label" &gt; &lt;!-- 前置内容 --&gt; &lt;span class="el-input__prefix" v-if="$slots.prefix || prefixIcon"&gt; ... &lt;/span&gt; &lt;!-- 后置内容 --&gt; &lt;span class="el-input__suffix" v-if="$slots.suffix || suffixIcon || showClear || validateState &amp;&amp; needStatusIcon"&gt; ... &lt;/span&gt; &lt;!-- 后置元素 --&gt; &lt;div class="el-input-group__append" v-if="$slots.append"&gt; ... &lt;/div&gt; &lt;/template&gt; 前置后置内容及插槽：基本上都是通过props接收的变量或者插槽控制样式及位置偏移，这里我就先“…”了 中文输入法相关的事件 compositionstart compositionupdate compositionend 首先会看到input上绑定了这三个事件（在下孤陋寡闻没有见过）,于是尝试一下触发时机 根据上图可以看到 输入到input框触发input事件 失去焦点后内容有改变触发change事件 识别到你开始使用中文输入法触发compositionstart 事件 未输入结束但还在输入中触发compositionupdate 事件 输入完成（也就是我们回车或者选择了对应的文字插入到输入框的时刻）触发compositionend事件。 查阅资料后发现，这三个事件不仅包括中文输入法还包括语音识别。 下面是MDN上的解释 类似于 keydown 事件，但是该事件仅在若干可见字符的输入之前，而这些可见字符的输入可能需要一连串的键盘操作、语音识别或者点击输入法的备选词 那么问题来了 为什么要使用这几个事件呢因为input组件常常跟form表单一起出现，需要做表单验证 为了解决中文输入法输入内容时还没将中文插入到输入框就验证的问题 我们希望中文输入完成以后才验证 不曾用过的属性特指本渣눈.눈 $attrs: 获取到子组件props没有注册的,除了style和class以外所有父组件的属性。（感觉好强!） tabindex: 原生属性, 元素的 tab 键控制次序(具体的自行查阅) readonly ：原生属性，只读。（true时input框不可修改） autoComplete：原生属性 当用户在字段开始键入时，浏览器基于之前键入过的值，是否显示出在字段中填写的选项。 aria-label：原生属性，tab到输入框时，读屏软件就会读出相应label里的文本。 内层textarea 结构123456789101112131415161718192021&lt;!-- 文本域结构 --&gt; &lt;textarea v-else :tabindex="tabindex" class="el-textarea__inner" :value="currentValue" @compositionstart="handleComposition" @compositionupdate="handleComposition" @compositionend="handleComposition" @input="handleInput" ref="textarea" v-bind="$attrs" :disabled="inputDisabled" :readonly="readonly" :style="textareaStyle" @focus="handleFocus" @blur="handleBlur" @change="handleChange" :aria-label="label" &gt; &lt;/textarea&gt; 绑定的事件及属性与input差不多，区别是textarea动态控制高度的style textarea 高度自适应props autosize 自适应高度的配置 resize 是否缩放 123456789101112131415161718192021222324computed: &#123; textareaStyle() &#123; // merge 从src/utils/merge.js引入 合并对象的方法 return merge(&#123;&#125;, this.textareaCalcStyle, &#123; resize: this.resize &#125;); &#125;, &#125;，methods: &#123; resizeTextarea() &#123; // 是否运行于服务器 （服务器渲染） if (this.$isServer) return; const &#123; autosize, type &#125; = this; if (type !== 'textarea') return; if (!autosize) &#123; this.textareaCalcStyle = &#123; minHeight: calcTextareaHeight(this.$refs.textarea).minHeight &#125;; return; &#125; const minRows = autosize.minRows; const maxRows = autosize.maxRows; this.textareaCalcStyle = calcTextareaHeight(this.$refs.textarea, minRows, maxRows); &#125;&#125; calcTextareaHeight 是calcTextareaHeight.js里的方法，计算文本域高度及设置样式 我就直接贴代码和分析的注释了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130let hiddenTextarea;// 预设的一些样式const HIDDEN_STYLE = ` height:0 !important; visibility:hidden !important; overflow:hidden !important; position:absolute !important; z-index:-1000 !important; top:0 !important; right:0 !important`;// 预计要用的一些样式属性const CONTEXT_STYLE = [ 'letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];// 获取到一些需要用到的样式function calculateNodeStyling(targetElement) &#123; // 获取最终作用到元素的所有样式（返回CSSStyleDeclaration对象） const style = window.getComputedStyle(targetElement); // getPropertyValue为CSSStyleDeclaration原型上的方法获取到具体的样式 const boxSizing = style.getPropertyValue('box-sizing'); // 上下内边距 const paddingSize = ( parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top')) ); // 上下边框宽度 const borderSize = ( parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width')) ); // 取出预计要用的属性名和值，以分号拼接成字符串 const contextStyle = CONTEXT_STYLE .map(name =&gt; `$&#123;name&#125;:$&#123;style.getPropertyValue(name)&#125;`) .join(';'); // 返回预设要用的样式字符串，上下内边距和， 边框和， boxSizing属性值 return &#123; contextStyle, paddingSize, borderSize, boxSizing &#125;;&#125;export default function calcTextareaHeight( targetElement, minRows = 1, maxRows = null) &#123; // hiddenTextarea不存在则创建textarea元素append到body中 if (!hiddenTextarea) &#123; hiddenTextarea = document.createElement('textarea'); document.body.appendChild(hiddenTextarea); &#125; // 取出以下属性值 let &#123; paddingSize, borderSize, boxSizing, contextStyle &#125; = calculateNodeStyling(targetElement); // 给创建的hiddenTextarea添加行内样式并赋值value或palceholder,无则'' hiddenTextarea.setAttribute('style', `$&#123;contextStyle&#125;;$&#123;HIDDEN_STYLE&#125;`); hiddenTextarea.value = targetElement.value || targetElement.placeholder || ''; // 获取元素自身高度 let height = hiddenTextarea.scrollHeight; const result = &#123;&#125;; // boxSizing不同 高度计算不同 if (boxSizing === 'border-box') &#123; // border-box：高度 = 元素自身高度 + 上下边框宽度和 height = height + borderSize; &#125; else if (boxSizing === 'content-box') &#123; // content-box： 高度 = 高度 - 上下内边距和 height = height - paddingSize; &#125; hiddenTextarea.value = ''; // 单行文字的高度 let singleRowHeight = hiddenTextarea.scrollHeight - paddingSize; // minRows最小行存在 if (minRows !== null) &#123; // 最小高度 = 单行高度 * 行数 let minHeight = singleRowHeight * minRows; if (boxSizing === 'border-box') &#123; // border-box则加上内边距及边框 minHeight = minHeight + paddingSize + borderSize; &#125; // minHeight与height取最大值给height赋值 height = Math.max(minHeight, height); result.minHeight = `$&#123; minHeight &#125;px`; &#125; // 最大行存在 if (maxRows !== null) &#123; // 逻辑同上 let maxHeight = singleRowHeight * maxRows; if (boxSizing === 'border-box') &#123; maxHeight = maxHeight + paddingSize + borderSize; &#125; // maxHeight与height取最小值给height赋值 height = Math.min(maxHeight, height); &#125; result.height = `$&#123; height &#125;px`; // 计算完成后移除hiddenTextarea元素 hiddenTextarea.parentNode &amp;&amp; hiddenTextarea.parentNode.removeChild(hiddenTextarea); hiddenTextarea = null; // 暴露包含minHeight及height的对象 return result;&#125;; 需要注意的一些点form组件中嵌套input组件时样式也会受form一些注入属性的控制。123456789// 接收form组件注入的属性 inject: &#123; elForm: &#123; default: '' &#125;, elFormItem: &#123; default: '' &#125; &#125; size(input的大小) this.elFormItem.validateState： 与表单验证关联 ，控制表单验证时icon的样式（红x之类的） 1234567891011121314151617computed: &#123; // 表单验证相关 validateState() &#123; return this.elFormItem ? this.elFormItem.validateState : ''; &#125;, needStatusIcon() &#123; return this.elForm ? this.elForm.statusIcon : false; &#125;, // 表单验证样式 validateIcon() &#123; return &#123; validating: 'el-icon-loading', success: 'el-icon-circle-check', error: 'el-icon-circle-close' &#125;[this.validateState]; &#125;&#125; props的validateEvent属性：时间选择器会传入false其他默认true （意思大概true是需要做校验）,以下是用到validateEvent的methods1234567891011121314151617181920212223242526handleBlur(event) &#123; this.focused = false; // 暴露blur事件 this.$emit('blur', event); if (this.validateEvent) &#123; // 向上找到ElFormItem组件发布el.form.blur事件并传值 this.dispatch('ElFormItem', 'el.form.blur', [this.currentValue]); &#125;&#125;,setCurrentValue(value) &#123; // 还在输入并且内容与之前内容相同 return if (this.isOnComposition &amp;&amp; value === this.valueBeforeComposition) return; // input内容赋值 this.currentValue = value; // 还在输入return if (this.isOnComposition) return; this.$nextTick(_ =&gt; &#123; this.resizeTextarea(); &#125;); // 除了时间选择器其他组件中使用默认为true if (this.validateEvent) &#123; // mixin中的方法 意思是向上找到ElFormItem组件发布el.form.change事件并传递当前input内容 this.dispatch('ElFormItem', 'el.form.change', [value]); &#125;&#125; dispatch这个方法开始我以为是触发vuex的方法结果是mixin里的路径： src/mixins/emitter.js 1234567891011121314151617// 接收组件名，事件名，参数dispatch(componentName, eventName, params) &#123; var parent = this.$parent || this.$root; var name = parent.$options.componentName; // 寻找父级，如果父级不是符合的组件名，则循环向上查找 while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.componentName; &#125; &#125; // 找到符合组件名称的父级后，发布传入事件。 if (parent) &#123; parent.$emit.apply(parent, [eventName].concat(params)); &#125;&#125; 导入的Migrating迭代api友好提示 方便由于用了移除的api报错 找出问题在哪 参见methos中getMigratingConfig事件及src/mixins/migrating.js 疑问1234567891011121314151617181920212223242526272829// 判断韩文的方法(不清楚为什么)import &#123; isKorean &#125; from 'element-ui/src/utils/shared';methods: &#123; // 中文或语音输入开始 中 后 触发详见↑ handleComposition(event) &#123; // 完成输入时 if (event.type === 'compositionend') &#123; // 输入中标识为false this.isOnComposition = false; // 中文或语音输入前的值赋值给当前 this.currentValue = this.valueBeforeComposition; // 清空之前的值 this.valueBeforeComposition = null; // 赋值并且向父组件暴露input方法 this.handleInput(event); // 未完成时 &#125; else &#123; const text = event.target.value; const lastCharacter = text[text.length - 1] || ''; // 最后一个字符不是韩文就是在输入中（不是很理解为什么要判断最后一个字符是否是韩语） this.isOnComposition = !isKorean(lastCharacter); // 输入开始前 if (this.isOnComposition &amp;&amp; event.type === 'compositionstart') &#123; this.valueBeforeComposition = text; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
        <category>element-ui源码分析系列</category>
      </categories>
      <tags>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国际化语言切换Vue-i18n使用]]></title>
    <url>%2F2018%2F08%2F14%2F%E5%9B%BD%E9%99%85%E5%8C%96%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2Vue-i18n%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[多语言切换vue实现国际化插件vue-i18n，参考element-admin中i18n的使用 安装1npm install vue-i18n --save 基本使用main.js中配置 1234567891011121314151617181920212223242526272829// 引入import VueI18n from 'vue-i18n'Vue.use(VueI18n)// 配置const i18n = new VueI18n(&#123; locale: 'en', // 默认语言 message: &#123; // 语言文字 en: &#123; msg: &#123; hello: 'hello world' &#125; &#125;, cn: &#123; msg: &#123; hello: '你好，世界' &#125; &#125; &#125;&#125;)// 挂在到Vue实例new Vue (&#123; el: '#app', router, i18n, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) vue组件中使用 1&lt;h1&gt;&#123;&#123; $t('msg.hello') &#125;&#125;&lt;/h1&gt; 12// 切换修改this.$i18n.locale的值即可this.$i18n.locale = 'en' 要切换的文字较少可以参照以上，如果较多可以 参考element-admin里的写法 创建了一个单独的语言文件夹 lang en.js index.js zh.js 123456789101112131415161718192021222324// en.js 导出英文对象export default &#123; ... navbar: &#123; logOut: 'Log Out', dashboard: 'Dashboard', github: 'Github', screenfull: 'screenfull', theme: 'theme' &#125; ...&#125;// zh.js 导出中文对象export default &#123; ... navbar: &#123; logOut: '退出登录', dashboard: '首页', github: '项目地址', screenfull: '全屏', theme: '换肤' &#125; ...&#125; 配置文件index.js 1234567891011121314151617181920212223242526272829303132import Vue from 'vue'import VueI18n from 'vue-i18n'import Cookies from 'js-cookie'import elementEnLocale from 'element-ui/lib/locale/lang/en' // element-ui语言包import elementZhLocale from 'element-ui/lib/locale/lang/zh-CN'// element-ui语言包import enLocale from './en' import zhLocale from './zh'Vue.use(VueI18n)const messages = &#123; en: &#123; // ES6扩展运算符合并对象 ...enLocale, ...elementEnLocale &#125;, zh: &#123; ...zhLocale, ...elementZhLocale &#125;&#125;// 结合cookie记录用户选择的语言，若无默认enconst i18n = new VueI18n(&#123; // set locale // options: en or zh locale: Cookies.get('language') || 'en', // set locale messages messages&#125;)export default i18n main.js入口文件 1234567891011//...import i18n from './lang' // 导入配置文件(默认会导入./lang/index.js)//...new Vue(&#123; el: '#app', router, store, i18n, // 挂在到Vue实例上 render: h =&gt; h(App)&#125; 组件中使用 12345678&lt;div class="tips"&gt;&lt;span&gt;&#123;&#123;$t('login.username')&#125;&#125; : admin&lt;/span&gt;&lt;span&gt;&#123;&#123;$t('login.password')&#125;&#125; : &#123;&#123;$t('login.any')&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div class="tips"&gt;&lt;span style="margin-right:18px;"&gt;&#123;&#123;$t('login.username')&#125;&#125; : editor&lt;/span&gt;&lt;span&gt;&#123;&#123;$t('login.password')&#125;&#125; : &#123;&#123;$t('login.any')&#125;&#125;&lt;/span&gt;&lt;/div&gt; 1234567891011handleSetLanguage(lang) &#123; // 切换 this.$i18n.locale = lang // 结合vuex （vuex的mutations方法结合了cookie） this.$store.dispatch('setLanguage', lang) // 切换成功提示 this.$message(&#123; message: 'switch language success', type: 'success' &#125;)&#125; :artificial_satellite:点击跳转github地址]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js官方文档温故小结]]></title>
    <url>%2F2018%2F08%2F09%2FVue-js%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%B8%A9%E6%95%85%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[来阅读和总结一下Vue官方文档吧~（平时自己不太清晰或者没有注意到的部分内容） 箭头函数里的this拿不到Vue实例对象: 因为箭头函数是和父级上下文绑定在一起的 所以不要出现以下错误的写法： 12created: () =&gt; console.log(this.a)vm.$watch('a', newValue =&gt; this.myMethod()) v-once:指令只执行一次插值，数据变化时不更新。 v-html：不要对用户提供的内容使用插值，容易导致XSS攻击。 场景： 一个提交评论的功能，评论内容是v-html来展示的，用户提交一个可执行的script脚本用来窃取cookie,token,用户信息等等。其它用户查看该评论时v-html自动执行脚本，信息被窃取。 动态style：对象语法{}一个对象，动态切换class;数组语法[],多个class。vue.js会自动添加需要添加浏览器引擎前缀。 自定义组件上的class: 会添加到该组件根元素而不是覆盖。 动态style: 对象语法： 12345678910111213// html&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt;&lt;div :style="&#123;color: activeColor&#125;"&gt; // jsdata() &#123; return&#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;, activeColor: 'green' &#125;&#125; 数组语法： 1&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt;&lt;/div&gt; 浏览器前缀2.3.0+版本属性值可以是一个带前缀的数组，之后渲染最后一个值 1&lt;div :style="&#123;display: ['-webkit-box', '-ms-flexbox', 'flex']&#125;"&gt;&lt;/div&gt; v-if和template元素： 何时使用template: 当条件判断需要切换不同的元素时使用。template标签天生不可见，当需要对一些内容进行v-if条件判断时，可以在外层包裹template元素，减少dom层。 只是显示或隐藏同一个元素，直接在元素上v-if即可，或者外层包裹div v-else v-else-if 需要紧跟在v-if后面，否则不识别。与条件判断语句逻辑相同 key管理元素复用：Vue默认复用已有元素，不会从头开始渲染，效率比较快。 给元素加上key属性：表示完全独立的元素，不复用。 终于知道为什么v-for要绑定key了，防止复用，唯一 v-show与v-if: 如果在允许时条件很少改变使用v-if较好，频繁的变化使用v-show较好。 v-show: 只是改变display属性是否为none，一开始就会被渲染，每次都会被渲染； v-if: 只有当条件为真时才渲染，影响dom，销毁和重建 v-if 与 v-for一起使用时：v-for 优先级更高，v-if会重复运行于每个v-for循环中（类似于循环内部的if判断） v-for: 记得动态绑定key 12345678910111213&lt;--数组--&gt;&lt;ul id="example-1"&gt; &lt;li v-for="(item, index) in arr" :key="item.id"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; &lt;--对象--&gt;&lt;ul id="example-2"&gt; &lt;li v-for="(value, key, index) in obj" :key="key"&gt; &#123;&#123;key&#125;&#125; - &#123;&#123;value&#125;&#125; -&#123;&#123;index&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 数组 会改变原数组的方法 push() pop() shift() unshift() splice() sort() reverse() 不改变原数组的方法 filter() concat() slice() 避免不必要的处理数据出现的bug（最近我自己就用sort又忘记它会改变原数组） 检测不到数组变化的情况 利用索引直接设置一个项时arr[index] = newValue; 解决： ​ this.$set(arr, index, newValue) ​ arr.splice(index, 1, newValue) 修改数组长度 arr.length = newLength; 解决： ​ arr.splice(newLength) 对象更改检测注意事项：检测不到对象属性的添加或删除1234567891011121314151617&lt;div&gt;&#123;&#123;obj&#125;&#125;&lt;/div&gt;data() &#123; return &#123; obj: &#123; name: 'holly' &#125; &#125;&#125;// 给obj添加一个age属性obj.age = 3 // 虽然添加了属性但是插值并没有变化/***解决方法*/// 使用$setthis.$set(obj, 'age', 3)// 使用Object.assign或者lodash的extend方法 用两个对象属创建新的对象this.obj = Object.assign(&#123;&#125;, this.obj, &#123;age: 3&#125;) v-for 和 template: 用于渲染多个元素的时候 123456&lt;ul&gt; &lt;template v-for="item in items"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class="divider" role="presentation"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 事件 想要拿到event对象，传入特殊变量$event即可 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 （一直不太理解，下面这个图感觉解释的比较清楚） 事件修饰符.prevent ：对应addEventListener 中的 passive 选项(解决移动端滑动，滚动卡顿而诞生的) 这个 .passive 修饰符尤其能够提升移动端的性能。 不要把 .passive 和 .prevent 一起使用 按键修饰符 ASCII码值 1&lt;input v-on:keyup.13="submit"&gt; 按键别名 .enter .tab .delete .esc .space .up .down .left .right 可以通过全局 config.keyCodes 对象自定义按键修饰符别名： 12// 可以使用 `v-on:keyup.f1`Vue.config.keyCodes.f1 = 112 鼠标按钮修饰符2.2.0+ .left .right .middle 表单v-model 指令在表单 input、textarea 及 select 元素上创建双向数据绑定 修饰符 .lazy: 原本v-model绑定的值是实时更新的，这个修饰符就是转变为change事件同步，change事件是失去焦点时触发。 .number: 将输入的值转为数值。 .trim: 过滤首尾空白字符 组件基础组件的自动化全局注册：多个全局共用的基础组件时使用（暂时没有用到过，点击跳转官网） 组件上的事件修饰符.native: 可以监听组件根元素事件 .sync修饰符: props传递的值是单向数据流，想父组件传递给子组件，子组件更新这个值，父组件也同步更新。这时可以使用.sync实现prop”双向绑定”。 slot插槽 匿名插槽： 父组件内容分发到插槽 具名插槽： 子组件slot插槽的name属性和父组件slot属性对应，分发到对应name的插槽 插槽默认内容：组建插槽内可以有默认内容，当父组件为这个插槽提供了内容，将被覆盖。 作用域： 父组件模板的内容都会在父组件作用域内编译，子组件模板的所有内容都会在子组件作用域内编译。 作用域插槽：可以从子组件获取数据的可复用插槽 写法： 123456789101112131415161718192021222324252627282930313233&lt;!-- 组件 todo-list--&gt;&lt;ul&gt; &lt;li v-for="todo in todos" v-bind:key="todo.id" &gt; &lt;!-- 我们为每个 todo 准备了一个插槽，--&gt; &lt;!-- 将 `todo` 对象作为一个插槽的 prop 传入。--&gt; &lt;slot :todo="todo" :arr="arr"&gt; &lt;!-- 回退的内容 --&gt; &#123;&#123; todo.text &#125;&#125; &lt;/slot&gt; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 父组件使用组件 --&gt;&lt;todo-list v-bind:todos="todos"&gt; &lt;!-- 将 `slotProps` 定义为插槽作用域的名字 --&gt; &lt;template slot-scope="slotProps"&gt; &lt;!-- 为待办项自定义一个模板，--&gt; &lt;!-- 通过 `slotProps` 为一个对象 插槽可以传入多个prop--&gt; &lt;span v-if="slotProps.todo.isComplete"&gt;✓&lt;/span&gt; &#123;&#123; slotProps.todo.text &#125;&#125; &lt;span&gt; &#123;&#123; slotProps.arr &#125;&#125; &lt;/span&gt; &lt;/template&gt;&lt;/todo-list&gt;&lt;!-- slot-scope 使用结构赋值的写法 看起来更简洁一些--&gt;&lt;todo-list v-bind:todos="todos"&gt; &lt;template slot-scope="&#123;todo, arr&#125;"&gt; &lt;span v-if="todo.isComplete"&gt;✓&lt;/span&gt; &#123;&#123; todo.text &#125;&#125; &lt;span&gt; &#123;&#123; arr &#125;&#125; &lt;/span&gt; &lt;/template&gt;&lt;/todo-list&gt; 动态组件：component 的is属性12&lt;component v-bind:is="currentTabComponent"&gt;&lt;/component&gt;&lt;button @click="handleChangeView"&gt;切换&lt;/button&gt; 12345678910111213141516171819components:&#123; comA:&#123; template:`&lt;div&gt;组件A&lt;/div&gt;` &#125;, comB:&#123; template:`&lt;div&gt;组件B&lt;/div&gt;` &#125;, comC:&#123; template:`&lt;div&gt;组件C&lt;/div&gt;` &#125;&#125;,data:&#123; currentTabComponent:'comA'&#125;,methods: &#123; handleChangeView() &#123; this.currentTabComponent = 'comB' &#125; &#125; 结合keep-alive做缓存 123&lt;keep-alive&gt; &lt;component v-bind:is="currentTabComponent"&gt;&lt;/component&gt;&lt;/keep-alive&gt; 异步组件:需要的时候才从服务器加载这个模块。 全局注册 12345Vue.component( 'async-webpack-example', // 这个 `import` 函数会返回一个 `Promise` 对象。 () =&gt; import('./my-async-component')) 局部注册 123components: &#123; 'my-component': () =&gt; import('./my-async-component')&#125; 2.3.0+新增异步组件函数返回对象属性：来处理加载状态 12345678910111213const AsyncComponent = () =&gt; (&#123; // 需要加载的组件 (应该是一个 `Promise` 对象) component: import('./MyComponent.vue'), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000&#125;) 特殊情况： 一些需要对vue规则做一些小调整的特殊情况 访问根实例： $root (项目比较大时推荐vuex) 子组件访问父组件实例： $parent 访问子组件或子元素：给组件绑定ref，通过$ref访问，$refs在组件渲染完成之后生效，不是响应式 依赖注入：父组件通过provide提供变量及方法，子组件通过inject注入(依然推荐vuex) 123456789// 父组件provide: function () &#123; return &#123; getMap: this.getMap,// 方法 mapInfo: this.mapInfo // 对象数据 &#125;&#125;// 子组件inject: ['getMap', 'mapInfo'] 事件侦听器： $on $once $off 循环引用 递归组件： 组件可以在自己的模板中调用自身，确保递归是条件性的，避免无限循环 123name: 'stack-overflow',template: '&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'// 死循环，可以使用v-if条件判断 控制更新 强制更新：极少数情况下需要手动强制更新可以通过$forceUpdate v-once创建静态组件：需要渲染大量静态内容，除非觉得渲染非常慢，否则不推荐 123456&lt;div v-once&gt; &lt;h1&gt; 大量静态数据 &lt;/h1&gt; ...&lt;/div&gt; 过渡 &amp; 动画 点击跳转]]></content>
      <categories>
        <category>温故</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置码云和github公钥SSH]]></title>
    <url>%2F2018%2F08%2F07%2F%E9%85%8D%E7%BD%AE%E7%A0%81%E4%BA%91%E5%92%8Cgithub%E5%85%AC%E9%92%A5SSH%2F</url>
    <content type="text"><![CDATA[公钥可以解决每次push clone pull 时需要输入账号密码的问题(当然也可以通过git的config文件或者gitbash输入命令永远保存账号密码) 生成本地ssh 打开Git Bash 1cd ~/.ssh 生成ssh 12ssh-keygen -t rsa -C 'github的用户名邮箱' -f '自定义的公钥名例如：github_id_rsa'ssh-keygen -t rsa -C '码云的用户名邮箱' -f '自定义的公钥名例如：id_rsa' 一路回车就好，生成免密公钥 -t : 指定密钥类型 （不指定默认SSH-2的RSA密钥） rsa: 密钥类型 -C: 用于识别这个密钥的注释（可以输入任何内容，很多网站和软件用这个注释作为密钥的名字） -f: 指定文件名 生成的文件 C:\Users\Administrator\.ssh下可以看到新增的 将公钥配置到github和gitee将对应的pub文件内容粘贴到对应的网站就可以了 github: settings =&gt; SSH and GPG keys =&gt; new ssh key gitee: 设置 =&gt; SSH公钥 =&gt; 添加公钥即可 避免冲突创建config文件1234cd ~/.sshvi config// 输入:w 回车// 输入:q! 回车 文件内容 1234567891011# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa(对应文件名)# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_id_rsa（对应文件名） 保存搞定~~✿✿ヽ(°▽°)ノ✿]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gitbash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css利用不可见文本实现图标与文字对齐]]></title>
    <url>%2F2018%2F08%2F06%2Fcss%E5%88%A9%E7%94%A8%E4%B8%8D%E5%8F%AF%E8%A7%81%E6%96%87%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%9B%BE%E6%A0%87%E4%B8%8E%E6%96%87%E5%AD%97%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[日常开发中经常需要将icon图标与文字对齐，看起来好像很简单，但实现以后切换不同屏幕或者字体大小或行高，肉眼看总是觉得好像有一些没有完全对齐。 利用不可见文本实现图标与文字对齐使用inline-flex： 1234&lt;div&gt; &lt;span&gt;&amp;#8203;&lt;img src="url"/&gt;&lt;/span&gt; 文字内容&lt;/div&gt; 1234span&#123; display: inline-flex; align-items: center；&#125; 使用inline-block: html结构同上 123456789101112span &#123; position: relative; display: inline-block; line-height: 1; // 使文本高度为图标高度 width: 1em; //图标大小，用来占位 &#125; span img &#123; position: absolute; top: 0; left: 0; width: 1em; height: 1em; &#125; 伪元素替换html中的不可见文本 123456&lt;div&gt; &lt;span&gt; &lt;img src="url"/&gt; &lt;/span&gt; 文字内容&lt;/div&gt; 12// 加上伪元素span::before &#123; content: '\200b' &#125; 原理： 让不可见文本对齐Line Box中其他文本，让图标对齐这个不可见文本。详细原理分析请查阅大漠《Icon和文本对齐方式的探索》：http://www.w3cplus.com/css/icon-align-to-text.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机端判断滚动条到达底部]]></title>
    <url>%2F2018%2F08%2F02%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%88%A4%E6%96%AD%E6%BB%9A%E5%8A%A8%E6%9D%A1%E5%88%B0%E8%BE%BE%E5%BA%95%E9%83%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近项目里要做一个滚动条滑动到底部再上垃就翻页的效果，手机谷歌浏览器判断出现偏差，原因是因为获取视窗高度时与其他浏览器不同，需要兼容写法。 但其实不同的浏览器对各种高度的解析是不一样的，所以都需要兼容性写法。 js判断滚动条滚动到底部如何判断滚动条到底底部呢 文档高度 - 滚出可视区的高度 === 可视区高度 但移动端有些浏览器有下拉上垃回弹所以可以改写为,兼容性更好一些 文档高度 - 滚出可视区的高度 &lt;= 可视区高度 或者（其实是一个意思 哈哈哈） 文档高度 - （滚出可视区的高度 + 可视区高度） &lt;= 0 兼容性写法 相关的 获取文档高度： 123456789101112function getDocumentHeight () &#123; const body = document.body const html = document.documentElement const height = Math.max( body.offsetHeight, body.scrollHeight, html.clientHeight, html.offsetHeight, html.scrollHeight ) return height&#125; 文档滚出可视区的高度： 1234function getScrollTop () &#123; const scrollTop =(document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop return scrollTop&#125; 可视区高度：(我遇到的问题就是没有写window.innerHeight，手机谷歌浏览器获取的可视区高度跟别的浏览器就不一样，加上以后就没问题了) 12345678function getClient() &#123; const client = &#123;&#125; client.width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth client.height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight return client &#125;&#125; 判断到底底部： 123if (getDocumentHeight() - getScrollTop() &lt;= getClient().height) &#123; console.log('到达底部')&#125; 其他 元素相对文档偏移： 12345678function getOffset (el) &#123; const box = el.getBoundingClientRect() return &#123; top: box.top + window.pageYOffset - document.documentElement.clientTop, left: box.left + window.pageXOffset - document.documentElement.clientLeft &#125;&#125; 元素相对父元素的偏移： 12345678function getOffsetParent (el) &#123; const box = el.getBoundingClientRect() return &#123; top: box.top + window.pageYOffset - document.documentElement.clientTop, left: box.left + window.pageXOffset - document.documentElement.clientLeft &#125;&#125;]]></content>
      <categories>
        <category>每日一坑</category>
      </categories>
      <tags>
        <tag>移动端，javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex持久化插件-解决刷新数据消失的问题]]></title>
    <url>%2F2018%2F08%2F02%2FVuex%E6%8C%81%E4%B9%85%E5%8C%96%E6%8F%92%E4%BB%B6-%E8%A7%A3%E5%86%B3%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E6%B6%88%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[vuex可以进行全局的状态管理，但刷新后刷新后数据会消失，这是我们不愿意看到的。怎么解决呢，我们可以结合本地存储做到数据持久化，也可以通过插件-vuex-persistedstate。 1.手动利用HTML5的本地存储方法 vuex的state在localStorage或sessionStorage或其它存储方式中取值 在mutations,定义的方法里对vuex的状态操作的同时对存储也做对应的操作。 这样state就会和存储一起存在并且与vuex同步 问题 最直观的就是，手动写比较麻烦。 2.利用vuex-persistedstate插件插件的原理其实也是结合了存储方式,只是统一的配置就不需要手动每次都写存储方法 使用方法 安装 1npm install vuex-persistedstate --save 引入及配置 在store下的index.js中 12345import createPersistedState from "vuex-persistedstate"const store = new Vuex.Store(&#123; // ... plugins: [createPersistedState()]&#125;) 默认存储到localStorage 想要存储到sessionStorage，配置如下1234567import createPersistedState from "vuex-persistedstate"const store = new Vuex.Store(&#123; // ... plugins: [createPersistedState(&#123; storage: window.sessionStorage &#125;)]&#125;) 想使用cookie同理 默认持久化所有state 指定需要持久化的state,配置如下123456789101112import createPersistedState from "vuex-persistedstate"const store = new Vuex.Store(&#123; // ... plugins: [createPersistedState(&#123; storage: window.sessionStorage, reducer(val) &#123; return &#123; // 只储存state中的assessmentData assessmentData: val.assessmentData &#125; &#125; &#125;)] vuex引用多个插件的写法譬如：vuex提示的插件和持久化的插件一起使用，配置如下 1234567891011import createPersistedState from "vuex-persistedstate"import createLogger from 'vuex/dist/logger'// 判断环境 vuex提示生产环境中不使用const debug = process.env.NODE_ENV !== 'production'const createPersisted = createPersistedState(&#123; storage: window.sessionStorage&#125;)export default new Vuex.Store(&#123; // ... plugins: debug ? [createLogger(), createPersisted] : [createPersisted]&#125;) plugins要是一个一维数组不然会解析错误 点击跳转插件GITHUB地址]]></content>
      <categories>
        <category>vuex</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解HTTP读书笔记]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%9B%BE%E8%A7%A3HTTP%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一起来系统的学习一下http协议吧~ 了解web及网络基础通常使用的网络是在TCP/IP协议族的基础上运作的，而http属于它内部的一个子集。 TCP/IP协议族计算机与网络设备要相互通信，双方必须基于相同的方法。比如，如何探测到通信目标，由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要实现确定。不同硬件，操作系统之前的通信，所有的这一些都需要一种规则。而我们就把这种规则称为协议（protocol）。 TCP/IP是互联网相关的各类协议族的总称 一种说法是TCP/IP指TCP和IP这两种协议 另一种任务TCP/IP是在IP协议的通信过程中，使用到的协议族的统称。 TCP/IP的分层管理 应用层 ：决定了向用户提供应用服务时通信的活动，TCP/IP协议族内预存了各类通用的应用服务。比如：FTP文件传输协议和DNS域名系统服务就是其中两类，HTTP协议也处于该层。 传输层：提供处于网络连接中的两台计算机之间的数据传输。传输层有两个性质不同的协议： TCP传输控制协议和UDP用户数据协议。 网络层（网络互连层）：处理网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。 数据链路层：用来处理连接网络的硬件部分。包括控制操系统、硬件的设备驱动、NIC，及光纤等物理课件部分。 TCP/IP传输流 利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。 以http为例 发送端的客户端在应用层（HTTP协议）发出一个想看的某个WEB页HTTP请求。 为了传输方便，在传输层（TCP协议）把应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层 接收端的服务器在链路层接收到数据，按序往上次发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的HTTP请求。 与HTTP关系密切的协议：IP, TCP和DNS负责域名解析的DNS服务 DNS服务适合HTTP协议一样位于应用层，提供域名到IP地址之间的解析服务。 DNS协议提供通过域名查找IP，或逆向从IP地址反查域名的服务。 确保可靠性的TCP协议 TCP位于传输层，提供可靠的字节流服务。 所谓字节流服务：为了传输方便，将大块数据分割成以报文段为单位的数据包进行管理。 TCP协议为了确保准确无误的将数据送达到目标处，TCP协议采用了三次握手策略。TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。 三次握手： 握手过程中使用了TCP的标志： SYN (synchronize) 和 ACK （acknowledgement） 发送端首先发送一个带SYN标志的数据包给对方，接收端接收到后，回传一个带有SYN/ACK标志的数据包以示传输确认信息。最后发送端再回传一个带ACK标志的数据包，代表握手结束。 若握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包 除了上述三次握手，TCP协议还有其他各种手段保证通信的可靠性 负责传输的IP协议 IP协议属于网络层，几乎所有使用网络的系统都会用到IP协议，TCP/IP协议族中的IP指的就是网际协议。 IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件就是IP地址（网络地址，节点被分配到的地址）和MAC地址（硬件地址，网卡所属的固定地址）。IP地址可变换，但MAX地址基本上不会更改。 使用ARP协议凭借MAX地址进行通信：IP间通信以来MAC地址。在网络上，通常需要多台计算机和网络设备中转才能连接到对方。而进行中转时，会利用下一站中转设备中的MAX地址来搜索下一个中转目标。这时采用ARP协议，是一种用以解析地址的协议，根据通信方的IP地址可以反查出对应的MAC地址。 无论哪台计算机，哪台网络设备，它们都无法全面掌握互联网中的细节。 从输入一个域名到看到web页面之间发生的事 URI 和 URL URI: 统一资源标识符，用字符串标识某一互联网资源，由某个协议方案表示的资源的定位标识符，协议方案是指访问资源时所使用的协议类型名称。采用http协议时协议方案就是http。 URL：表示资源的地点（互联网上所处的位置） 简单的HTTP协议1.1持久连接节省通信量http协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。 为了解决上述TCP连接的问题，HTTP/1.1和一部分HTTP/1.0想出了持久连接 HTTPkeep-alive 的方法。只要一端没有明确提出断开连接，则保持TCP连接状态。 在HTTP/1.1中所有的连接默认都是持久连接，但在HTTP/1.0内并未标准化。 管道化持久连接使得多数请求以管道化方式发送成为可能。从前发送请求后需要等待并受到响应，才能发送下一个请求。管道化技术出现后，不再等待响应亦可直接发送下一个请求，这样能够做到同时发送多个请求，而不需要一个接一个地等待响应。 HTTP报文内的HTTP报文信息请求报文和响应报文的结构 实例 返回的HTTP状态码状态码类别： 类别 原因短语 1XX Informational(信息性状态码) 接收的请求正在处理 2XX Success(成功状态码) 请求正在处理完毕 3XX Redirection(重定向状态码) 需要进行附加操作以完成请求 4XX Clinet Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error (服务器错误状态码) 服务器处理请求出错 常见状态码： 200 ：表示从客户端发来的请求在服务器端正常处理。 204 No Content: 服务器接收的请求已处理成功，但返回的响应报文中不含实体的主体部分，也不允许返回任何实体的主体，浏览器显示的页面不发生更新。一般只需要从客户端往服务器发送信息，而客户端不需要发送新信息内容的情况下使用。 206 Partial Content: 表示客户端进行了范围请求，而服务器成功执行了这部分get请求。响应报文中包含由Content-Range指定范围的实体内容。 301: 永久性重定向。请求的资源已被分配了新的URI，以后应使用资源现状所指的URI。 302： 暂时性重定向。资源已被分配了新的URI，希望用户本地使用新的URI。 303： 和302有着相同的功能，但303明确表示客户端应采用GET方法获取资源。 304： 如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。 与重定向无关。 307：与302功能相同。但不会从POST变成GET。 当301、302、303响应状态码返回时，计划所有的浏览器都会把POST改成GET，并伸出请求报文的主体，之后请求会自动再次发送 400： 请求报文语法错误（一般是传参的问题） 401：发送的请求需要通过HTTP认证的认证信息。 403: 被服务器拒绝，未获得访问权限。 404： 服务器上无法找到请求资源。 500： 服务器端执行请求时发生错误。 503：服务器暂时处于超负载或停机维护，无法处理请求。 与HTTP协作的Web服务器代理服务器和客户端的中间层，接收客户端发送的请求并转发给服务器同时接收服务器返回的响应转发给客户端 作用： 利于缓存技术，减少网络带宽的流量 组织内部针对特定网站的访问控制等 分类： 是否使用缓存 缓存代理： 代理转发响应时，缓存代理会预先将资源的副本保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器获取资源，而将之前缓存的资源作为响应返回。 是否修改报文 透明代理： 不对报文做任何加工。 非透明代理： 对报文内容进行加工。 网关网关能使通信线路上的服务器提供非HTTP协议服务。 利用网关能提高通信安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接安全。 隧道可按照要求建立起一条与其他服务器通信的线路，届时使用SSL等加密手段进行通信，确保客户端能与服务器进行安全通信。 隧道本身不解析HTTP请求，原样中转给服务器。 HTTP首部HTTP/1.1通用首部字段Cache-Control HTTP缓存相关点击跳转Connection 控制不再转发给代理的首部字段 Connection：Upgrade 管理持久连接 Connection: Keep-Alive =》 持久连接 Connection: close： =》 关闭持久连接 确保Web安全的HTTPSHTTP的缺点通信使用明文可能会被窃听问题：TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窃视。 解决：加密处理防止窃听： 通信加密：通过和SSL或TLS的组合使用加密HTTP的通信内容。 内容加密：客户端对HTTP报文进行加密处理再发生。前提是要求客户端和服务器同时具备加密和揭秘和解密机制。不然还是有被篡改的风险。 不验证通信方的身份可能遭遇伪装任何人都可以发送请求 解决：查明对方的证书 如果使用SSL，SSL不仅提供加密处理，而且使用一种被称为证书的手段可用于确定方。 证书由第三方机构颁发，证明服务器和客户端是实际存在的。 伪造证书技术上很困难。 无法证明报文完整性，可能已遭篡改防止篡改： 有必要使用HTTPS HTTP+加密+认证+完整性保护=HTTPS HTTPS是身披SSL外壳的HTTP HTTPS采用混合加密的机制 HTTPS可以使用客户端证书。以客户端证书进行客户端认证。 每看到最后几章就不想看了...]]></content>
      <categories>
        <category>网络协议</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[横向滑动以及图片拼凑遮罩]]></title>
    <url>%2F2018%2F07%2F31%2Fcss%E5%B0%8F%E8%AE%B0-%E6%A8%AA%E5%90%91%E6%BB%91%E5%9D%97%E5%8F%8A%E6%8B%BC%E5%87%91%E9%81%AE%E7%BD%A9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[css小记：横向滑动以及图片拼凑遮罩 横向滑动效果： html部分： 123456789&lt;ul class="precautions"&gt; &lt;li class="precautions-block" v-for="(item, index) in 4" :key="index"&gt; &lt;h4&gt;注意事项标题&#123;&#123;index + 1&#125;&#125;&lt;/h4&gt; &lt;p&gt; 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 &lt;/p&gt; &lt;div class="step"&gt;&#123;&#123;index + 1&#125;&#125;/4&lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; css部分: 123456789101112131415161718192021222324252627282930313233343536373839.precautions&#123; width:100%; display: inline; white-space: nowrap; // 不换行 overflow-x: scroll; // 横向scroll float: left; overflow-y: hidden; margin-top: 0.3rem; .precautions-block&#123; box-shadow: 0px 0.08rem 0.15rem #EAECF3; width: 6rem; padding: .1rem .3rem .6rem .3rem; background-color: #fff; margin-right: .3rem; position: relative; display:inline-block; white-space: normal; // 内部文字换行 h4&#123; margin: .4rem 0; &#125; p&#123; line-height: 1.5; &#125; // 四分之一圆 .step&#123; background-color: #23498D; color: #f1f1f1; width: .6rem; height: .6rem; border-radius:100% 0 0 0; position: absolute; bottom: 0; right: 0; line-height: .6rem; text-align: center; font-size: .24rem; &#125; &#125;&#125; 拼凑示例遮罩效果： html部分： 12345678910&lt;div class="mask" v-if="sample"&gt; &lt;div v-for="(img, index) in 6" :key="index"&gt; &lt;p&gt; &lt;img src="./@2x.png" v-if="img%2 !== 0"&gt; &lt;/p&gt; &lt;p&gt; &lt;img src="./pgjg@2x.png" v-if="img%2 === 0"&gt; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; css部分： 1234567891011121314151617181920212223.mask&#123; height: 100%; width: 100%; position: fixed; left: 0; top: 0; z-index: 999; background-color: rgba(0, 0, 0, .5); div&#123; height: 36%; width: 50%; display: inline-block; text-align: center; float: left; p&#123; height: 50%; img&#123; width: 1.5rem; height: 1.5rem; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS小记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP缓存/浏览器缓存]]></title>
    <url>%2F2018%2F07%2F31%2FHTTP%E7%BC%93%E5%AD%98-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[浏览器缓存就是把已经请求过的web资源拷贝一份副本存储在浏览器中，第二次请求时会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。 浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的也就是Response Headers 强缓存 左图为已经有缓存数据的情况：缓存未失效，直接使用缓存数据 表现为： Status Code: 200 (from memory cache) 或 （from disk cache ） 右图为缓存数据失效的情况：向源服务器请求数据，将数据和缓存规则存入缓存（一般为浏览器内存或磁盘中） 那么问题来了，浏览器怎么知道缓存是否失效呢？根据响应头里的 Expires 和 Cache-Control 来判断 Expires 是HTTTP1.0版本定义的缓存字段，值为服务器端返回的到期时间（绝对时间），如果客户端的时间与服务器端的时间有误差，会导致缓存命中的误差。 Cache-Control 是HTTP1.1版本定义的缓存字段 值 意义 private 客户端可以缓存 public 客户端和代理服务器可以缓存 max-age=xxx 缓存在xxx秒后失效 no-cache 需要使用协商缓存来验证缓存数据 no-store 不缓存 Expires和Cache-Control同时存在时Cache-Control值为max-aga=xxxx 会直接忽略Expires 。 ` 上图可以看到，从浏览器内存中返回的数据，并没有向源服务器返回数据 Cache-Control对应的是2592000s以后缓存失效，也就是30天内请求这个url都直接从浏览器缓存中得到数据。 Expires: 2018年8月22日07:23:08过期 按照之前说的 Expires会被忽略 协商缓存 左图为缓存未失效时，先向缓存得到Etag或者Last-Modified，然后请求服务器Request Headers会带上If-None-Match(值就是上一次请求返回的Etag 唯一标识) 或If-Modified-Since （上一次请求返回的资源最后修改时间）, 服务器收到If-None-Match 与唯一标识对比，没有改变 或 If-Modified-Since 与资源最后修改时间对比，没有改变，即响应HTTP 304告诉浏览器使用浏览器缓存。浏览器直接从缓存里拿到数据。 右图之前的步骤同上，但If-None-Match 与资源唯一标识不同 或 If-Modified-Since小于资源最后修改时间，则表示缓存的资源已经失效，返回状态码 200 并且返回最新的数据，浏览器缓存数据。 通过上面的分析可以看出协商缓存：是根据响应头中的Etag， Last-Modified以及请求头中的If-None-Match，If-Modified-Since 字段来判断是否过期。 缓存规则优先级及生效情况： 强缓存与协商缓存同时存在，如强缓存还在生效期，强缓存覆盖协商缓存； 强缓存的expires和cache-control同时存在，则cache-control覆盖； 协商缓存Etag和Last-Modified同时存在时，Etag覆盖Last-Modified; 服务器配置http缓存(nginx为例)12345location ~ .*\.(js|css)$ &#123; expires 1d; add_header Cache-Control max-age=315360000;&#125; #nginx中Last-Modified 和 Etag是默认打开的 以上配置可以对应请求的响应头 常见的HTTP请求头及响应头 请求头字段 说明 示例 Accept 可接受的响应内容类型 Accept： application/json Accept-Encoding 可接受的响应内容的编码方式 Accept-Encoding: gzip, deflate Accept-Charset 可接受的字符集 Accept-Charset: utf-8 Accept-Language 可接受的响应内容语言列表 Accept-Language: zh-CN,zh;q=0.9 Authorization 用于表示HTTP协议中需要认证资源的认证信息 Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE== If-None-Match 设置客户端ETag，如果和服务端接受请求生成的ETage相同，允许服务端返回304 Not Modified If-None-Match: W/“4fd3169315a2307bef83eb3fce4d1382” Connection 用来指定当前的请求/回复中的，是否使用缓存机制。 Connection: keep-alive Content-Type 请求体的MIME类型 （用于POST和PUT请求中） Content-Type：application/json;charset=UTF-8 Date 发送该消息的日期和时间（以RFC 7231中定义的”HTTP日期”格式来发送） Date: Dec, 26 Dec 2015 17:30:00 GMT Referer 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。Referer其实是Referrer这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用Referer了。 Referer: http://itbilu.com/nodejs User-Agent 浏览器的身份标识字符串 Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 Cookie 由之前服务器通过Set-Cookie（见下文）设置的一个HTTP协议Cookie Cookie: $Version=1; Skin=new; 响应头字段 说明 示例 Access-Control-Allow-Origin 指定哪些网站可以跨域源资源共享 Access-Control-Allow-Origin: * Age 响应对象在代理缓存中存在的时间，以秒为单位 Age: 12 Cache-Control 通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒 Cache-Control: max-age=3600 Date 此条消息被发送时的日期和时间(以RFC 7231中定义的”HTTP日期”格式来表示) Date: Tue, 15 Nov 1994 08:12:31 GMT ETag 对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列 ETag: “737060cd8c284d8af7ad3082f209582d” Expires 指定一个日期/时间，超过该时间则认为此回应已经过期 Expires: Thu, 01 Dec 1994 16:00:00 GMT Last-Modified 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示) Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT Refresh 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向 Refresh: 5; url=http://itbilu.com Server 服务器的名称 Server: nginx/1.6.3 Set-Cookie 设置HTTP cookie Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1 Content-Encoding 服务端能够发送压缩编码类型 Content-Encoding: gzip Content-Type 服务端发送的类型及采用的编码方式 text/html; charset=GB2312]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript高级程序设计-读书笔记]]></title>
    <url>%2F2018%2F07%2F30%2FjavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[强化js基础，来看一看传说中的小红书 1.JavaScript 简介JavaScript的实现 核心(ECMAscript) 文档对象模型(DOM) 浏览器对象模型(BOM) ECMAScript宿主: WEB浏览器 Node平台 Adobe Flash 大致组成部分： 语法 类型 语句 关键字 保留字 操作符 对象 文档对象模型(DOM)是真的XML但经过扩展用于HTML的应用呈现变成接口(API)。DOM把整个页面映射为一个多层节点结构。 浏览器对象模型(BOM)2.HTML中使用javascriptscript标签6个属性： async：可选。表示立即下载脚本，不妨碍页面其他操作； charset: 可选。表示src属性指定代码的字符集； defer: 可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只外部脚本有效； src: 可选。表示包含要执行代码的外部文件； type: 可选。表示编写代码使用的脚本语言内容类型，不指定默认为text/javascript; language：已废弃。 使用script元素的两种情况：直接在页面嵌入javascript代码 和 包含外部javascript。 带src属性的script元素不应该在其script标签之间包含额外的javascript代码。只会下载并执行外部脚本文件，嵌入的代码会被忽略。 script元素的src属性还可以包含来自外部域的javascript文件与img元素的src属性相似。（可以利用这一点进行跨域请求）,同时也要考虑安全性。 只要存在defer和async属性，浏览器会按照script元素在页面中出现的先后顺序对他们一次解析。 标签的位置 传统做法：放在head元素中。 但这样会影响页面呈现，等javascript代码被下载解析执行完成以后才开始呈现页面内容·。 现在web应用：放在body元素页面内容后面 解析javascript代码之前，页面内容将完全呈现 延迟脚本defer属性: script标签放在head中也会将script脚本延迟到标签后执行(只适用于外部脚本) 异步脚本async属性：异步下载和执行script脚本（注意：互相有依赖关系的脚本不适用，因为无法保证加载顺序） 3.基本概念语法区分大小写例如： test和Test是两个不同的变量。 标识符就是指比变量、函数、属性的名字或函数的参数。 第一个字符必须是字母、下划线_或一个美元符号$ 其他字符可以是字母、下划线、美元符号或数字 按照惯例ECMAScript标识符采用驼峰大小写格式。 注释 // 单行注释 /* *多行注释 *啦啦啦 */ 严格模式ECMAScript 5引入严格模式。 顶部添加“use strict” 语句推荐语句结尾写分号 ； （我就不写分号…） 单句if判断推荐写花括号； 关键字和保留字不能作为标识符（也就是声明的变量名） 关键字 break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try ** ** 保留字：尽管在这门语言中没有任何特定用途，但他们有可能将来被用作关键字 abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public 非严格模式下保留字有缩减 数据类型 5种基本数据类型： Undefined、Null 、Boolean、Number、String。 一种复杂类型： Object typeof操作符检测数据类型的一种手段，返回的结果如下 “undefined”(值未定义) “boolean”(布尔类型) “string”(字符串类型) “number”(数值类型) “object”(对象或null) “function”(函数) undefined类型声明未赋值时 未声明也未定义的变量，访问时会报错 但typeof操作符会返回”undefined” Null类型空对象指针 所以typeof返回“object” 如果定义变量准备将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样直接判断！=null就可以指定相应变量是否保存了一个对象引用。 Boolean类型两个字面量：true和false 转换Boolean类型（Boolean()） 数据类型 转换为true值 转换为false值 Boolean true false String 任何非空字符串 “” 空字符串 Number 任何非零数字值（包含无穷大） 0和NaN Object 任何对象 null undefined undefiend if语句会隐式转换boolean Number类型ECMAScript能保存的 最小数值存在于Number.MIN_VALUE中，大多数浏览器中这个值时5e-324 最大数值保存在Number.Max_VALUE中，大多数浏览器中这个值时1.7976931348623157e+308 如果某次结果得到一个超出javascript数值范围的值，那么这个数值将被自动转换成特殊Infinity值。 负数 -Infinity (负无穷） 正数 Infinity(正无穷) 将无法参与下一次计算 NaN非数值，一个特殊数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。 ECMAScript中，任何数值除以0会返回NaN NaN与任何值都不相等包括自身 isNaN()函数，可以确定这个参数是否“不是数值”，接收到一个值后，尝试将这个值转换为数值例如字符串“10”或Boolean值，而任何不能被转换为数值的值都会导致这个函数返回true 数值转换Number() true和false将被转换为1和0 如果时数字值只是简单的传入与返回 如果是null返回0 如果是undefined返回NaN 如果是字符串，遵循以下规则 如果字符串中只包含数字则转换为数字‘012’会转换为12，0前面的会被忽略 如果字符串中包含有效浮点格式如“1.1”则转换为1.1，0在前的话同样忽略 如果包含有效的十六进制格式，则转换为相同大小的十进制整数值 如果字符串是空，则转换为0 如果字符串中包含除以上格式之外的字符则转换为NaN 如果是对象，则调用对象的valueOf()方法然后依照前面的规则进行转换返回的值。如果转换的结果是NaN,则调用对象的toString（）方法，然后再次依照前面的规则转换返回的字符串值。 parseInt() 忽略字符串前面的空格，直到找到第一个非空字符串，如果不是数字字符或者符号返回NaN 如果第一个字符是数字字符会继续解析第二个，知道解析完所有后续或者遇到非数字字符。不解析小数 parseFloat() 与parseInt()类似但遇到小数点会继续解析，知道遇到第二个小数点 String类型包含一些特殊的字面量 字面量 含义 \n 换行 \t 制表 \b 空格 \r 回车 \f 走纸换页 \ \ 斜杠 \ ‘ 单引号 \ “ 双引号 \xnn \ unnnn 字符串特点ECMAScript 中字符串是不可变的，也就是说，字符串一旦被创建，值不能改变，要改变某个变量保存的字符串，首先要销毁原来的字符串，然后在用另一个包含新值的字符串填充该变量。 转换为字符串toString() null和undefined没有这个方法 在不确定是否为null或undefined的情况下，还可以使用转型还是String(),遵循以下原则： 如果值有toString()方法则调用该方法并返回结果 如果是null则返回null 如果是undefined则返回undefined Object类型ECMAScript中对象其实就是一组数据和功能的集合。对象可以通过new操作符后跟要创建的对象类型的名称来创建。 Object的每个实例都具有下列属性和方法 constructor: 保存用户创建当前对象的函数。 hasOwnProperty:用于检查给给定的属性在当前对象实例中(而不是在实例的原型中)是否存在。传入的参数必须以字符串形式指定 isprototypeOf(object): 用于检查传入对象是否是传入对象的原型 propertyIsEnumerable(propertyName): 用于检查给定的属性是否能使用for in 语句来枚举 toLocaleString() : 返回对象的字符串表示 valueOf（）： 返回对象的字符串，数值或布尔表示，通常与toString()方法的返回值相同 操作符一元操作符 递增和递减操作符 1// 前置和后置的++ -- 一元加和减操作符 1// 前置+或- 隐式转换数值类型 位操作符 按位非(NOT) 由~表示，执行按位非的结果就是返回数值的反码。按位非是ECMAScript操作符中少数几个与二进制计算有关的操作符之一。 123var num1 = 25; // 二进制 00000000000000000000000000011001 var num2 = ~num1; // 二进制 11111111111111111111111111100110 alert(num2); // -26 按位非操作的本质：操作数的负值减 1。 按位与(AND) 由&amp;表示 按位与操作只在两个数值的对应位都是1时才返回1，任何一位是0，结果都是0. 1 按位或(OR) 由|表示 按位或操作在有一个位是1的情况下返回1，两个都为0的情况下才返回0 先略过位操作符（理解无能） 布尔操作符 逻辑非(!) 首先将它的操作数转换为一个布尔值，在对其求反 两个!!实际上就是模拟转换布尔 逻辑与 &amp;&amp; 如果第一个操作数能够决定结果，那么就不会在对第二个操作数求值 如果第一个操作数是false,则无论第二个操作数是什么值，结果都不再可能是true 两个都为true的就返回第二个，都为false返回第一个，一个为false返回false的那个 逻辑或|| 第一个为true返回第一个 第一个为false，第二个为ture返回第二个 第一个为false, 第二个为false 返回第二个false 返回最终起决定因素的那个&amp;&amp;最终决定为false的，|| 最终决定为true的，都不满足就只好返回第二个 语句if语句判断语句 搭配else 或else if do while语句一种后测试循环语句 先执行一次再测试条件 适用于循环体中的代码至少要被执行一次的情形 while语句前测试循环语句，循环体内执行之前对出口条件求值 for语句前测试循环语句，循环之前初始化变狼和定义循环后要执行的代码。 for in 语句精准的迭代语句，可用来枚举对象的属性。 123for (let key in window) &#123; document.write(key)&#125; for in 循环输出的属性名的顺序是不可预测的 要迭代的对象的变量值为null或undefined，则不执行循环体。所以在使用前检测该对象的值不是null或undefined break 和 continue语句用于循环中精确控制代码执行，break立即跳出循环，continue立即退出进行下一次循环 with语句严格模式下不允许使用with语句 否则视为语法错误 switch语句switch语句在比较值的时候使用的是全等操作符，因此不会发生类型转换 多个if elseif 时使用switch比较好 函数推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。 但其实写业务代码时是根据场景来的 理解参数ECMScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么类型。 原因是ECMscript中的参数在内部使用一个数组来表示的。 arguments对象是类数组，所以可以使用[0]访问也有length属性。 没有重载ECMScript 函数不能像传统意义上那样实现重载。例如JAVA可以为一个函数编写两个定义。 ECMScript中同名函数会被后一个覆盖，但我们可以通过检查传入的参数的类型和数量并作出不同的反应，模仿方法的重载。 4.变量、作用域和内存问题基本类型和引用类型 基本类型： Nndefined、Null、Boolean、Number、String。 引用类型： 对象，数组。 检测类型typeof操作符是确定一个变量是字符串，数值，布尔值，还是undefined的最佳工具。 如果变量是一个对象或null，则typeof操作符会返回object。typeof检测函数时会返回function. 检测引用类型时可以使用instanceof，如果变量是给低昂引用类型的实例，那么instanceof会返回true。 根据规定，所有引用类型的值都是object的实例，因此在检测一个引用类型值和object构造函数时，会返回true。 执行环境和作用域在web浏览器中，全局执行环境被认为是window对象，因此所全局变量和函数都是作为window对象的属性和方法创建的。 每个函数都有自己的执行环境。 标识符解析是沿着作用域链一级一级的搜索标识符的过程。搜索过程始终从作用域链的最前端开始，然后逐级向后回溯，直至找到标识符为止，如果找不到标识符，通常会导致错误发生。 函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。 垃圾收集javascript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。 简单的原理：找出那些不再继续使用的变量，然后释放其占用的内存。为此垃圾收集器会按照固定的时间间隔，周期性的执行这一操作。 局部变量只有在函数执行的过程中存在。而在这个过程中，会为局部变量在栈或堆上分配相应的空间，以便存储它们的值。然后在函数值使用这些变量，知道函数执行结束。释放局部变量。 标记清除当变量进入环境，例如函数中声明一个变量时，标记为进入环境。逻辑上来讲永远不能释放进入环境的变量，当变量离开环境时，则将其标记为离开环境。 引用计数不太常见的一种垃圾收集策略。 当一个值的引用次数为0时，可以将其回收。 管理内存确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是执行中的代码只保存必要的数据。一旦不再有用，最好通过将其值设置为null来释放其引用。 不过接触一个值的引用并不意味着自动回收该值所占用的内存。接触引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。 5.引用类型Object类型声明方法: new关键字和字面量 访问方法： 点或[] []可以用来访问会导致语法错误的字符，或者属性名使用的是关键字或保留字。 Array类型检测数组 instanceof Array.isArray() 转换方法 toString() toLocaleString() valueOf() 返回，分隔的字符串 join() 可以使用不同的分隔符构建这个字符串 如果数组中某一项值是null或undefined，那么这句个方法返回的结果以空字符串表示 栈方法 push 从数组末尾添加 pop 从数组末尾移除一项 重排方法 reverse 翻转数组项的顺序 sort() 默认从小到大排序，也可以传入函数，按照函数的规则排序 操作方法 concat 基于当前数组中所有项创建一个新数组。 slice splice 位置方法 indexOf lastIndexOf 迭代方法 every filter forEach map some 归并方法 reduce reduceRight( Date类型date类型使用UTC 1970年1月1日零时开始经过的毫秒数来报错日期，能够精确到1970年1月1日之前或之后的285616年 new Date() 创建日期对象 Date.parse()方法接受一个表示日期的字符串参数，尝试返回相应的毫秒数。如果传入的字符串不能表示日期会返回NaN. 超多API暂时忽略 RegExp类型匹配模式3个标志 g: 表示全局，应用于所有字符串，而非发现第一个匹配项时立即停止； i: 表示不区分大小写，在确定匹配项时忽略字符串大小写； m: 表示多行，即到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项； 元字符必须转义：（[{\^$|)?*+.]}） 面向对象的程序设计小结 工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代； 构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符。不过，构造函数也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象，因此没有理由不在多个对象见共享函数。 原型模式，使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用公祖奥函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享属性和方法 原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即子类型构造函数内部调用超类型构造函数。这样可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。 函数表达式小结 函数表达式不同于函数声明，函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。 在无法确定如何引用函数的情况下，递归数就会变得比较复杂 ...表示看不下去了]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js小整理]]></title>
    <url>%2F2018%2F07%2F29%2Fjs%E5%B0%8F%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[偶尔过一遍js知识 1.typeof 对于基本类型除了null都可以显示正确的类型 对于对象，除了函数都会显示object 对于null会显示object 可以使用Object.prototype.toString.call(xxx)获得正确类型返回类似[Object Type]的字符串 2.类型转换 转Boolean 条件判断除了undefined,null,false,NaN,’’,0,-0 其他所有值都转为true 对象转基本类型：首先会调用valueOf然后调用toString。并且这两个方法可以重写。 Symbol.toPrimitive 也可以重写,该方法在转基本类型时调用优先级最高。 1234567891011121314151617let num = &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return '1'; &#125;, [Symbol.toPrimitive]() &#123; return 2; &#125;&#125;num // &#123;valueOf: ƒ, toString: ƒ, Symbol(Symbol.toPrimitive): ƒ&#125;1+num // 3'1'+num // '12' 四则运算符：加法运算时，其中一方时字符串类型就会把另一个也转化为字符串类型。 其他运算只要其中一方是数字，那么另一方就转为数字。 12[1,2] + [2,1] // '1,22,1'// 加法会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串 3.原型prototype基本上所有的函数都有这个属性，除了Function.prototype.bind()创建的对象 声明一个函数时，这个属性就被自动创建了 这个属性的值是一个对象（也就是原型），只有一个属性constructor constructor对应构造函数 12function Fn() &#123;&#125;Fn.prototype // &#123;constructor: ƒ&#125; constructor是一个共有且不可枚举的属性。一旦我们改变了函数的prototype，那么这个对象就没有这个属性了。 12Fn.prototype = &#123;a: 1&#125;Fn.prototype // &#123;a: 1&#125; constructor属性的作用 让实例对象知道是什么函数构造了它 如果想给某类库中的构造函数增加一些自定义的方法，就可以通过xx.constructor.method来扩展 proto 这是每个对象都有的隐式原型，指向创建该对象的构造函数原型 因为在js中没有类的概念，为了实现类似继承的方式，通过 proto 将对象的原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。 实例对象 proto 的 产生: 使用new操作符时，生成的实例对象拥有 proto __属性 12function Fn() &#123;&#125;// 这个函数是Function的实例对象 function是个语法糖 内部调用了 new Function 总结 Object是所有对象的爸爸，所有对象都可以通过 proto 找到它 Function是所有函数的爸爸，同上 Function.prototype和Object.prototype是两个特殊的对象，他们由引擎创建 除了以上两个特殊对象，其他对象都是通过构造器new出来的 函数的prototype是一个对象也就是原型 对象的 proto 指向原型， proto __将对象和原型链接起来组成原型链 4.New new的过程 新生成一个对象 链接到原型 绑定this 返回新对象 12345678910111213// 调用new时发生的四件事，试着实现一个newfunction create() &#123; // 创建一个空对象 let obj = new Object() // 获得构造函数 也就是传进来的第一个参数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定this执行构造函数 let result = Con.apply(obj, arguments) // 确保new出来的是一个对象 return typeof result === 'object' ? result : obj&#125; new 运算符优先级 123456789101112131415function Fn() &#123; return this&#125;Fn.getName = function () &#123; console.log('1')&#125;Fn.prototype.getName = function () &#123; console.log('2')&#125;new Fn.getName() // 1new Fn().getName() // 2-------------执行顺序-------------new (Fn.getName())(new Fn()).getName() 5.Instanceof可以正确判断对象的类型，内部机制是通过判断对象的原型链中是不是能找到类型的prototype. 6.this 有对象调用: 指向调用它的对象 没有对象调用: 指向window new出来的实例: 指向实例 call apply bind 改变指向传入的对象 箭头函数没有this，this指向取决于箭头函数外第一个不是箭头函数的函数 7.闭包函数A返回一个函数B，并且B中使用了函数A的变量，函数B就被称为闭包 8.深拷贝浅拷贝一个变量赋值一个对象，那么两者的值引用同一个，其中一方改变，另一个相应改变。实际业务重要解决这个问题 1.浅拷贝 assign123456let a = &#123; age: 1&#125;let b = Object.assign(&#123;&#125;, a)a.age = 2console.log(b.age) // 1 扩展运算符 … 123456let a = &#123; age: 1&#125;let b = &#123;...a&#125;a.age = 2console.log(b.age) // 1 浅拷贝只能解决第一层问题，如果接下去的值里还有对象，就需要深拷贝 2.深拷贝 JSON.parse(JSON.stringify(object))局限 忽略undefined 不能序列化函数 不能解决循环引用的对象 如果有以上三种情况 可以使用lodash的深拷贝函数 9.防抖和继承防抖多次执行变为最后一次执行，节流每隔一段时间执行，不频繁执行 10.继承ES5 Object.create() 12345678910111213141516function Super() &#123;&#125;Super.prototype.getNumber = function() &#123; return 1&#125;function Sub() &#123;&#125;let s = new Sub()Sub.prototype = Object.create(Super.prototype, &#123; constructor: &#123; value: Sub, enumerable: false, writable: true, configurable: true &#125;&#125;)// 以Sub为构造函数以Super为原型 浏览器小结1.Event loopjs执行过程中产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步代码，会被挂起并加入到Task队列中。一旦执行栈为空，Event Loop 就会从Task队列中拿出需要执行的代码并放入执行栈中执行 不同的任务源会被分配到不同的Task队列中，任务源可以分为 微任务（microtask） ES6中称为jobs 包括： process.nextTick promise Object.observe MutationObserver 宏任务（macrotask）ES6中称为task script setTimeout setInterval setImmediate I/O UI rendering Event loop顺序 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染UI 然后开始下一轮Event loop，执行红任务中的异步代码 2.渲染机制 处理html并构建dom树 处理css构建cssdom树 将dom和cssdom合并成一个渲染树 根据渲染树的布局，计算每个节点的位置 调用GPU绘制， 合成图层，显示在屏幕上 3.重绘（Repaint）和回流(Reflow) 重绘是当前节点需要更改外观而不会影响布局，比如改变color就称为重绘 回流是布局或者几何属性需要改变 回流必定发生重绘，重绘不一定引发回流。回流所需的成本比重绘高的多，改变深层次的节点很有可能导致父节点一些了回流。 导致性能问题的几个点 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 参考链接: https://yuchengkai.cn/docs/zh/frontend/]]></content>
      <categories>
        <category>温故</category>
      </categories>
      <tags>
        <tag>小记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS揭秘-读书笔记]]></title>
    <url>%2F2018%2F07%2F16%2FCSS%E6%8F%AD%E7%A7%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[CSS如今面临的挑战是：在保证DRY、可维护、灵活性、轻量级并且尽可能符合标准的前提下，把我们手中的这些css特性转化为网页中的各种创意。（作者为W3C特邀专家，强调 CSS 代码的 DRY 原则是一个贯穿本书的主题，提供了很多css技巧） DRY是Don&#39;t Repeat Yourself 的首字母缩写，意思是不应该重复已经做过的事。是一种变成理念，旨在提升代码某方面的可维护性。改变某个参数时，只改尽量少的地方，最好是一处 CSS编码技巧 尽量少的代码重复 1234567891011button&#123; padding: 6px 16px; border: 1px solid #446d88; background: #58a linear-gradient(#77a0bb, #58a); border-radius: 4px; box-shadow: 0 1px 5px gray; color: white; text-shadow: 0 -1px 1px #335166; font-size: 20px; line-height: 30px; &#125; 例如： 上面是一个按钮的样式,字体大小和行高为固定的值 问题1： 想要改变字体大小时，为了垂直居中，line-height也要重新赋值 解决： 可以将行高按照字体大小的比例写（不给固定值） 12font-size: 20px;line-height: 1.5; 问题2：当改变父级字体大小时，不得不修改每一处使用绝对值的样式； 解决：使用em ，rem , 百分比； 假设html的font-size：16px; 那么可以改写为： 1234567891011button&#123; padding: .375rem 1rem; border: .0625rem solid #446d88; background: #58a linear-gradient(#77a0bb, #58a); border-radius: .25rem; box-shadow: 0 .0625rem .3125rem gray; color: white; text-shadow: 0 -0.0625rem .0625rem #335166; font-size: 1.25rem; line-height: 1.5;&#125; 问题3：改变按钮颜色时，根据上面的样式需要改变background、box-shadow、text-show； 解决：把半透明的黑色或白色叠加在主色调上； 1234567891011button&#123; padding: .375rem 1rem; border: .0625rem solid rgba(0, 0, 0, .1); background: #58a linear-gradient(hsla(0,0%,100%,.2), transparent); border-radius: .25rem; box-shadow: 0 .0625rem .3125rem rgba(0, 0, 0, .5); color: white; text-shadow: 0 -0.0625rem .0625rem rgba(0, 0, 0, .5); font-size: 1.25rem; line-height: 1.5; &#125; 这样只需要覆盖background-color就可以了 123456button.cancel&#123; background-color:#c00 ;&#125;button.ok&#123; background-color: #6b0;&#125; 1. currentColor : 表示“当前的标签所继承的文字颜色”例如：想让所有hr自动与文本颜色保持一致 1234hr &#123; height: .5em; background: currentColor;&#125; 2.inherit : 继承父级样式（伪元素则为宿主元素） 人类视觉偏差： 需要做些调整 一个完全垂直居中的物体，视觉上可能并不居中，可以将中心点向上挪； 圆形字，例如0与矩形字相比，显得小一些，需要稍微放大； 这些视觉上的错觉在任何形式的视觉设计中都普遍存在，需要做些调整； 关于响应式网页设计的一些建议 在利用媒体查询的同时最好做到以下几点，减小媒体查询成本 使用百分比长度，或使用视口相关的单位(vw,vh,vmin,vmax); 当需要在较大分辨率下得到固定宽度时，使用max-width而不是width; 不要忘记为替换元素（img,video,iframe等），设置一个max-width为100%； 加入背景图片需要完整铺满一个容器，background-size:cover; 当图片或其他元素以行列式进行布局时，推荐使用flexbox或display: inline-block； 使用多列文本时，指定列宽而不是指定列数，这样它就可以在较小的屏幕上自动显示为单列布局; 总的来说，思路是尽最大努力实现弹性可伸缩的布局，并在媒体查询各个断点区间内指定相应的尺寸。 合理使用简写 例如： 123background: url(tr.png) no-repeat top right / 2em 2em, url(br.png) no-repeat bottom right / 2em 2em, url(bl.png) no-repeat bottom left / 2em 2em; 可以看到有很多重复的部分，可以改写为： 12345background: url(tr.png) top right, url(br.png) bottom right, url(bl.png) bottom left;background-size: 2em 2em;background-repeat: no-repeat; 现在只需要改一个地方就可以控制size和repeat了 预处理器 小型项目不推荐使用，未来说不定预处理器受欢迎的特性会加入到原生css中 例如：强大的原生css特性 calc(): 可以实现计算，例如想要一个100% - 50px的宽度，可以写为： 1width: calc(100% - 50px); 背景与边框 半透明边框 12border: 10px solid hsla(0,0%,100%,.5);background: white; 给了一个半透明边框，但实际效果看起来却像是与背景色颜色一样的边框 默认情况下，背景会延伸到边框所在的区域下层。并且在半透明边框处透出了白色的背景。 解决： 利用裁剪属性 background-clip 123border: 10px solid hsla(0,0%,100%,.5);background: white;background-clip: padding-box; 这样浏览器会将内边距外沿背景裁切掉。得到半透明边框效果。 多重边框 1.box-shadow方案： 前3个参数为0，第四个参数为狂战半径，可能得到一个像实线的边框，利用text-shadow的逗号分隔语法，可以实现多个投影，即多边框效果； 1234background: yellowgreen;box-shadow: 0 0 0 10px #655, 0 0 0 15px deeppink, 0 2px 5px 15px rgba(0,0,0,.6); 需要注意的是，box-shadow不影响布局，不受box-sizing影响，可以利用内边距或外边距模拟边框所需要占据的空间，inset关键字可以绘制内圈； 2. outline方案: 描边（适用于两层边框）如果只需要两层边框，可以先写一个常规边框再加上outline属性产生外层边框 123background: yellowgreen;border: 10px solid #655;outline: 5px solid deeppink; outline-offset属性可以控制它跟元素边缘之间的间距 局限： 只适用于两层边框 不贴合border-radius圆角（未来有可能改为贴合） 灵活的背景定位 background-position属性设置背景定位: 默认以padding box为准； background-origin可以修改偏移以什么为准，backgroun-origin: content-box;以内容区的边缘作为基准 calc()：不确定宽高的情况下可以使用calc(100% - 20px)写background-position; 边框内圆角 1234567891011121314151617&lt;div class="something-meaningful"&gt; &lt;div&gt; I have a nice subtle inner rounding, don't I look pretty? &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .something-meaningful &#123; background: #655; padding: .8em; &#125; .something-meaningful &gt; div &#123; background: tan; border-radius: .8em; padding: 1em; &#125;&lt;/style&gt; 如上：内部有圆角外层无圆角，但用了两个元素，怎么只用一个元素实现同样的效果呢 可以利用outline不受border-radius影响来做,利用box-shadow填充outline与圆角之间的缝隙； 12345678910111213&lt;div class="something-meaningful"&gt; I have a nice subtle inner rounding, don't I look pretty?&lt;/div&gt;&lt;style&gt; .something-meaningful&#123; background: tan; border-radius: .8em; padding: 1em; box-shadow: 0 0 0 .6em #655; outline: .6em solid #655; &#125;&lt;/style&gt; 条纹背景 横向条纹 如上利用背景属性实现实色条纹，默认repeat所以铺满了 12background: linear-gradient(#fb3 50%, #58a 0);background-size: 100% 30px; 不等宽 12background: linear-gradient(#fb3 30%, #58a 0);background-size: 100% 30px; 多色条纹 123background: linear-gradient(#fb3 33.3%, #58a 0, #58a 66.6%, yellowgreen 0);background-size: 100% 45px; 纵向条纹 与横向一样 只不过增加一个参数指定渐变方向，linear-gradient默认to right，background-size值也置换一下。 123background: linear-gradient(to right, /* 或 90deg */ #fb3 50%, #58a 0);background-size: 30px 100%; 斜向条纹 1234background: linear-gradient(45deg, #fb3 25%, #58a 0, #58a 50%, #fb3 0, #fb3 75%, #58a 0);background-size: 42.426406871px 42.426406871px; 为什么是42.426406871px（勾股定理） 如果宽度为15px那么：2 1× ≈ 5 2 42.426 406 871 像素 同色系条纹 12345background: #58a;background-image: repeating-linear-gradient(30deg, hsla(0,0%,100%,.1), hsla(0,0%,100%,.1) 15px, transparent 0, transparent 30px); 还是推荐使用透明度而不是固定的同色系颜色 随机排列的条纹 上面都是某个固定的宽repeat出来的，所以是很规律的，如何实现不规律的条纹。 123456background: hsl(20, 40%, 90%);background-image: linear-gradient(90deg, #fb3 11px, transparent 0), linear-gradient(90deg, #ab4 23px, transparent 0), linear-gradient(90deg, #655 41px, transparent 0);background-size: 41px 100%, 61px 100%, 83px 100%; 还有很多复杂的背景图,有兴趣可以看看（表示我现在看不动） 连续的图像边框 先跳过 形状 自适应的椭圆 1border-radius: 50%; 正方形会变成圆形，其他矩形则为椭圆 半椭圆 123456789/*纵向上部分的半椭圆*/border-radius: 50% / 100% 100% 0 0;/*以上是缩写 等同于下面 两个值分别代表横轴纵轴的圆角length*/ border-top-left-radius: 50% 100%; border-top-right-radius: 50% 100%; border-bottom-right-radius: 50% 0; border-bottom-left-radius: 50% 0/*横向左侧部分的半椭圆*/border-radius: 100% 0 0 100% / 50%; ↑二分之一椭圆 ↓四分之一椭圆 1border-radius: 100% 0 0 0; 平行四边形 transform: skew() 会影响内部元素也出现变形 解决1：嵌套skew内部与外部变形相反 12345&lt;a href="#yolo" class="button"&gt; &lt;div&gt;Click me&lt;/div&gt;&lt;/a&gt;.button &#123; transform: skewX(-45deg); &#125;.button &gt; div &#123; transform: skewX(45deg); &#125; 解决2： 利用伪元素，只让伪元素变形 12345678910111213.button &#123; position: relative; /* 其他的文字颜色、内边距等样式…… */&#125;.button::before &#123; content: ''; position: absolute; /*撑满宿主元素*/ top: 0; right: 0; bottom: 0; left: 0; z-index: -1; background: #58a; transform: skew(45deg);&#125; transform的其他属性也适用，例如rotate() 菱形图片 一个容器中放入菱形图片 123456789.picture &#123; width: 400px; transform: rotate(45deg); overflow: hidden;&#125;.picture &gt; img &#123; max-width: 100%; transform: rotate(-45deg) scale(1.42);&#125; 结构与布局 自适应 未知宽高的父级元素，子元素左右居中 给父元素加上 12width: min-content;margin: auto; 满幅背景，定宽内容 常见方法，威哥区块准备两层元素：外层实现满幅背景，内层定宽内容，后者margin: auto实现水平居中 123456789101112&lt;footer&gt; &lt;div class="wrapper"&gt; &lt;!-- 页脚的内容写在这里 --&gt; &lt;/div&gt;&lt;/footer&gt;footer &#123; background: #333;&#125;.wrapper &#123; max-width: 900px; margin: 1em auto;&#125; 利用calc()一个标签 12345678&lt;footer&gt; &lt;!-- 页脚的内容写在这里 --&gt;&lt;/footer&gt;footer &#123; padding: 1em; padding: 1em calc(50% - 450px); background: #333; &#125; 垂直居中 行内元素text-align:center; 块级元素对他自身margin: auto; 然而实际应用中是个很头痛的事情 1.定位的方式有固定的宽高 1234567891011121314151617main &#123; position: absolute; top: 50%; left: 50%; margin-top: -3em; /* 6/2 = 3 */ margin-left: -9em; /* 18/2 = 9 */ width: 18em; height: 6em;&#125;/*可以改写为*/main &#123; position: absolute; top: calc(50% - 3em); left: calc(50% -9em); width: 18em; height: 6em;&#125; 未知宽高 123456main &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 2.利用视口单位只适用于视口居中的场景 123456main &#123; width: 18em; padding: 1em 1.5em; margin: 50vh auto 0; transform: translateY(-50%);&#125; 3.最佳解决方案 flexbox1234567body &#123; display: flex; min-height: 10 margin: 0;&#125;main &#123; margin: auto;&#125; 紧贴底部的页脚 1234567891011body &#123; display: flex; flex-flow: column; min-height: 100vh;&#125;main &#123; flex: 1; &#125;footer: &#123; height: 10vh; &#125; ↑ flex方法 ↓ 其他方法 12345678main &#123; min-height: calc(100vh - 7em); /* 避免内边距或边框搞乱高度的计算： */ box-sizing: border-box;&#125;footer&#123; height: 7em;&#125; 过渡与动画 没看完暂时先到这里]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue风格规范梳理]]></title>
    <url>%2F2018%2F07%2F14%2Fvue%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[有助于规避冲突，及团队开发。 vue规范梳理 必须的（避免错误冲突） 组件名为多个单词（避免冲突）； 组件中data必须为一个函数，根实例new Vue时可以使用对象的写法； prop定义尽量详细 123456789101112131415161718// 一般规范写法props: &#123; status: String&#125;// 更好的写法 （一般常用的就是type，default 根据实际需求来）props: &#123; sattus:&#123; type: String, // 类型 required: true, // 是否必传 default: '', // 默认值 //default: function() &#123; return &#123;message: 'hello'&#125; &#125;, // 带默认值的对象或数组 validator: function(value) &#123; return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; // 自定义验证函数 &#125;&#125; v-for必须配合key (key保证唯一就可以了)； 避免v-if和v-for用在同一个元素上； 实际应用如果需要这样做可以将v-if移至父元素上； 或者将v-for的对象替换为计算属性，返回已经过滤掉后的数据（computed）； 为组件样式设置作用域 也就是style标签上加scoped(只作用于当前组件)，或者class策略； mixin和插件等扩展中的私有属性命名，推荐使用$_前缀； 强烈推荐（增强可读性） 组件单独用一个文件分开，方便查找使用； 单文件组件命名单词大写开头或者-分隔（HollyTree or holly-tree）; 基础组件命名以特定的前缀开头 如Base V 等； 单例组件名（每个页面只使用一次不接受prop）用 The前缀； 与父组件紧密耦合的子组件应以父组件名为前缀； 组件名中单词顺序，以高级别单词开头，描述性修饰词结尾； 组件名大小写 (分不清各种模板暂时都这样写也没问题) js中组件名首字母大写驼峰MyComponent; prop名大小写js中使用驼峰,html中-分隔； 12345678props: &#123; hollyTree: &#123; type: String, default: '' &#125;&#125;// 组件上使用时holly-tree 多个特性的元素上，每个特性一行（易读）； 12345&lt;holly-tree :type="a" :flag="true" :status="200"&gt;&lt;/holly-tree&gt; 模板中只包含简单的表达式，复杂的逻辑则应该写在方法或计算属性里； 复杂的计算属性分割为多个简单的属性； 标签上的属性值带“” 或 ‘’； 缩写 用：表示v-bing @表示v-on: ； 推荐 组件/实例的顺序；（所有的都放一个实例里了，实际使用时不可能这样） 123456789101112131415161718192021222324252627282930313233343536373839export default(&#123; el: '', name: '', parent: '', functional: true, delimiters: ['$&#123;', '&#125;'], comments: true, components: &#123;&#125;, directives: &#123;&#125;, filters: &#123;&#125;, extends: &#123;&#125;, mixins: [], inheritAttrs: true, model: &#123;&#125;, props: &#123;&#125;, data()&#123; return &#123; &#125; &#125;, computed: &#123;&#125;, watch: &#123;&#125;, //生命周期 beforeCreate() &#123;&#125;, created()&#123;&#125;, beforeMount()&#123;&#125;, mounted()&#123;&#125;, beforeUpdate()&#123;&#125;, updated()&#123;&#125;, activated()&#123;&#125;, deactivated()&#123;&#125;, beforeDestory()&#123;&#125;, destroyed()&#123;&#125; //非响应式属性 methods: &#123;&#125;, // 渲染 template/render()&#123;&#125;, renderError()&#123;&#125; ) 元素特性顺序； 定义 is 列表渲染 v-for 条件渲染 v-if,v-else-if,v-else,v-show,-v-cloak 渲染方式 v-pre,v-once 全局 id 唯一特性 ref,key,slot 双向绑定 v-model 其他特性 事件 v-on 内容 v-html,v-text 实例中空行（易读）； 顶级元素顺序 template script style 或12互换 保持一致； 谨慎使用 v-if,v-else使用时最好都加key,避免莫名其妙的问题； scoped中避免使用元素选择器，用类选择器； 优先使用prop和事件进行父子组件通信，避免使用this.$parent 优先使用vuex做全局状态管理而不是this.$root或全局事件总栈]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue项目中的某些webpack配置]]></title>
    <url>%2F2018%2F07%2F04%2FVue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%9F%90%E4%BA%9Bwebpack%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[常会用到的一些修改的地方，例如打包忽略console.log,以及为了大小去掉map文件等； webpack配置开发与打包后请求接口 本地开发时和部署项目时我们的请求接口是不一样的，除了定义一个常量手动修改，webpack可以配置吗，可以的！ ​ 1.修改开发环境以及正式环境的配置 config文件夹下有两个文件 dev.env.js ：这里可以配置开发环境的接口 123456module.export = merge(prodEnv, &#123; NODE_ENV: '"development"', // 加上下面这句 HOST_API: '"http://localhost:8080"' // 这里写你自己定义的属性 后面是本地开发时请求的接口&#125;) ​ prod.env.js 12// 也是加上HOST_API: "'http://localhost:8888"' ​ 最后 axios.defaults.baseURL = HOST_API 就可以了 2.通过 process.env.NODE_ENV来写判断123process.env.NODE_ENV === "development" // 开发环境process.env.NODE_ENV === "production" //配置环境// development production 与 config/dev.env.js 和 config/prod.env.js 是对应的 webpack打包去掉console.log以及map文件 去掉conosle.log以及debuger 123456789// 在build/webpack.prod.conf.js里 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false, drop_debugger: true, / drop_console: true &#125;, sourceMap: true &#125;), 去掉打包后的map文件 12345// 在config/index.js文件里build&#123; productionSourceMap: false&#125;// 但其实线上map文件可以定位错误 如果需要定位问题可以设为true ​ webpack中添加引入文件的别名 build/webpack.base.conf.js里 123456789 resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), 'common': resolve('src/common') &#125; &#125;// 这样import from时 common可以代替src/common ,@可以代替src 配置本地开发转发代理 config/index.js中的dev队形中 12345678910111213dev: &#123; proxyTable: &#123; '/api': &#123; target: 'http://www.baidu.com', changeOrigin: true, pathRewrite: &#123; '^/api' &#125; &#125; &#125;&#125;// 当请求的url为api时 会转发到target// 最终实际发出的请求时target 局域网内通过ip访问本地vue-cli搭建的项目 在config/index.js中奖默认的host:localhost修改为‘0.0.0.0’ 在package.json中是script下的dev的值，后面加上 –host 0.0.0.0 这样通过localhost和ip都可以访问到，直接修改为ip的方式localhost是访问不到的]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript对象的属性描述符]]></title>
    <url>%2F2018%2F06%2F01%2Fjavascript%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[经常会看到一些技术文章说，可枚举不可枚举，一直很懵。其实就是对象属性描述符中的Enumerable(可枚举性)。下面来看看有哪些对象属性描述符~ 描述符类型 分为两种 数据属性(data property) 包含一个数据值的位置，在这个位置可以读取和写入值,有四个特性 访问器属性(accessor poperty) 名字、值和一组属性描述符构成的。而属性值可以用一个或两个方法替代，这两个方法就是getter和setter 他们共同的特性 configurable(可配置性) 可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认true; 设置为false后无法使用delete删除属性，严格模式下直接报错；并且不能使用defineProperty()方法来修改属性描述符，但可以用使用defineProperty()方法将writable的状态从true改为false（只有这一种情况可以修改）；var声明变量时默认为false; enumerable(可枚举性) 可枚举性决定属性是否出现在对象的属性枚举中。 用户定义的普通属性默认是可枚举的，而原生继承的属性默认是不可枚举的。 propertyIsEnumerable() 可以判断对象的属性是否可枚举 123456var o = &#123;a:1&#125;;console.log(o.propertyIsEnumerable('a'))//trueObject.defineProperty(o,'a',&#123;enumerable:false&#125;)console.log(o.propertyIsEnumerable('a'))//false ​ 具体来说，比如 fon in 循环是否能遍历到该属性 Object.keys方法是否能取到该属性 JSON.stringify方法是否能取到该属性 不同的特性数据属性 ： value (属性值) 属性值包含这个属性的数据值，读取属性值的时候，从这个位置读，写入属性值的时候，把新值保存在这个位置。默认undefined。 writable (可写性) 可鞋型决定是否可以修改属性的值，默认为true;设置为false后赋值语句会静默失败，严格模式赋值直接报错； 通过Object.defineProperty()方法改变属性value的值不会受影响，因为这也意味着在重置writable的属性值为false 访问器属性： getter 在读取属性时调用的函数。默认undefined setter 在写入属性时调用的函数。默认undefined 1234567891011121314151617181920212223242526// getter 和 setter 取代了数据属性中的value和writable属性// 只设置get方法没有set方法 对象的赋值会静默失败 严格模式下会报错// 只设置set方法而不设置get方法 对象的属性值为undefined// 所以一般都是成对出现的var o =&#123; get a()&#123; return this._a; &#125;, set a(val)&#123; this._a = val*2; &#125;&#125;o.a = 1;console.log(o.a);//2// 可读可取// 利用Object.defineProperty()对o的属性a的getter和setter进行配置Object.defineProperty(o,'a',&#123; get: function()&#123; return this._a; &#125;, set :function(val)&#123; this._a = val*2; &#125;&#125;)o.a = 1;console.log(o.a);//2 ​ 描述符方法 Object.getOwnPropertyDescriptor() 第一个参数是该对象，第二个参数时对象的某一个属性。用于查询一个属性的描述符，并以对象的形式返回 123let obj = &#123;holly: 'nice'&#125;console.log(Object.getOwnPropertyDescriptor(obj, 'holly'))// &#123;value: "nice", writable: true, enumerable: true, configurable: true&#125; ​ Object.defineProperty() 第一个参数时对象，第二个参数是对象的某一个属性，第三个参数是要修改的配置；用于创建或配置对象的一个属性的描述符，返回配置后的对象（创建时，如果不针对描述符配置，则该项描述符默认false） 123456789let holly = &#123;&#125;console.log(Object.defineProperty(holly, 'name', &#123; value: 'holly', writable: true&#125;))// &#123;name: "holly"&#125; 返回该对象console.log(Object.getOwnPropertyDescriptor(holly, 'name'))// &#123;value: "holly", writable: true, enumerable: false, configurable: false&#125;// 由于没有配置 enumerable和configurable 为false Object.defineProperties() 第一个参数是该对象，第二个是要修改的属性为键 特性为值组成的对象；用于创建或配置对象的多个属性的描述符，返回配置后的对象。 12345678910111213let desc = &#123;a: 1, b: 2&#125;console.log(Object.defineProperties(desc, &#123; a: &#123; value: 3, enumerable: false &#125;, b: &#123;writable: true&#125;&#125;))// &#123;b: 2, a: 3&#125;console.log(console.log(Object.getOwnPropertyDescriptor(desc, 'a')))// &#123;value: 3, writable: true, enumerable: false, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(desc, 'b'))// &#123;value: 2, writable: true, enumerable: true, configurable: true&#125; Object.create() 第一个参数指定原型，第二个参数属性和描述符对象；用于指定原型和属性来创建一个对象 1234567let newOne = Object.create(Object.prototype, &#123; a: &#123;value: 'hello', enumerable: true&#125;&#125;)console.log(newOne)// &#123;a: "hello"&#125;console.log(Object.getOwnPropertyDescriptor(newOne,'a'))// &#123;value: "hello", writable: false, enumerable: true, configurable: false&#125; 参考链接: https://www.cnblogs.com/xiaohuochai/p/5743821.html ​ 应用场景 大部分是框架才会用到，比如Vue.js的双向数据绑定]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端前端开发调试工具-vConsole]]></title>
    <url>%2F2018%2F05%2F26%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7-vConsole%2F</url>
    <content type="text"><![CDATA[在写移动网页时，手机上调试可以使用vConsole，类似于谷歌浏览器的f12调试工具。 github地址传送✌ 效果图 console日志 网络请求 页面结构 cookie及本地存储 也可执行输入的js代码 使用方法 装包 1cnpm install vconsole --save-dev main.js中引入并创建实例 12import VConeole from 'vconsole'const vConsole = new VConsole() 由于vConsole只在开发时使用，所以可以根据环境变量进行实例化 12345process.env.NODE_ENV === 'production' ? '' : dev()function dev() &#123; const vConsole = new VConsole() console.log('开发环境启用vconsole')&#125; 遇到的一个小问题当在vue项目中利用vConsole 打印 $refs获取dom就会出现报错 代码如下： 1console.log(this.$refs.app, 555) 报错信息： 最终也打印出来了，不影响功能。 issues 152 提了这个问题 暂时还没有解决]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript的模块化]]></title>
    <url>%2F2018%2F05%2F24%2Fjavascript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[由于现在的网页可以看作是一个功能丰富的应用，需要对代码进行分割、作用域隔离、模块之间的依赖管理以及发布到生产环境时的自动化打包与处理等。 ES6模块（Module）模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 export 与 import12345678910111213141516171819202122232425262728// test.jsexport const testName = 'Cindy'export const testAge = '15'// export 对外输出两个变量---------------------------------// 也可以这样写const testName = 'Cindy'const testAge = '15'export &#123;testName, testAge&#125;// 等价于上面那种写法，不过这样更清晰，底部可以看出对外输出了哪些变量---------------------------------// 也可以输出函数和类（class）export function fn(x, y) &#123; return x + y&#125;// 对外输出一个函数 fn===================================// 与其对应的加载这个模块 import (import是只读的)// testImport.jsimport &#123;testName, testAge，fn&#125; from './test.js'-----------------------------------// 如果加载时想换一个变量名 可以用as关键字import &#123;testName as firstName, testAge as egg&#125; from './test.js'-----------------------------------// 可以使用 * 指定一个对象，整体加载import * as test from './test.js'console.log(test.testName)test.fn(1, 2) export 不能直接 export 具体的数据或变量 ，变量声明语句或者{包裹的数据或变量} export输出的内容import时要对应名字，或者用as改变名字 export default 与 import12345678910// default.jsexport default function () &#123; console.log('foo');&#125;// 默认输出一个匿名函数// import命令可以为该函数指定任意名字import toName from './default'toName() // 'foo'// 即便不是匿名函数 import时也可以指定任意名字 因为export default只能使用一次 输出一个叫做default的变量或方法// export default 后面不能跟变量声明语句 export default 只能使用一次,默认输出一个叫做default的变量或方法，所以import时可以取任意名字 export default 后面不能跟变量声明语句，只能是变量名 其他的模块化方案 CommonJS基于Node.js （require(), module.exports） AMD 由RequireJS提出的，CMD 由 SeaJS提出的,两种用法基本相似（define）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue音乐demo总结]]></title>
    <url>%2F2018%2F05%2F17%2Fvue%E9%9F%B3%E4%B9%90demo%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[很敬佩黄轶老师，涵盖了非常多的知识点。跟着敲还是需要一些vue基础的。 关于Vue开发音乐app的项目总结 我把它部署到了自己的服务器 可以扫码查看 左上角也可以下载我打包好的app ╮(╯▽╰)╭由于我没有备案 直接用的服务器ip 所以微信扫码请点击查看原网页,微信扫码请点击查看原网页, 微信扫码请点击查看原网页。重要的事情说三遍 1.利用vue-cli 初始化项目 请查看本站另一篇文章 ✌点击传送门 2.meta标签的移动端的自适应在index.js的head标签内写name为viewport的meta标签1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0, user-scalable=no"&gt; 了解一下viewport及相关属性设置 属性 值 width 设置layout viewport 的宽度，为一个正整数，或字符串”width-device”设备宽度 initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 height 设置layout viewport 的高度，这个属性并不重要，很少使用 user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许 根据上面这个表格不难看出：width为设备宽度，初始缩放为1，最大及最小缩放都为1，不允许缩放 3.添加依赖 babel-runtime和babel-polyfill实现ES6转ES5babel默认只换新的javascript语法，不转换新的api，所以要安装babel-polyfill，但是会污染全局变量 为了不污染全局变量和内置对象原型，又想使用ES6新语法和api就需要配合使用babel-runtime,可以避免重复代码 12cnpm i babel-runtime --savecnpm i babel-polyfill --save-dev 然后需要在入口文件main.js中 1imprort 'bable-polyfill' 4.引入fastclick解决移动端300ms点击延迟的问题1cnpm i fastclick --save fastclick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。 然后在入口文件引入 12import fastclick from 'fatclick'fastclick.attach(document.body) 5.webpack.base.conf.js中可以配置别名1234567resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; '@': resolve('src'), 'common': resolve('src/common') &#125;&#125; 这样页面import某个在src/common下的对象时可以直接写 import music from &#39;common/music&#39; 6.路由文件的配置1234567891011121314151617181920212223242526272829303132// 在router文件夹内的index.jsimport Vue from 'vue'import Router from 'vue-router'// 以上是脚手架搭建项目已经写好的// 假如现在有三个页面 先导入import Test1 from 'src/components/test1'import Test2 from 'src/components/test2'import Test3 from 'src/components/test3'Vue.use(Router)export default new Router(&#123; routes:[ &#123; path: '/', redirect: '/test1' // 重定向path'/test1' &#125;, &#123; path: '/test1', component: Test1 &#125;, &#123; path: '/test2', component: Test2 &#125;, &#123; path: '/test3', component: Test3 &#125; ]&#125;) 完成了基本的路由配置 App.vue里的router-view就会渲染对应path的component 最好是使用路由按需加载，请查看本站另一篇文章✌ 点击传送 7.router-link的使用12345&lt;router-link tag="div" class="tab-item" to="/test1"&gt; &lt;span class="tab-link"&gt;测试&lt;/span&gt;&lt;/router-link&gt;// tag是渲染的标签 to对应点击以后的path// router会默认有一个class router-link-active 可以覆盖自定义样式 8.子组件引入和使用的规范引入使用首字母大写加驼峰 使用小写 - 连接 12345// 父组件 test2中引入test1improt TestOne from 'components/test1'// template中使用时&lt;test-one&gt;&lt;/test-one&gt;// 尽量语义化 我这里随意写的就没有语义化... 9.jsonp的原理和使用 原理请查看本站另一篇文章✌点击传送 项目中引入了jsonp插件 1cnpm i jsonp --save 因多处会使用到jsonp对它进行一层封装 12345678910111213141516171819202122232425import originJSONP from 'jsonp'export default function jsonp(url, data, option) &#123;// url与处理后的data拼接 url += (url.indexOf('?') &lt; 0 ? '?' : '&amp;') + param(data) // 返回一个promise return new Promise((resolve, reject) =&gt; &#123; originJSONP(url, option, (err, data) =&gt; &#123; // 插件默认返回第一个参数为null第二个参数为数据 所以会接收两个参数 if (!err) &#123; resolve(data) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125;// 对data数据进行处理function param(data) &#123; let url = "" for (var k in data) &#123; let value = data[k] !== undefined ? data[k] : '' url += `&amp;$&#123;k&#125;=$&#123;encodeURIComponent(value)&#125;` &#125; return url ? url.substring(1) : ''&#125; 因为使用promise封装了 所以调用时要用到.then 12import jsonp from 'common/js/jsonp'jsonp(url, data, option).then((res) =&gt; &#123;console.log(res)&#125;) 那么问题来了 ↓ 10.为什么要使用promise对jsonp进行封装试想一种应用场景（回调地狱）A通过jsonp请求获取，B拿到A返回的数据作为参数通过jsonp请求获取，C拿到B返回的数据作为参数通过jsonp请求获取 我们的做法一般都是，执行jsonp({Aparams})并在A回调里拿到B需要的参数并且执行jsonp({Bparams})然后在B的回调里拿到C需要的参数并且执行jsonp({Cparams}) 一两层回调的嵌套其实也觉得还好，但如果业务逻辑复杂需要嵌套100层呢？这样就非常不便于阅读和维护，也就是常听到的“回调地狱” 以上promise封装是怎么做到解决回调地狱的呢？还是上面那个应用场景，我们用以上封装的jsonp怎么使用呢 jsonp({Aparams}).then(jsonp({Bparams})).then({jsonp(Cparams)})即可 当第一个jsonp执行后返回一个promise对象，promise对象状态发生改变就会触发then并且可以拿到A的resolve传递出去的数据,再执行第二个jsonp返回一个promise对象，让promise对象状态发生变化时触发then可以拿到B的resolve传递出去的数据再执行第三个jsonp，依次类推，非常清晰。 当然业务上其实有reject的情况，这时会执行.catch( // 进行错误处理) 那么问题来了，什么是promise状态发生改变时 promise的三种状态 pending(进行中)； fulfilled(已成功)； rejected(已失败)。 状态改变 当执行resolve时,promise对象的状态会从pending 变为 fulfilled； 当执行reject时,promise对象的状态会从pending 变为 rejected; 当然ajax也可以结合promise封装，axios已经结合了promise可以直接使用 11.better-scroll的使用 由于项目很多地方都需要滑动，所以我们对better-scroll进行封装 详见本站另一篇文章✌ 点击传送 12.图片懒加载: Vue-Lazyload 非常好用的一个优化插件 官方文档✌ 点击传送 使用步骤1.npm 安装 1cnpm install vue-lazyload --save 2.main.js中use 1234567import VueLazyLoad from 'vue-lazyload'Vue.use(VueLazyLoad, &#123; // loading图片 loading: require('本地图片路径')&#125;)// 页面中使用 只需要用v-lazy指令替换src就可以了// scr="imgUrl" =&gt; v-lazy="imgUrl" 更多属性请看官方文档，超超超好用 13.vuex的使用vuex帮助我们管理共享状态,多个没有什么关联性的组件想要共享状态可以通过vuex 详见本站另一篇文章 ✌ vuex的学习及使用 14.ES6 class类的基本使用 ES5中生成实例对象的方法–构造函数 12345678function Holly(x, y) &#123; this.x = x this.y = y&#125;Holly.protitype.connect = function() &#123; return (this.x + ',' + this.y )&#125;var hollyTree = new Holly('www.hollytree', '.top') ES6 中引入class这个概念,针对上面改写 123456789101112// 定义一个Holly的类class Holly &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; // 方法直接定义 不需要function关键字 也不需要逗号 connect() &#123; return (this.x + ',' + this.y ) &#125;&#125;var hollyTree = new Holly('www.hollytree', '.top') Holly类里有一个cunstructor方法，这就是构造方法this指向实例。 也就是说ES5中的构造函数Holly对应ES6中Holly类的构造方法 ES6的类可以看做构造函数的另一种写法，typeof 类 返回 ‘function’,数据类型为函数，类本身指向构造函数； 类所有的方法都定义在类的prototype（原型）上； 原型对象的constructor属性直接指向类本身与ES5一致 由于项目中多处用到歌曲的数据，并且数据需求的格式基本一样，所以这里选择用类来创建song实例12345678910111213141516171819202122// song.js// 定义一个Song类，类的构造函数接收一些参数并指向实例export default class Song &#123; constructor(&#123; id, mid, singer, name, album, duration, image, url &#125;) &#123; this.id = id this.mid = mid this.singer = singer this.name = name this.album = album this.duration = duration this.image = image this.url = url &#125; // 类的方法 实例可以直接调用 getLyric() &#123; if (this.lyric) &#123; return Promise.resolve(this.lyric) &#125; &#125;&#125;let songData = new Song(&#123;id: 22, mid:666, singer: 'holly'...&#125;)console.log(songData) // &#123;id: 22, mid: 666, singer: 'holly'...&#125; 15.HTML5 audio音频播放 简单应用 1&lt;audio ref="audio" :src="currentSong.url" @canplay="ready" @error="error" @timeupdate="updateTime"&gt; &lt;/audio&gt; play()方法 开始播放 canplay事件：当浏览器可以开始播放音频/视频时触发。 paly事件： 当音乐开始播放时触发（播放暂停有时因为业务逻辑可能需要将canplay换成play事件，控制切换以及ready触发时保证已经play()） error事件：当在音频/视频加载期间发生错误时触发。 timeupdate事件：在音频/视频（audio/video）的播放位置发生改变时触发。 以下代码实现功能： 当歌曲发生改变的时候播放也就是调用play() 在播放器切换歌曲时可以控制，当前歌曲已经ready时才能切换到下一首 实时获取播放时间 123456789101112131415161718192021222324252627282930313233343536data() &#123; return &#123; // 标识 songReady: false &#125;&#125;，methods: &#123;// 只有该歌曲已经ready时，赋值为true ready() &#123; this.songReady = true &#125;,// 然后在切换的方法里 例如next() 加一个判断就可以了 next() &#123; if(!this.songReady) &#123; return &#125; // 就不执行下面的了 ... // 最后在重置为false this.songReady = false &#125;， // 当资源加载失败时不影响切换操作 error() &#123; this.songReady = true &#125;&#125;，watch: &#123; // 当前歌曲变化时并且已经ready 开始播放 currentSong() &#123; if(!this.songReady) &#123; return &#125; this.$refs.audio.play() this.songReady = true &#125;&#125; 16. Vue的混入 Mixins 的使用 混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。 详见本站另一篇文章✌ 点击传送 Mixins的使用 17.带实时提示的搜索组件的节流 vue中一般是v-model绑定input值然后监听，一旦发生改变就发送请求； 例如我想搜索周杰伦，输入周时请求一次，杰时请求一次，伦时请求一次；或者删除伦时请求一次…. 频繁的发送请求，页面有可能造成卡顿，也增大了服务器的压力； 这个时候需要进行节流优化。 案例 传送门 18.Vue中常用的一些是事件修饰符项目中用到了.stop .prevent .stop 阻止事件冒泡 .prevent 取消浏览器默认行为（例如a标签的默认刷新页面） .capture 使用事件捕获模式 .self 只作用于元素本身，类似于已阻止事件冒泡 .once 只作用一次 修饰符可以串联 例如需要阻止冒泡并且只触发一次 .stop.once 19.打包1npm run build 打包以后的文件如下： 包含static静态资源文件夹 与 html 文件 由于是单页应用程序，进入首页时会加载所有的静态文件。项目比较大时会白屏很久。 这时推荐路由懒加载的模式进行优化，这样打包后会分模块，进入不同路由后加载对应静态资源 详见： 路由懒加载✌ 20.手机上调试推荐使用vConsole 一个由微信团队开发开源的插件 使用方法 点击传送✌]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的节流控制案例]]></title>
    <url>%2F2018%2F05%2F10%2Fjavascript%E4%B8%AD%E7%9A%84%E8%8A%82%E6%B5%81%E6%8E%A7%E5%88%B6%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[节流控制频繁触发事件或频繁发送请求，避免页面卡顿，请求卡顿，简单来说就是在多次触发时有一个间隔时间，第n次触发事件和第n+1次触发事件之间必须保证间隔时间。 一个带提示的搜索案例（用vue写的）场景(如下图) 需要达到的效果 搜索输入内容时利用节流函数控制在一个指定的周期内才发送请求 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344// 搜索框&lt;template&gt; &lt;div&gt; &lt;input class="box" ref="querySearch" v-model="query" :placeholder="请输入"&gt; &lt;div&gt;提示层 请求返回的数据渲染的 这里我就不具体谢了&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; query: '' &#125; &#125;, watch: &#123; query(newVal) &#123; // 发送请求 //this.search(newVal) // 改为利用节流函数控制 this.throttle(this.search(newVal), 200) // 执行逻辑 当query改变时200ms后发送请求，当200ms内多次触发节流函数，会取消上一次200ms后执行func()的函数，继续新的一次200ms后执行 // 也就是每一次query发生改变都要等到200ms以后发送请求 &#125; &#125;， methods: &#123; //节流函数 第一个参数是要执行的函数 第二个是要延迟的时间 throttle(func, delay) &#123; let timer return function(...args)&#123; // 被执行了 取消执行 // 在delay时间内反复执行return的匿名函数会清除上一次继续延迟delay时间后执行func 达到节流的效果 if(timer) &#123; clearTimeout(timer) &#125; timer = setTimerout(() =&gt; &#123; func.apply(this, args) &#125;, delay) &#125; &#125; &#125; &#125;&lt;/script&gt; 减少请求 一定程度上优化了性能 节约流量 常见的应用场景 Dom元素的拖拽 射击游戏 （单位时间内只发射一颗子弹） 鼠标移动距离 搜索联想（也就是这个案例） 监听滚动事件]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>节流</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中混入的使用（Mixin）]]></title>
    <url>%2F2018%2F04%2F25%2FVue%E4%B8%AD%E6%B7%B7%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88Mixins%EF%BC%89%2F</url>
    <content type="text"><![CDATA[当出现类似组件，功能又有重叠的地方，但又具有比较大的差异时可以使用Mixin，只提取公共的部分。然后混入到多个组件中。（写法与组件非常类似，很容易上手） Mixin的基本用法现在的场景是 多个页面底部有A组件，多个页面内容都可滑动，滑动到最底部时一部分内容被A组件遮挡，（滑动用的scorll组件）这时需要在页面有数据时给scroll一个bottom等于A组件的高度再重新计算scroll scroll组件是利用better-scroll封装的一个组件 详见另一篇 点击传送 多个组件需要写相同逻辑,推荐使用Mixin12345678910111213141516171819202122232425// mixin.jsimport &#123;mapGetters&#125; from 'vuex'export const playlistMixin = &#123; computed: &#123; ...mapGetters(['playlist']) &#125;, mouted() &#123; this.handlePlaylist(this.playlist) &#125;, activated() &#123; this.handlePlaylist(this.playlist) &#125;, watch: &#123; playlist(newVal) &#123; this.handlePlaylist(this.playlist) &#125; &#125;, methods: &#123; // handlePlaylist需要被具体组件实现 当混入的组件中有这个方法时会覆盖mixin中的同名方法 handlePlaylist() &#123; // 没有时 我们手动抛一个error throw new Error ('error') &#125; &#125;&#125; 混入到组件中1234567891011121314151617181920212223// music-list.vue// 引入import &#123;playlistMixin&#125; from './mixin'// mixins属性混入export default &#123; // 可以混入多个 逗号隔开 mixins: [playlistMixin], data() &#123; return &#123; &#125; &#125;， methods: &#123; handlePlaylist(list) &#123; const bottom = list.length &gt; 0 ? '60px' : '' // scroll组件的dom this.$refs.list.$el.style.bottom = bottom // 重新计算高度，最大滑动高度也会被重新计算 达到内容不被A组件遮挡的效果 this.$refs.list.refresh() &#125; &#125;&#125;// 混入到其他页面写法也一样 只是handlePlaylist的方法体根据每个页面不同来写 已经在多个组件写了相同逻辑或功能 也可以提取出来再混入 减少代码量 也方便维护]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>mixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[better-scoll的封装与使用]]></title>
    <url>%2F2018%2F04%2F19%2Fbetter-scoll%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[better-scroll是解决各种滚动场景需求的插件，由于一般移动端项目滚动的场景特别多，所以会对其进行封装复用 Vue中的better-scroll学习及使用better-scroll 中文文档 ✌ 点击传送 首先大概了解一下该插件的滚动原理 父容器有一个固定高度 第一个子元素，高度会随内容进行变化 当内容高度不超过父容器不滚动,超过父容器就可以滚动 重点：better-scroll对外暴露了一个BScroll的类，我们初始化只需要neiw一个实例，第一个参数为父容器的DOM,第二个参数是一些配置。 初始化时会子酸父元素和子元素的高度和宽度，才能决定是否可以滚动，所以初始化时必须确保父元素与子元素已经渲染。否则会出现不可滚动的情况 当子元素或者父元素DOM结果发生变化（通常也就是数据发生变化）需要冲洗调用refresh()方法重新计算高度 写一个基础的scroll组件dom结构很简单 1234567&lt;template&gt; // 父容器 &lt;div ref="wrapper"&gt; // 插槽 &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;script&gt; // 先引入better-scroll improt Bscroll 'better-scroll' export default &#123; // 可接收的值 props: &#123; // 组件的一个属性可以看文档：为0时不派发scroll事件，1时滑动超过一定事件派发scroll事件，2时滑动过程中时时派发scroll事件，3时不仅滑动时时时派发，另一个属性momentum为true开启动画，动画也派发scroll事件 probeType: &#123; type: Number, default: 1 &#125;， click: &#123; type: Boolean, default: true &#125;， // 数据影响滑动，所以需要接收对应数据 data: &#123; type: Array, default: null &#125;， // 监听滚动 listenScroll: &#123; type: Boolean, default: false &#125; mounted() &#123; // 初始化时机 在dom已渲染 setTimeout(() =&gt; &#123; this._initScroll() &#125;, 20) &#125;, methods: &#123; // 初始化方法 _initScroll() &#123; // 防错 避免undefined if(!this.$refs.wrapper) &#123; return &#125; // 第一个参数为父容器dom 第二个参数为一些配置参数 this.scroll = new BScroll(this.$refs.wrapper, &#123; probeType: this.probeType， // 派发scroll的模式 click: this.click &#125;) // 如果有监听listenScroll // 记录Vue实例的this let me = this if(this.listenScroll) &#123; // 监听scroll事件并且派发scroll时间把pos位置传出去 // 触发时机：滚动过程中，具体时机取决于选项中的 probeType // 具体可以查阅官方文档 this.scroll.on('scroll', pos =&gt; &#123; // 这个回调里的this执行better-scroll 所以要记录Vue实例的this // pos是位置 me.$emit('scroll', pos) &#125;) &#125; &#125;, // 以下都是better-scroll的API // 启用 enable() &#123; this.scroll &amp;&amp; this.scroll.enable() &#125;, // 禁用 disable() &#123; this.scroll &amp;&amp; this.scroll.disable() &#125; // 刷新scroll 重新计算 refresh() &#123; this.scroll &amp;&amp; this.scroll.refresh() &#125;， // 滚动到指定位置 参数为x坐标(px)，y坐标(px)，滚动动画时长(ms),缓动函数，默认easing scrollTo() &#123; // apply是为了保证指向Vue实例 // scrollTo的this指向better-scroll this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments) &#125;, // 滚动到目标元素 参数：el滚动到的目标元素，滚动动画时长(ms),offsetX相对目标元素横向偏移量(px)如果直接设为true则中心，offsetY同理，缓动动画 默认easing scrollToElement() &#123; this.scroll &amp;&amp; this.scroll.scrollToElment.apply(this.scroll, arguments) &#125; &#125;， watch: &#123; // 当数据发生变化时重新计算scoll data() &#123; setTimeout(() =&gt; &#123; this.refresh() &#125;, 20) &#125; &#125; &#125; &#125;&lt;/script&gt; 使用上面封装的组件引入scroll组件 并在页面注册 然后在template中使用 test1 12345678910&lt;template&gt; &lt;scroll ref="listWrapper" :data="list"&gt; &lt;div class="content"&gt; &lt;div class="list1" v-for="item1 in list1"&gt; &lt;span&gt;item1&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroll&gt;&lt;/template&gt; 将获取到的list数据传入scroll组件，scroll组件watch到data变化会重新计算高度，这是如果内容超过父容器就可以正常滑动了 test2 123456789101112&lt;template&gt; &lt;scroll ref="listWrapper" :data="list"&gt; &lt;div class="content"&gt; &lt;div class="list1" v-for="item1 in list1"&gt; &lt;span&gt;item1&lt;/span&gt; &lt;/div&gt; &lt;div class="list2" v-for="item2 in list2"&gt; &lt;span&gt;item2&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroll&gt;&lt;/template&gt; 当一个滑动出现两个或两个以上由内容撑开高度异步获取的情况，要确保都获取到数据以后再传data，或者手动调用refresh方法 this.$refs.listWrapper.refresh()重新计算 test3 实现点击右侧字母左侧滑动到对应位置以及滑动右侧左侧滑动到对应位置效果图 首先引入上面封装的scroll组件 并在页面注册 然后在template中使用 左侧数据与右侧数据的索引是对应好的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&lt;template&gt; &lt;scroll @scroll="scroll" :listen-scroll="listenScroll" :probe-type="probeType" :data="data" class="listview" ref="listview"&gt; &lt;--左侧列表--&gt; &lt;ul&gt; &lt;li v-for="group in data" class="list-group" ref="listGroup"&gt; &lt;h2 class="list-group-title"&gt;&#123;&#123;group.title&#125;&#125;&lt;/h2&gt; &lt;uL&gt; &lt;li @click="selectItem(item)" v-for="item in group.items" class="list-group-item"&gt; &lt;img class="avatar" v-lazy="item.avatar"&gt; &lt;span class="name"&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/uL&gt; &lt;/li&gt; &lt;/ul&gt; &lt;--右侧字母--&gt; &lt;div class="list-shortcut" @touchstart.stop.prevent="onShortcutTouchStart" @touchmove.stop.prevent="onShortcutTouchMove" @touchend.stop&gt; &lt;ul&gt; &lt;--左侧滚动右侧实时高亮--&gt; &lt;li v-for="(item, index) in shortcutList" :data-index="index" class="item" :class="&#123;'current':currentIndex===index&#125;"&gt;&#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="list-fixed" ref="fixed" v-show="fixedTitle"&gt; &lt;div class="fixed-title"&gt;&#123;&#123;fixedTitle&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/scroll&gt;&lt;/template&gt; &lt;script type="text/ecmascript-6"&gt; import Scroll from 'src/base/scroll/scroll' // 左侧title高度 根据样式来的 const是为了以后有变化好统一处理 const TITLE_HEIGHT = 30 // 右侧每个li的高度 const ANCHOR_HEIGHT = 18 export default &#123; props: &#123; data: &#123; type: Array, default: [] &#125; &#125;, computed: &#123; shortcutList() &#123; return this.data.map((group) =&gt; &#123; return group.title.substr(0, 1) &#125;) &#125;, fixedTitle() &#123; if (this.scrollY &gt; 0) &#123; return '' &#125; return this.data[this.currentIndex] ? this.data[this.currentIndex].title : '' &#125; &#125;, data() &#123; return &#123; scrollY: -1, currentIndex: 0, diff: -1 &#125; &#125;, created() &#123; this.probeType = 3 this.listenScroll = true this.touch = &#123;&#125; this.listHeight = [] &#125;, methods: &#123; // 设置或获取自定义属性的方法 getData(el, name, val) &#123; const prefix = 'data-' if(val) &#123; //有第三个参数时set return el.setAttribute(prefix + name, val) &#125; else &#123; // 没有第三个参数时get return el.getAttribute(prefix + name) &#125; &#125;, selectItem(item) &#123; this.$emit('select', item) &#125;, // 点击右侧字母时 onShortcutTouchStart(e) &#123; // dom中已经设置了自定义属性 :data-index="index" 直接获取得到索引 let anchorIndex = this.getData(e.target, 'index') // 调用组件滚动到元素的方法 滚动到左侧列表对应的index Dom元素 // 由于比较长 多处会用到可以进行封装 见_scrollTo //this.$refs.listview.scrollToElement(this.$refs.listGroup[anchorIndex]) // 记录第一个touches手指的位置 let firstTouch = e.touches[0] // 记录start的Y值 this.touch.y1 = firstTouch.pageY // 记录index this.touch.anchorIndex = anchorIndex // 左侧列表滑动到指定元素位置 this._scrollTo(anchorIndex) &#125;, // 滑动过程中 列表跟随滚动 需要记录start的Y值计算差 onShortcutTouchMove(e) &#123; // 记录滑动第一个手指位置的Y值 let firstTouch = e.touches[0] this.touch.y2 = firstTouch.pageY // 获得start和move的Y值差 / 右侧每个li的高度（ANCHOR_HEIGHT）| 0 也就是向下取整 // 也就是获得了偏移了几个元素 let delta = (this.touch.y2 - this.touch.y1) / ANCHOR_HEIGHT | 0 // 新的元素位置就是start记录的索引+delta let anchorIndex = parseInt(this.touch.anchorIndex) + delta // 滑动到指定元素位置 this._scrollTo(anchorIndex) &#125;, refresh() &#123; this.$refs.listview.refresh() &#125;, // 记录实时滚动的Y值 scroll(pos) &#123; this.scrollY = pos.y &#125;, // 计算每个左侧列表的高度 _calculateHeight() &#123; this.listHeight = [] const list = this.$refs.listGroup let height = 0 this.listHeight.push(height) for (let i = 0; i &lt; list.length; i++) &#123; let item = list[i] height += item.clientHeight this.listHeight.push(height) &#125; &#125;, _scrollTo(index) &#123; if (!index &amp;&amp; index !== 0) &#123; return &#125; // 点击右侧时 scrollY赋值实现高亮 因为点击时左侧没有派发scroll事件没有更新scrollY // 需要根据逻辑手动给scrollY赋值 if (index &lt; 0) &#123; // 顶部 index = 0 &#125; else if (index &gt; this.listHeight.length - 2) &#123; // 底部 index = this.listHeight.length - 2 &#125; this.scrollY = -this.listHeight[index] // 左侧滚动到指定位置 this.$refs.listview.scrollToElement(this.$refs.listGroup[index], 0) &#125; &#125;, watch: &#123; data() &#123; // data发生改变时 重新计算左侧每个列表高度 setTimeout(() =&gt; &#123; this._calculateHeight() &#125;, 20) &#125;, // 滑动位置发生变化时 scrollY(newY) &#123; // 三种情况 顶部 中间 底部 const listHeight = this.listHeight // 当滚动到顶部，newY&gt;0 if (newY &gt; 0) &#123; this.currentIndex = 0 return &#125; // 在中间部分滚动 for (let i = 0; i &lt; listHeight.length - 1; i++) &#123; let height1 = listHeight[i] let height2 = listHeight[i + 1] // 两个元素之间 if (-newY &gt;= height1 &amp;&amp; -newY &lt; height2) &#123; this.currentIndex = i this.diff = height2 + newY return &#125; &#125; // 当滚动到底部，且-newY大于最后一个元素的上限 // 2的原因是 listHeight在创建时比元素多一个 并且底部以元素的上线位置为准 this.currentIndex = listHeight.length - 2 &#125;, diff(newVal) &#123; let fixedTop = (newVal &gt; 0 &amp;&amp; newVal &lt; TITLE_HEIGHT) ? newVal - TITLE_HEIGHT : 0 if (this.fixedTop === fixedTop) &#123; return &#125; // 当偏移量小于title的高度时才transfrom 其它情况不变依然fix在列表顶部 this.fixedTop = fixedTop this.$refs.fixed.style.transform = `translate3d(0,$&#123;fixedTop&#125;px,0)` &#125; &#125;, components: &#123; Scroll &#125;&lt;/script&gt; 达到左右互相联动的效果 右侧点击左侧滑动到对应元素，右侧滑动，根据偏移比例左侧滑动到对应位置 左侧滑动到某个区间，右侧高亮 顶部固定title，在滑动偏移差小于title高度时,fixed有个过渡效果。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>组件</tag>
        <tag>封装</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex的学习及使用]]></title>
    <url>%2F2018%2F03%2F24%2FVuex%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[解决多个组件的状态共享,解决路由间传递复杂数据,便于维护。 目录结构通常情况下 我们在src下建立一个store文件夹 具体如下图 state.js里是要用到的状态； getters.js是用来映射state里的状态； mutations.js是改变state里状态的一些方法，只能同步操作； mutations-types.js是统一管理mutaions方法名的一个文件（多人协作时方便管理，也可以不用）； actions.js 不直接改变state里的状态，通过commit mutations里的方法进行改变state,并且可以分发多个mutaitons并且可以进行异步操作； index.js 入口文件 例子：例子中用了export,export default 两种不同的导出语法 如果不清楚可以查阅另一篇文章 ✌ 点击进入 javascript的模块化 state.js 1234567891011121314const state = &#123; singer: &#123;&#125;, playing: false, fullScreen: false, playList: [], sequenceList: [], currentIndex: -1, //歌单详细列表 disc: &#123;&#125;, // 排行列表 topList: &#123;&#125;,&#125;export default state getters.js (进行映射state) 123456789101112131415export const singer = state =&gt; state.singerexport const playing = state =&gt; state.playingexport const fullScreen = state =&gt; state.fullScreenexport const playList = state =&gt; state.playListexport const sequenceList = state =&gt; state.sequenceListexport const currentIndex = state =&gt; state.currentIndexexport const disc = state =&gt; state.discexport const topList = state =&gt; state.topList mutations-types.js (统一管理mutations方法名称常量) 123456789101112131415export const SET_SINGER = 'SET_SINGER'export const SET_PLAYING_STATE = 'SET_PLAYING_STATE'export const SET_FULL_SCREEN = 'SET_FULL_SCREEN'export const SET_PLAYLIST = 'SET_PLAYLIST'export const SET_SEQUENCE_LIST = 'SET_SEQUENCE_LIST'export const SET_CURRENT_INDEX = 'SET_CURRENT_INDEX'export const SET_DISC = 'SET_DISC'export const SET_TOP_LIST = 'SET_TOP_LIST' mutations.js (改变state的一些方法) 123456789101112131415161718192021222324252627282930import * as types from './mutations-types' const mutations = &#123; [types.SET_SINGER] (state, singer) &#123; state.singer = singer &#125;, [types.SET_PLAYING_STATE](state, flag) &#123; state.playing = flag &#125;, [types.SET_FULL_SCREEN](state, flag) &#123; state.fullScreen = flag &#125;, [types.SET_PLAYLIST](state, list) &#123; state.playList = list &#125;, [types.SET_SEQUENCE_LIST](state, list) &#123; state.sequenceList = list &#125;, [types.SET_CURRENT_INDEX](state, index) &#123; state.currentIndex = index &#125;, [types.SET_DISC](state, disc) &#123; state.disc = disc &#125;, [types.SET_TOP_LIST](state, topList) &#123; state.topList = topList &#125;&#125;export default mutations actions.js(派发多个mutations或进行异步操作) 在 store 上注册 action。处理函数总是接受 context 作为第一个参数，payload 作为第二个参数（可选）。 context包含以下属性，第二个参数可选（调用时传入的参数） 12345678&#123; state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters // 等同于 `store.getters`，只存在于模块中&#125; 下面用了结构赋值 第一个参数只接收commit,有些场景也需要接收state {commit, state} 12345678import * as types from './mutations-types' // 清空播放列表 export const deleteSongLits = function(&#123;commit&#125;, val) &#123; commit(types.SET_PLAYLIST, []) commit(types.SET_SEQUENCE_LIST, []) commit(types.SET_CURRENT_INDEX, -1) commit(types.SET_PLAYING_STATE, false) &#125; index.js (vuex入口文件) 12345678910111213141516171819202122import Vue from 'vue'import Vuex from 'vuex'import * as actions from './actions'import * as getters from './getters'import state from './state'import mutations from './mutations'// 内置的logger插件 日志插件可以在控制台查看vuex的信息进行调试import createLogger from 'vuex/dist/logger'Vue.use(Vuex)// run dev时 debug为trueconst debug = process.env.NODE_EN !== 'production'export default new Vuex.Store(&#123; actions, getters, state, mutations, // strict 严格模式 true为开启 // 任何 mutation 处理函数以外修改 Vuex state 都会抛出错误 strict: debug, plugins: debug ? [createLogger()] : []&#125;) 在项目的入口文件main.js中将该 Store 实例添加到构造的 Vue 实例中main.js 12345678910111213141516171819202122import Vue from 'vue'import App from './App'import router from './router'import fastclick from 'fastclick'import 'babel-polyfill'import 'common/stylus/index.styl'import VueLazyLoad from 'vue-lazyload'import store from './store' // 引入storeVue.config.productionTip = falsefastclick.attach(document.body)Vue.use(VueLazyLoad, &#123; loading: require('common/image/logo@2x.png')&#125;)/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store,// 添加到Vue实例中 render: h =&gt; h(App)&#125;) 利用辅助函数在组件中获取state,映射getter,提交mutation,分发action1234567891011121314151617181920212223242526272829303132import &#123; mapState, mapMutations, mapActions &#125; from 'vuex'export default &#123; computed: &#123; ...mapState([ // 映射 this.singer 为 store.state.singer 'singer' ]), // 把 `this.playing` 映射为 `this.$store.getters.playing` ...mapGetters(['playing']) &#125;, methods: &#123; ...mapMutations([ 'SET_SINGER', // 将 `this.SET_SINGER()` 映射为 `this.$store.commit('SET_SINGER')` // `mapMutations` 也支持载荷： 'SET_SINGER' // 将 `this.SET_SINGER(amount)` 映射为 `this.$store.commit('SET_SINGER', amount)` ]), ...mapMutations(&#123; setSinger: 'SET_SINGER' // 将 `this.setSinger()` 映射为 `this.$store.commit('SET_SINGER')` &#125;) ...mapActions([ 'deleteSongLits', // 将 `this.deleteSongLits()` 映射为 `this.$store.dispatch('deleteSongLits')` // `mapActions` 也支持载荷： // 'deleteSongLits' // 将 `this.deleteSongLits(amount)` 映射为 `this.$store.dispatch('deleteSongLits', amount)` ]), ...mapActions(&#123; empty: 'deleteSongLits' // 将 `this.empty()` 映射为 `this.$store.dispatch('deleteSongLits')` &#125;) &#125;&#125; vuex的分割模块以vue-element-admin的store为例 ✌ 点击传送 目录结构: index.js 入口文件 getter.js state的映射 modules模块文件夹，里面为一个个vuex模块 以errorLog模块为例 123456789101112131415161718const errorLog = &#123; state: &#123; logs: [] &#125;, mutations: &#123; ADD_ERROR_LOG: (state, log) =&gt; &#123; state.logs.push(log) &#125; &#125;, actions: &#123; addErrorLog(&#123; commit &#125;, log) &#123; commit('ADD_ERROR_LOG', log) &#125; &#125;&#125;export default errorLog// 导出一个对象 有sate, mutations, actions的对象 getter.js state的映射 1234const getters = &#123; errorLogs: state =&gt; state.errorLog.logs&#125;export default getters index.js vuex入口文件 123456789101112131415161718192021222324import Vue from 'vue'import Vuex from 'vuex'import app from './modules/app'import errorLog from './modules/errorLog'import permission from './modules/permission'import tagsView from './modules/tagsView'import user from './modules/user'import getters from './getters'// 加载每一个模块Vue.use(Vuex)const store = new Vuex.Store(&#123; // 注入modules对象中 modules: &#123; app, errorLog, permission, tagsView, user &#125;, getters&#125;)export default store main.js 项目入口文件 12345678910import store from './store' // 加载storenew Vue(&#123; el: '#app', router, store, // 挂在到Vue实例 i18n, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 模块写法只是将state,mutations,actions写到了不同的功能模块中，并且分别加载并挂在到Vuex实例中，多人写作或者功能模块较多的项目推荐这种写法 Vuex数据持久化，结合localStoragevuex刷新后就会消失, 很多应用场景刷新要保留数据 结合本地存储只要不手动清除，就一直存在 思路 最好是写一个js文件,根据业务场景写localStorage的set和get和移除或清空 state里的数据直接获取localStorage存储的数据 mutaions或actions方法里调用js文件中是set get 移除 清空等方法 demo写set get方法的文件 cache.js 1234567891011121314151617181920212223242526272829303132333435import storage from 'good-storage'const SEARCH_KEY = '__search__'const SEARCH_MAX_LENGTH = 15// 保存搜索历史export function saveSearch(query) &#123; // 本地存储数组 let searches = storage.get(SEARCH_KEY, []) // 进行比较后插入 insertArray(searches, query, (item) =&gt; &#123; return item === query &#125;, SEARCH_MAX_LENGTH) // 保存 storage.set(SEARCH_KEY, searches) return searches&#125;export function loadSearch() &#123; return storage.get(SEARCH_KEY, [])&#125;// 删除一个export function deleteSearch(query) &#123; let searches = storage.get(SEARCH_KEY, []) deleteFromArray(searches, (item) =&gt; &#123; return item === query &#125;) storage.set(SEARCH_KEY, searches) return searches&#125;export function clearSearch() &#123; storage.remove(SEARCH_KEY) return []&#125; state.js (获取存储) 12345678import &#123;loadSearch&#125; from 'common/js/cache'const state = &#123; // 搜索历史 searchHistory: loadSearch(),&#125;export default state mutations.js 12345678910import * as types from './mutations-types' const mutations = &#123; [types.SET_SEARCH_HISTORY](state, history) &#123; state.searchHistory = history &#125;&#125;export default mutations actions.js (更新存储) 123456789101112131415import * as types from './mutations-types'import &#123;saveSearch, deleteSearch, clearSearch,&#125; from 'common/js/cache' // 搜索历史相关 export const saveSearchHistory = function(&#123;commit&#125;, query) &#123; commit(types.SET_SEARCH_HISTORY, saveSearch(query)) &#125; export const deleteSearchHistory = function(&#123;commit&#125;, query) &#123; commit(types.SET_SEARCH_HISTORY, deleteSearch(query)) &#125; export const clearSearchHistory = function(&#123;commit&#125;) &#123; commit(types.SET_SEARCH_HISTORY, clearSearch()) &#125; 当派发actions时会做对应的存储操作，state会拿到本地存储的数据]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp的原理和使用]]></title>
    <url>%2F2018%2F03%2F15%2Fjsonp%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[浏览器的同源策略不允许跨域，jsonp是解决跨域的一种方法。但也存在一些缺点，所以跨域最好还是后台进行设置. 原理 利用script标签的src属性不受同源策略影响（协议，端口，域名任何一个不同，同源策略都会禁止跨域） 通过前端方法作为参数传递到服务器，服务器注入参数后再返还，实现服务器向客户通信 只支持get方法 请求过程 请求前：创建一个script标签，并给src赋值 url+callback的方法名，并在window上注册这个方法 发送请求： 将script添加到页面中，浏览器会发起一个请求 数据响应：服务器将返回的数据作为参数和函数名拼接在一起 jsonpCbk({data:”data”})。当浏览器接收到响应数据，由于发起请求的是script，所以相当于直接调用jsonpCbk方法，并且给回调传入了一个参数。 原生js写一个jsonp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// url要请求的地址以及拼接的参数；opts&#123;param: 约定的函数参数，timeout:超时时间，name:指定的函数名，prefix:指定的函数名前缀&#125;；fn回调函数var count = 0function noop()&#123;&#125;function jsonp(url, opts, fn) &#123; // opts 如果是一个函数 赋值给fn 并重置opts为空对象 if('function' == typeof opts)&#123; fn = opts opts = &#123;&#125; &#125; // 如果没有opts 给opts赋值空对象 if(!opts) opts = &#123;&#125; var prefix = opts.prefix || '__jp' // id为opts的name或者prefix+计数（prefix为opts.prefix或__jp） var id = opts.name || (prefix + (count++)) var param = opts.param || 'callback' // 有opts.timeout 就取 没有就是60000ms var timeout = null != opts.timeout ? opts.timeout : 60000 var enc = encodeURIComponent // 第一个script或者head标签 var target = document.getElementsByTagName('script')[0] || document.head var script var timer // 如果有timeout就在timeout之后执行clean并抛出Error if (timeout) &#123; timer = setTimeout(function()&#123; cleanup() if(fn) fn(new Error('Timeout')) &#125;, timeout) &#125; function cleanup() &#123; // 移除创建的script 回调函数置空 清除定时器 if(script.parentNode) script.parentNode.removeChild(script) window[id] = noop if(timer) clearTimeout(timer) &#125; function cancel() &#123; if(window[id]) &#123; cleanup() &#125; &#125; // 全局挂载id window[id] = function(data) &#123; cleanup() // 请求返回后执行回调fn if(fn) fn(data) &#125; url += (~url.indexOf('?') ? '&amp;' : '?') + param + '=' + enc(id); url = url.replace('?&amp;', '?'); // 创建script标签src属性赋值url script = document.createElement('script') script.src = url; // 插入到head或script的前面 target.parentNode.insertBefore(script, target); return cancel; &#125; 以上是参照一个jsonp插件的源码写的 传送门 此方法在调用时需要自己拼接将参数拼接在url后面 opts如果跟后台有约定callback参数名就传{param: 约定参数名} ，没有默认callback]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue首屏优化之路由懒加载]]></title>
    <url>%2F2018%2F03%2F10%2FrouterLazy%2F</url>
    <content type="text"><![CDATA[项目比较大时build后首次加载会有很慢的问题,路由懒加载就是优化加载速度的方法之一 路由懒加载优化首屏加载速度首先贴个官方文档 1. 路由配置如下123456789101112131415161718192021222324252627282930// router 文件夹下的index.js文件import Vue from 'vue'improt VueRouter from 'vue-router'improt Holly from '@/pages/Holly' // 某页面Vue.use(VueRouter)// 非懒加载/* const routes = [ &#123; path: '/', name: 'holly', component: Holly &#125;] */// 懒加载const routes= [ &#123; path: '/', name: 'holly', componet: () =&gt; improt('@/pages/Holly') //其实就相当于按需加载 &#125;] //实例化const router = new VueRouter(&#123; routes&#125;)export default router 这就是将不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应组件。 2. main.js入口文件关于路由的配置1234567improt router from './router' //引入路由配置文件new Vue(&#123; el: '#app', router, // 注入到根实例中 render: h =&gt; h(App)&#125;) 今天把项目做了路由懒加载的优化，首屏快了几秒~ 😄]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用vue-cli初始化项目]]></title>
    <url>%2F2018%2F03%2F09%2Fvue-cli-init-project%2F</url>
    <content type="text"><![CDATA[可以快速初始化vue项目，提供一套本地node测试服务器，集成打包上线方案 利用vue-cli脚手架初始化项目1. 首先电脑需要安装好node和包管理工具 去官网下载node稳定版本 点击传送门 记得下载.msi格式的，可以避免配置环境变量 npm（node安装以后自带npm） 如果想使用cnpm 需要安装一下 12npm install -g cnpm --registry=https://registry.npm.taobao.org// 通常npm下载速度比较慢所以很多人会选择cnpm淘宝镜像 如果想使用yarn 需要安装一下 12npm install -g yarn// 只是命令上与npm和cnpm有些出入要看文档 具体的命令可以查看对应的官方文档 2.接下来是安装一个强大的编译工具 webpack和vue脚手架 我通常用cnpm装 12345678910// 全局安装webpackcnpm install webpack -g// 全局安装vue-clicnpm install vue-cli -g// 检测vue版本 -V大写vue -V// 检测node版本 -v小写node -v// npm 版本npm -v 3. 初始化项目 输入一些命令 12345678910111213141516vue init webpack myProject //myproject 为项目名称// 回车以后会询问几个简单的选项 我们进行填写 一路填写+回车Project name : myproject// 如果不需要更改直接回车就可以了。注意：这里不能使用大写，所以我把名称改成了myprojectProject description: // 项目描述 默认为A Vue.js project,直接回车，不用编写。Author：// 作者 如果你有配置git的作者，他会读取。Install vue-router ? // 是否安装vue的路由插件，我们这里需要安装，所以选择YUse ESLint to lint your code?// 是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n，如果你是大型团队开发，最好是进行配置。setup unit tests with Karma + Mocha? // 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。Setup e2e tests with Nightwatch?// 是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。 4. 下载依赖包及运行项目 cnpm i 包都下载好以后 npm run dev 项目就在本地跑起来了 浏览器中可以直接访问 5.有几个重要的文件,简单的认识一下 package.json scripts: 命令行里执行的命令具体做了什么，与这里一 一对应 例如npm run dev dependencies：生产环境以来的包，对应–save devDependencies: 开发环境中以来的包 对应–save-dev webpack.base.config.js webpack的基本配置文件 entry入口文件 output出口文件 babelrc es6转化为es5的配置 6. 项目打包上线 执行命令 12npm run build// 默认生产dist目录 里面是打包好的静态文件 可以部署到服务器 ​]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝与浅拷贝]]></title>
    <url>%2F2018%2F03%2F02%2FcopyDeep%2F</url>
    <content type="text"><![CDATA[最近工作中一个简单的赋值，引发了一个很奇怪的 bug。所以深拷贝和浅拷贝还是非常有必要弄清楚的。 1.首先看看 js 基本数据类型和引用类型的区别 基本数据类型：String , Number, Boolean, Null, Undefined 存放在栈内存中。直接按值存放，可以直接访问。 引用数据类型：Array, Object, Function 等；存放在堆内存中，变量实际保存是保存在栈中的一个地址，指向堆中具体的位置。从栈中获取地址再从堆内存中取到数据。 2.赋值，拷贝 基本数据类型拷贝的时候，在堆内存中开辟了新的空间，和原来的变量互不相干。不用考虑深拷贝浅拷贝的问题。 引用数据类型在用=号赋值时，实际上是将栈中的地址赋值给新的变量。所以当改变这个新的变量里的数据时，指向的堆中的数据也是会有变化的。（我那个 bug 也就是这个问题） 12345let a = 123let b = aa = 1234console.log(a) // 1234console.log(b) // 123 基本数据类型复制不会发生引用, 栈中会开辟新的空间存放 12345let arr = [1, 2, 3]let arr1 = arrarr[0] = 3console.log(arr) // [3, 2, 3]console.log(arr1) // [3, 2, 3] 引用数据类型复制是将栈中的地址赋值给变量，指向堆中的同一个空间，所以当改变其中一个时，其实是改变堆中的数据，所有指向这个空间的变量都会发生改变。 3.深拷贝和浅拷贝 上面的例子其实就是浅拷贝，引用类型的数据复制的是指向地址。 深拷贝，堆开辟一个新的空间存放复制的对象。 引用类型的浅拷贝会出现很多问题，那么下面来看看引用类型如何实现深拷贝。 4.实现深拷贝的方法 我最常用的一个是（简单粗暴）序列化反序列化法 1JSON.parse(JSON.stringify(obj)) 但这个方法存在一些问题 ： 无法复制正则表达式类型、函数类型 无论构造器是什么都会变成 Object undefined 无法复制 只能深拷贝对象和数组其他类型会失真 但实际开发中只是复制数据是够用的 迭代递归法 对对象进行迭代操作，对它的每个值进行递归深拷贝 1234567891011121314151617181920212223242526272829function deepClone(obj) &#123; let copy if (null == obj || 'object' != typeof obj) return obj // Date if (obj instanceof Date) &#123; copy = new Date() copy.setTime(obj.getTime()) return copy &#125; // Array if (obj instanceof Array) &#123; copy = [] for (var i = 0; i &lt; obj.length; i++) &#123; copy[i] = clone(obj[i]) &#125; return copy &#125; // Object if (obj instanceof Object) &#123; copy = &#123;&#125; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; copy[key] = clone(obj[key]) &#125; &#125; return copy &#125; throw new Error('error')&#125; Object.assign() ES6 的深拷贝方法 concat 对数组进行深拷贝 应该还有很多方法 或者更深入的思考 关于可枚举不可枚举这些概念我还不太清楚 有待进步]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>每日一坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ios系统与Date的Bug]]></title>
    <url>%2F2018%2F03%2F01%2FmoveIos-1%2F</url>
    <content type="text"><![CDATA[解决办法 （转化为/分隔的就可以） ios系统 Date.parse()获取时间戳时 ios系统只认得/分隔的时间 其它-分隔或者别的 ios获取的都是NaN123var resData = '2017-3-14 10:03:45'; resData=resData..replace(/-/g, '/'); console.log("返回时间：" + resData)]]></content>
      <categories>
        <category>每日一坑</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>移动</tag>
        <tag>踩坑记</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑Vue项目时服务突然停止(Node内存溢出)]]></title>
    <url>%2F2018%2F02%2F03%2FnodeFull%2F</url>
    <content type="text"><![CDATA[先描述下现象：vue项目在跑时偶尔出现webpack-dev-server服务停止,需要重新npm run dev. 1FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory 报错信息说堆内存溢出（其实就是node内存溢出） 解决办法： 如果是run dev时报错,在package.json文件里的scripts字段的 ‘dev’ : node 后面加上 –max_old_space_size=4096 这里的4096单位是M也就是4G（具体的大小根据实际情况而定） 如果是在打包时 就在build后面加上面的内容 原因 首先项目在跑时其实用的是用的webpack-dev-server工具，是一个小型的Node.js Express 服务器。 webpack在每次代码更改保存时都会进行编译然后实刷新页面得到最新的效果，但同时也会占用大量内存，也就是占用node内存。 node是基于V8构建的，V8对内存的使用是有限制的（老64位系统约1.4G，32位约0.7G，新生代内存64位约32M，32系统下约为16M）在这种限制下，如果不小心触碰到这个界限，就会造成进程退出。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>每日一坑</tag>
        <tag>Node</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的bus组件通信时多次触发的问题]]></title>
    <url>%2F2018%2F01%2F07%2FbusVue%2F</url>
    <content type="text"><![CDATA[解决办法 在组件中 beforeDestory周期 bus.$off(“emit的事件名”) 手动销毁事 Vue利用bus进行组件通信时，因为bus是全局的不受页面生命周期控制，所以会发生多次触发的问题。多个页面都用到同一个组件而组件又用到了bus，那么这个组件通过bus emit了多少次这个页面在on时就会触发多少次。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>组件通信</tag>
        <tag>bus</tag>
        <tag>每日一坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题梳理]]></title>
    <url>%2F2016%2F01%2F02%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[准备面试，个人梳理，比较乱； 如何实现图片懒加载 利用自定义属性data-imageUrl先存放图片地址，监听外层盒子滚动事件，遍历检测图片位置，若在可视区内，将data-imageUrl赋值给src显示图片； 可视区内： 方法1 const bound = el.getBoundingClientRect() 返回一个位置对象 const clientHeight = window.innerHeight 可视区高度 bound.top &lt;= clientHeight + 50 时在可视区内 （50是为了提前加载图片） 方法2 通过document.documentElement.clientHeight获取屏幕可视窗口高度 通过element.offsetTop获取元素相对于文档顶部的距离 通过document.documentElement.scrollTop获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离 2-3 &gt;0则在可视区内 ​ 优化： 滚动时不断遍历和赋值src，损耗性能，可以利用节流函数，在用户滚动某一个时间后才遍历和赋值。（效果看起来就像是用户停止滚动时加载图片） 设一个标识记录已加载图片的index，当滚动时就不遍历所有图片了。 前端性能优化 对高频触发的事件进行节流或消抖(debounce 和throttle 这两个函数),scroll事件及tochmove等高频事件； css避免使用通配符*（它会匹配所有元素） js放底部css放顶部（js会阻塞页面解析，css会阻塞页面呈现和js执行），但如今使用webpack等工具基本上不用考虑这种影响； 首屏: 减少网络请求次数，减小文件体积使用cdn加速（gulp、webpack、grunt等构件工具压缩合并） 以上参考链接：https://mp.weixin.qq.com/s/qglFD2nHFqFBivb8T23Qtg 浏览器缓存：服务器响应的header 信息 缓存策略 获取资源形式 状态码 发送请求到服务器 强缓存 从缓存取 200（from memory cache） 否，直接从缓存取 协商缓存 从缓存取 304（not modified） 是，通过服务器来告知缓存是否可用 Service worker 可以解决目前离线应用的问题，同时也可以做更多的事。 Service Worker 可以使你的应用先访问本地缓存资源，所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能（一般称之为 Offline First）。这是原生APP 本来就支持的功能，这也是相比于 web app ，原生 app 更受青睐的主要原因。 参考链接：https://juejin.im/post/5b0bff30f265da08f76cc6f0 如果需要动态改变css样式 尽量使用改变className 只触发一次reflow 慎用全局变量 全局变量需要搜索更长的作用域链。 全局变量的生命周期比局部变量长，不利于内存释放。 类型转换隐式转换要比api转换效率高 使用事件代理（事件委托）：当要对多个元素绑定事件时可以加将事件绑定到父元素然后通过判断e.target.nodeName执行 1234567891011121314151617&lt;ul id="parent-list"&gt; &lt;li id="post-1"&gt;Item 1 &lt;li id="post-2"&gt;Item 2 &lt;li id="post-3"&gt;Item 3 &lt;li id="post-4"&gt;Item 4 &lt;li id="post-5"&gt;Item 5 &lt;li id="post-6"&gt;Item 6 &lt;/li&gt;&lt;/ul&gt; // Get the element, add a click listener... document.getElementById("parent-list").addEventListener("click",function(e) &#123; // e.target is the clicked element! // If it was a list item if(e.target &amp;&amp; e.target.nodeName == "LI") &#123; // List item found! Output the ID! console.log("List item ",e.target.id.replace("post-")," was clicked!"); &#125; &#125;); 以上参考链接: https://segmentfault.com/a/1190000003646305 延迟加载 非首屏使用的数据样式脚本图片等，用户交互时才显示。（例如vue的路由懒加载） 减少iframe的使用:阻塞页面，缺乏语义； 首选get请求 post有两步先发送header再发送数据，而get只有一个步骤，tcp数据包发送数据； 减少cookie大小，cookie通过http投在服务器和浏览器间来回传送，减小可降低响应速度。 使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树 以上参考链接： https://csspod.com/frontend-performance-best-practices/ 什么是虚拟 DOM,为什么说虚拟dom比真实dom快 我的理解是 Virtual DOM也就是虚拟dom,其实是js对象模拟的dom树 js操作数据比真实dom要快很多 处理完以后再渲染成真实dom 谈一下你对 MVVM 的认识 首先说一下mvm：将软件分为三部分 视图（view）: 用户界面 控制器（controller）: 业务逻辑 模型（model）: 数据保存 他们之间的通信，view传达指令给controller，controller完成业务逻辑要求Model改变状态，Model将新的数据发送到view，用户得到反馈。单向 MVVM 模式将controller改名为viewModel 区别就是它采用双向数据绑定，view的变动自动反映在viewModel上，反之亦然 viewModel负责把model的数据同步到view显示出来，还负责把view的修改同步会model 写一个函数把url参数以键值对的方式放到一个对象里 1234567891011121314151617181920212223242526 let url = 'https://www.baid.com/s?edw=ddds&amp;ksjn54=546&amp;sdcnsl=5465&amp;cs=54'// 字符串切割处理 function params(url) &#123; if(url.indexOf('?') &lt; 0 ) return let arr = url.split('?') let arrL = arr[1].split('&amp;') let obj = &#123;&#125; for(let i=0;i&lt;arrL.length;i++)&#123; let cur = arrL[i].split('=') obj[cur[0]] = cur[1] &#125; return obj &#125; console.log(params(url)) // &#123;edw: "ddds", ksjn54: "546", sdcnsl: "5465", cs: "54"&#125;// 正则function paramsA(url)&#123; let reg = /([^&amp;?=]+)=([^&amp;?=]+)/g let obj = &#123;&#125; url.replace(reg, function()&#123; console.log(arguments) obj[arguments[1]] = arguments[2] &#125;) return obj&#125; 数组去重 12345678910111213141516171819202122// 利用indexOf返回第一个符合要求的index [256, 22, '11', 33, 22, 66, '11', '11'].filter((v, i, array) =&gt; &#123; return array.indexOf(v) === i&#125;) // [256, 22, "11", 33, 66]// 利用Set的唯一性let arr = [1,3,2,1,'1',3]let setArr = [...new Set(arr)] // [1, 3, 2, "1"]// 利用对象属性唯一 let arr = [256, 22, 33, 22, 66, '11', '11'] function arrS(arr) &#123; let obj = &#123;&#125; let result = [] for(let i=0;i&lt;arr.length ;i++)&#123; if(!obj[arr[i]]) &#123; obj[arr[i]] = i result.push(arr[i]) &#125; &#125; return result &#125; arrS(arr) // [256, 22, 33, 66, "11"] 取数组中最大值 1234567891011121314151617181920let arr = [1321,515,6,565,151,-85,55]// 扩展运算符Math.max(...arr)// applyMath.max.apply(null, arr)// for循环 每次循环取出较大的一个和后面一个对比 循环结束最终就是最大的let max = arr[0]for(let i = 0; i &lt; arr.length; i++) &#123; max = max &lt; arr[i+1] ? arr[i+1] : max&#125;// sort 降序排序取第一个arr.sort((num1, num2)) &#123; return num2 - num1&#125;arr[0]// reducearr.reduce((num1, num2) =&gt; &#123; return num1 &gt; num2 ? num1 : num2&#125;)// 这个方法类似于上面的for循环 不断对比返回较大的值 闭包的作用，优缺点 形成私有作用域保护私有变量不受外界干扰； 形成不销毁的栈内存，保存起来；（jq） 缺点：耗内存 三栏布局 左右300px高固定中间自适应 浮动：左右各左右浮动宽度300px； 定位：外层容器相对定位，左中右绝对定位，左left0top0,中left300right300右right0top0; flex布局：外层容器display:flex；左右给width:300px;中flex:1;自适应 table布局：外层容器display:table;width：100%；height固定，左中右display:table-cell;左右宽度固定； grid布局(网格)；外层容器display:grid;witdth:100%;grid-template-rows:100px;gridtemplate-cloums:300px auto 300px; CSS盒模型 基本概念：标准模型+IE模型 标准模型的宽高就是content的宽高 IE模型宽高包含padding和border 设置两种模型 box-sizing: content-box;标准模型，浏览器默认 box-sizing:border-box;IE模型 获取盒模型对应的宽和高 dom.style.width/height只能取到内联样式 dom.currentStyle.width/heigt 最终渲染后的宽高（仅支持IE） window.getComputedStyle(dom).width/height 最终渲染后的宽高（通用性更好一些） dom.getBoundingClientRect().width/height 最终渲染的宽和高 BFC 边距重叠解决方案 基本概念：块级格式化上下文； 原理（渲染规则） BFC元素垂直方向边距会重叠 BFC的区域不会与浮动元素的box重叠（清除浮动） BFC在页面上是独立的容器不会与外面的元素互相影响 计算BFC高度时浮动元素也会参与计算 如何创建BFC overflow的值不为”visible float不为none; position值不为static 或 relative; display:table-cell”, “table-caption”, or “inline-block”中的任何一个; 解决边距问题 清除浮动对页面的影响 解决父元素没有被脱离标准流的子元素撑高为0 DOM事件相关 DOM事件类-事件级别 DOM0 element.onclick = function(){} DOM2 element.addEventListener(‘click’,function(){},false) DOM3 element.addEventListener(‘keyup’,function(){},false) 事件模型 冒泡 捕获 事件流 事件通过捕获到达目标元素，目标元素再上传到window 事件捕获具体流程 window=&gt;document=&gt;html=&gt;body=&gt;…=&gt;目标元素 Event对象的常见应用 event.preventDefault() 阻止默认行为 event.stopPropagation() 阻止冒泡 event.stoplmmediatePropagation() 事件优先级 event.currentTarget 当前绑定事件的元素 event.target 当前被点击的元素 自定义事件 12345var eve = new Event('custome')ev.addEventListener('custome',function()&#123; console.log('custome')&#125;)ev.dispatchEvent(eve) HTTP协议 http协议的主要特点：简单快速，灵活，无连接，无状态； 报文组成部分 请求报文：请求行（http方法，http协议，页面地址），请求头（key-value格式），空行（服务器区分请求头和请求体），请求体； 状态行，响应头，空行，响应体； http方法 GET 获取资源 POST 传输资源 PUT 更新资源 DELETE 删除资源 HEAD 获得报文首部 GET和POST的区别 GET请求在URL传递参数是有长度限制的，post没有 GET只接收ASCII字符而POST没有限制 GET请求通过URL传递参数POST放在Request body中 相对来说GET更不安全一些，不能传递敏感信息 GET请求浏览器主动缓存，POST不会 状态码 1XX ：指示信息-表示请求已接收，继续处理 2XX：成功-表示请求已被成功接收 3XX：重定向-要完成请求必须进行更进一步操作 4XX：客户端错误-请求有语法错误或请求无法实现 5XX：服务器错误-服务器未能实现合法的请求 常见的状态码：200 客户端请求成功，206客户发送了一个带有Range头的get请求，服务器完成了他，301所有请求的页面已经转移至新的url,302所请求页面已经临时转移新url304 客户端有缓存的文档并发出了一个条件性请求，服务器告诉客户端，原来缓存的文档还可以继续使用。400 客户端请求语法错误不能被服务器理解；401请求未经授权 403访问被禁止404请求不资源不存在500服务器发生不可预期错误503请求未完成服务器临时过载或当机一段时间后可能恢复 ​ 持久连接 keep-alive http版本1.1支持 非keep-alive模式，每个请求/应答客户和服务器都要新建立一个连接，完成之后立即断开连接（http协议为无连接的协议） 使用keep-alive模式时，keep-Alive功能使客户端到服务器端连接持续有效，当出现服务器的后续请求时，keep-alive功能避免了建立或者重新建立连接。 创建对象的几种方法 123456789101112// 字面量let obj = &#123;a:1&#125;// new运算符let obj1 = new Object(&#123;b:2)// 构造函数let Fn = function(num) &#123; this.c = num&#125;let CC = new Fn(3)// Object.createlet DD = &#123;d: 4&#125;let D4 = Object.create(DD)//以DD为原型的对象 原型、构造函数、实例 实例通过new构造函数创建 构造函数有prototype属性指向原型对象 原型对象constructor指向构造函数（构造器） 构造函数.prototype.constructor === 构造函数 实例.__proto_指向原型对象 instanceof 可以判断是否在原型链上 constructor更加严谨 new运算符过程 例如 let foo2 = new Foo() 一个新对象被创建。它继承来自于foo.prototype 构造函数foo被执行，执行的时候相应的传参会被传入，同时上下文（this）,会被指定为这个新实例。 如果构造函数返回了一个对象，那么这个对象会取代整个new出来的结果。如果构造函数没有返回对象，那么new出来的结果为步骤1创建的对象。 面向对象 类的声明 123456789101112// 构造函数function Person(name) &#123; thus.name = name&#125;console.log(new Person('holly'))// ES6 classclass Person1() &#123; constructor(name) &#123; this.name = name &#125;&#125;console.log(new Person1('holly')) 类的继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// &lt;-- 借助构造函数实现继承 call --&gt;function Person() &#123; thus.name = 'person'&#125;function Child1() &#123; Person1.call(this) // 只能继承Person的私有属性 this.type = 'child'&#125;// &lt;-- 原型链继承 --&gt;function Person2() &#123; this.name = 'parent2' this.play = [1,2,3]&#125;function Child2() &#123; this.type = 'child2'&#125;// child2的原型对象指向Person2的实例 实现私有公有继承Child2.prototype = new Person2()// 缺点 改变一个实例的远行对象另一个也会变let s1 = new Child2()let s2 = new Child2()s1.play.push(4)console.log(s1.play) // [1,2,3,4]console.log(s2.play) // [1,2,3,4]// 改变一个实例的原型对象另一个也会改变// &lt;-- 组合方式 --&gt;function Person3 () &#123; this.name = 'person3' this.play = [1,2,3]&#125;function Child3() &#123; Person3.call(this) this.name = 'child3'&#125;Child3.prototype = new Person3()let s3 = new Child3()let s4 = new Child3()s1.play.push(4)console.log(s3.play) // [1,2,3,4]console.log(s4.play) // [1,2,3]//缺点 执行了两次父类 constructor也继承了// &lt;-- 组合的优化 --&gt;function Person3 () &#123; this.name = 'person3' this.play = [1,2,3]&#125;function Child3() &#123; Person3.call(this) // 拿到私有属性 this.name = 'child3'&#125;Child3.prototype = Parent3.prototype //拿到原型指向let s3 = new Child3()let s4 = new Child3()s1.play.push(4)console.log(s3.play) // [1,2,3,4]console.log(s4.play) // [1,2,3]//缺点 constructor也继承了// &lt;-- 优化2 -- &gt;Child3.prototype = Parent3.prototype //改为下行Child3.prototype = Object.create(Parent3.prototype）// 可以实现一层一层原型 ​ 完全 CSRF：跨站请求伪造（用户在A登陆过，B引诱用户点击A接口） 可以用token验证 referer验证 隐藏令牌 XSS ： 跨域脚本攻击，向页面注入js 避免的宗旨是让注入的js无法执行 算法 排序 快速排序：取中间值左右两边放大于和小于然后递归实现 123456789101112131415161718let quickSort = function(arr)&#123; if(arr.length &lt;= 1) &#123;return arr&#125; let pivotIndex = Math.floor(arr.length / 2) // 定义一个基准 数组中间的那个数 var pivot = arr.splice(pivotIndex, 1)[0] var left = [] var right = [] // 循环数组 小于基准的放left 大于等于基准的放right for(let i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; pivot) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; // 递归这个过程 return quickSort(left).concat([pivot], quickSort(right))&#125; ​ 选择排序 12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; ​ 希尔排序 123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while(gap &lt; len/3) &#123; //动态定义间隔序列 gap = gap*3+1; &#125; for (gap; gap &gt; 0; gap = Math.floor(gap/3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; return arr;&#125; ​ 冒泡排序：两两对比需要循环两层，内层做次数优化 12345678910111213function bubbleSort(arr)&#123; let len = arr.length for(let i = 0; i&lt; len; i++) &#123; for(let j = 0; j &lt; len -1 -i; j++) &#123; if(arr[j] &gt; arr[j+1])&#123; let temp = arr[j+1] arr[j+1] = arr[j] arr[j] = temp &#125; &#125; &#125; return arr&#125; ​ 数组的常用方法 concat: 链接两个或多个数据，返回结果； every: 对数组中每一个项运行给定的函数，如果该函数每一项都返回true,则返回true; some：对数组中每一项运行给定函数，如果任一项返回true,则返回true; map: 对数组中每一项运行给定函数，返回每次函数调用的结果组成的数组； filter: 对数组中的每一项运行给定函数，然后该函数返回true的项组成的数组； forEach: 对数组中每一项运行给定函数，没有返回值； join: 将所有的数组元素链接成一个字符串可以给定连接符（‘-’）,默认逗号； indexOf：返回第一个与给定参数相等的数组元素的索引，没有找到返回-1； lastIndexOf: 返回在数组中搜索到与给定参数相等的元素的索引里最大的值； reverse:颠倒数组中元素的顺序； slice: 传入索引值，将数组中对应索引范围内的元素作为新元素返回,不改变原数组； splice: 传入从索引A开始 删除几个(b)替换为(c); toString: 将数组作为字符串返回； valueOf 和 toString相似，将数组作为字符串返回； reduce(） 可以实现累加 [1,2,3,4,5].reduce(() =&gt; {return a + b}) includes: 传入参数在数组中返回true sort：传入函数参数为a,b 函数体return a-b（升序）b-a（降序） push: 向数组最后插入，返回数组长度； pop: 传入从后删除几项，返回被删除的项，默认一项； shift:传入从前删除几项，返回被删除的项，默认一项； unshift向前插入，返回数组长度； 字符串常用方法 charAt(n): 返回字符串第n个字符，如果n不在0-字符串.length上返回空字符串； indexOf(a);返回a在字符串中首次出现的索引，没有返回-1； lastIndexOf():搜索字符在字符串中最后出现的索引，没有返回-1； substring(a,b):返回a-b之间的字符串，不改变原字符串；（包头不包尾） slice(a,b):返回a-b之间的字符串，不改变原字符串（包头不包尾） replace(a,b) ;b替换a返回新字符串，不改变元字符串 match(regexp)返回一个包含匹配结果的数组，如果没有匹配项返回null trim()去除字符串开头结尾的空白符，返回str副本不影响原字符串； tolowerCase()转为小写 toUpperCase()转为大写 cancat()链接字符串 split把字符串分割为以传入为分隔的数组 ​ Math常用方法 ceil()向上取整 floor向下取整 round四舍五入 max(x,y)返回最大值 min(x,y)返回最小值 pow(x,y)返回x的y次幂 random() 返回0~1之间的随机数 sqrt()返回数的平方根 正则 compile编译正则表达式 exec 检索字符串中指定值返回找到的值并确定位置 test检索字符串中指定的值，返回true或false search检索正则表达式相匹配的值 match找到一个或多个正则表达式匹配 raplace替换与正则表达式匹配的字符串 对象 Object.assign({}, person)，将一个或多个对象中的值复制到一个目标对象 Object.keys(obj) 返回obj属性组成的数组 Object.defineProperty() 修改或创建对象属性的特性 a.hasOwnProperty(b) a是否有属性b 返回boolean DOCTYPE作用 声明文档类型和DTD规范，主要用途：文件合法性验证； htm5写法 &lt;!DOCTYPE html&gt; 浏览器渲染机制 渲染过程 html从上至下渲染domtree cssom tree domtree cssomtree 整合成rendertree ​ 重排reflow 增加删除修改dom 移动dom位置 修改css样式 resize窗口的时候，或者滚动 修改网页默认字体时 js运行机制 js是单线程的 任务队列 Event Loop 事件循环 所有同步任务都在主线程上执行，形成一个执行毡 主线程之外还存在任务队列，只要是异步任务，就在任务队列中 一旦所有同步任务执行完毕，系统会读取任务队列，开始执行 主线程不断重复上面三部 页面性能 资源压缩合并，减少http请求； 异步加载 动态加载 defer html解析玩后执行按顺序 async加载完之后执行，不按顺序 浏览器缓存 强缓存 expires:服务器过期时间绝对时间 Cache-Contro; max-age=3600相对时间 单位（秒） 协商缓存 问服务器是否缓存 ​ CDN 预解析DNS 错误监控 错误分类 代码错误 资源加载失败 错误捕获方式 try…catch ​ html5新标签 header/footer section/article nav aside]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
