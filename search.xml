<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javascript对象的属性描述符]]></title>
    <url>%2F2018%2F06%2F01%2Fjavascript%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[经常会看到一些技术文章说，可枚举不可枚举，一直很懵。其实就是对象属性描述符中的Enumerable(可枚举性)。下面来看看有哪些对象属性描述符~ 描述符类型 分为两种 数据属性(data property) 包含一个数据值的位置，在这个位置可以读取和写入值,有四个特性 访问器属性(accessor poperty) 名字、值和一组属性描述符构成的。而属性值可以用一个或两个方法替代，这两个方法就是getter和setter 他们共同的特性 configurable(可配置性) 可配置性决定是否可以使用delete删除属性，以及是否可以修改属性描述符的特性，默认true; 设置为false后无法使用delete删除属性，严格模式下直接报错；并且不能使用defineProperty()方法来修改属性描述符，但可以用使用defineProperty()方法将writable的状态从true改为false（只有这一种情况可以修改）；var声明变量时默认为false; enumerable(可枚举性) 可枚举性决定属性是否出现在对象的属性枚举中。 用户定义的普通属性默认是可枚举的，而原生继承的属性默认是不可枚举的。 propertyIsEnumerable() 可以判断对象的属性是否可枚举 123456var o = &#123;a:1&#125;;console.log(o.propertyIsEnumerable('a'))//trueObject.defineProperty(o,'a',&#123;enumerable:false&#125;)console.log(o.propertyIsEnumerable('a'))//false ​ 具体来说，比如 fon in 循环是否能遍历到该属性 Object.keys方法是否能取到该属性 JSON.stringify方法是否能取到该属性 不同的特性数据属性 ： value (属性值) 属性值包含这个属性的数据值，读取属性值的时候，从这个位置读，写入属性值的时候，把新值保存在这个位置。默认undefined。 writable (可写性) 可鞋型决定是否可以修改属性的值，默认为true;设置为false后赋值语句会静默失败，严格模式赋值直接报错； 通过Object.defineProperty()方法改变属性value的值不会受影响，因为这也意味着在重置writable的属性值为false 访问器属性： getter 在读取属性时调用的函数。默认undefined setter 在写入属性时调用的函数。默认undefined 1234567891011121314151617181920212223242526// getter 和 setter 取代了数据属性中的value和writable属性// 只设置get方法没有set方法 对象的赋值会静默失败 严格模式下会报错// 只设置set方法而不设置get方法 对象的属性值为undefined// 所以一般都是成对出现的var o =&#123; get a()&#123; return this._a; &#125;, set a(val)&#123; this._a = val*2; &#125;&#125;o.a = 1;console.log(o.a);//2// 可读可取// 利用Object.defineProperty()对o的属性a的getter和setter进行配置Object.defineProperty(o,'a',&#123; get: function()&#123; return this._a; &#125;, set :function(val)&#123; this._a = val*2; &#125;&#125;)o.a = 1;console.log(o.a);//2 ​ 描述符方法 Object.getOwnPropertyDescriptor() 第一个参数是该对象，第二个参数时对象的某一个属性。用于查询一个属性的描述符，并以对象的形式返回 123let obj = &#123;holly: 'nice'&#125;console.log(Object.getOwnPropertyDescriptor(obj, 'holly'))// &#123;value: "nice", writable: true, enumerable: true, configurable: true&#125; ​ Object.defineProperty() 第一个参数时对象，第二个参数是对象的某一个属性，第三个参数是要修改的配置；用于创建或配置对象的一个属性的描述符，返回配置后的对象（创建时，如果不针对描述符配置，则该项描述符默认false） 123456789let holly = &#123;&#125;console.log(Object.defineProperty(holly, 'name', &#123; value: 'holly', writable: true&#125;))// &#123;name: "holly"&#125; 返回该对象console.log(Object.getOwnPropertyDescriptor(holly, 'name'))// &#123;value: "holly", writable: true, enumerable: false, configurable: false&#125;// 由于没有配置 enumerable和configurable 为false Object.defineProperties() 第一个参数是该对象，第二个是要修改的属性为键 特性为值组成的对象；用于创建或配置对象的多个属性的描述符，返回配置后的对象。 12345678910111213let desc = &#123;a: 1, b: 2&#125;console.log(Object.defineProperties(desc, &#123; a: &#123; value: 3, enumerable: false &#125;, b: &#123;writable: true&#125;&#125;))// &#123;b: 2, a: 3&#125;console.log(console.log(Object.getOwnPropertyDescriptor(desc, 'a')))// &#123;value: 3, writable: true, enumerable: false, configurable: true&#125;console.log(Object.getOwnPropertyDescriptor(desc, 'b'))// &#123;value: 2, writable: true, enumerable: true, configurable: true&#125; Object.create() 第一个参数指定原型，第二个参数属性和描述符对象；用于指定原型和属性来创建一个对象 1234567let newOne = Object.create(Object.prototype, &#123; a: &#123;value: 'hello', enumerable: true&#125;&#125;)console.log(newOne)// &#123;a: "hello"&#125;console.log(Object.getOwnPropertyDescriptor(newOne,'a'))// &#123;value: "hello", writable: false, enumerable: true, configurable: false&#125; 参考链接: https://www.cnblogs.com/xiaohuochai/p/5743821.html ​ 应用场景 大部分是框架才会用到，比如Vue.js的双向数据绑定]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端前端开发调试工具-vConsole]]></title>
    <url>%2F2018%2F05%2F26%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7-vConsole%2F</url>
    <content type="text"><![CDATA[在写移动网页时，手机上调试可以使用vConsole，类似于谷歌浏览器的f12调试工具。 github地址传送✌ 效果图 console日志 网络请求 页面结构 cookie及本地存储 也可执行输入的js代码 使用方法 装包 1cnpm install vconsole --save-dev main.js中引入并创建实例 12import VConeole from 'vconsole'const vConsole = new VConsole() 由于vConsole只在开发时使用，所以可以根据环境变量进行实例化 12345process.env.NODE_ENV === 'production' ? '' : dev()function dev() &#123; const vConsole = new VConsole() console.log('开发环境启用vconsole')&#125; 遇到的一个小问题当在vue项目中利用vConsole 打印 $refs获取dom就会出现报错 代码如下： 1console.log(this.$refs.app, 555) 报错信息： 最终也打印出来了，不影响功能。 issues 152 提了这个问题 暂时还没有解决]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript的模块化]]></title>
    <url>%2F2018%2F05%2F24%2Fjavascript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[由于现在的网页可以看作是一个功能丰富的应用，需要对代码进行分割、作用域隔离、模块之间的依赖管理以及发布到生产环境时的自动化打包与处理等。 ES6模块（Module）模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 export 与 import12345678910111213141516171819202122232425262728// test.jsexport const testName = 'Cindy'export const testAge = '15'// export 对外输出两个变量---------------------------------// 也可以这样写const testName = 'Cindy'const testAge = '15'export &#123;testName, testAge&#125;// 等价于上面那种写法，不过这样更清晰，底部可以看出对外输出了哪些变量---------------------------------// 也可以输出函数和类（class）export function fn(x, y) &#123; return x + y&#125;// 对外输出一个函数 fn===================================// 与其对应的加载这个模块 import (import是只读的)// testImport.jsimport &#123;testName, testAge，fn&#125; from './test.js'-----------------------------------// 如果加载时想换一个变量名 可以用as关键字import &#123;testName as firstName, testAge as egg&#125; from './test.js'-----------------------------------// 可以使用 * 指定一个对象，整体加载import * as test from './test.js'console.log(test.testName)test.fn(1, 2) export 不能直接 export 具体的数据或变量 ，变量声明语句或者{包裹的数据或变量} export输出的内容import时要对应名字，或者用as改变名字 export default 与 import12345678910// default.jsexport default function () &#123; console.log('foo');&#125;// 默认输出一个匿名函数// import命令可以为该函数指定任意名字import toName from './default'toName() // 'foo'// 即便不是匿名函数 import时也可以指定任意名字 因为export default只能使用一次 输出一个叫做default的变量或方法// export default 后面不能跟变量声明语句 export default 只能使用一次,默认输出一个叫做default的变量或方法，所以import时可以取任意名字 export default 后面不能跟变量声明语句，只能是变量名 其他的模块化方案 CommonJS基于Node.js （require(), module.exports） AMD 由RequireJS提出的，CMD 由 SeaJS提出的,两种用法基本相似（define）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue音乐demo总结]]></title>
    <url>%2F2018%2F05%2F17%2Fvue%E9%9F%B3%E4%B9%90demo%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[很敬佩黄轶老师，涵盖了非常多的知识点。跟着敲还是需要一些vue基础的。 关于Vue开发音乐app的项目总结 我把它部署到了自己的服务器 可以扫码查看 左上角也可以下载我打包好的app ╮(╯▽╰)╭由于我没有备案 直接用的服务器ip 所以微信扫码请点击查看原网页,微信扫码请点击查看原网页, 微信扫码请点击查看原网页。重要的事情说三遍 1.利用vue-cli 初始化项目 请查看本站另一篇文章 ✌点击传送门 2.meta标签的移动端的自适应在index.js的head标签内写name为viewport的meta标签1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0, user-scalable=no"&gt; 了解一下viewport及相关属性设置 属性 值 width 设置layout viewport 的宽度，为一个正整数，或字符串”width-device”设备宽度 initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 height 设置layout viewport 的高度，这个属性并不重要，很少使用 user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许 根据上面这个表格不难看出：width为设备宽度，初始缩放为1，最大及最小缩放都为1，不允许缩放 3.添加依赖 babel-runtime和babel-polyfill实现ES6转ES5babel默认只换新的javascript语法，不转换新的api，所以要安装babel-polyfill，但是会污染全局变量 为了不污染全局变量和内置对象原型，又想使用ES6新语法和api就需要配合使用babel-runtime,可以避免重复代码 12cnpm i babel-runtime --savecnpm i babel-polyfill --save-dev 然后需要在入口文件main.js中 1imprort 'bable-polyfill' 4.引入fastclick解决移动端300ms点击延迟的问题1cnpm i fastclick --save fastclick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。 然后在入口文件引入 12import fastclick from 'fatclick'fastclick.attach(document.body) 5.webpack.base.conf.js中可以配置别名1234567resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; '@': resolve('src'), 'common': resolve('src/common') &#125;&#125; 这样页面import某个在src/common下的对象时可以直接写 import music from &#39;common/music&#39; 6.路由文件的配置1234567891011121314151617181920212223242526272829303132// 在router文件夹内的index.jsimport Vue from 'vue'import Router from 'vue-router'// 以上是脚手架搭建项目已经写好的// 假如现在有三个页面 先导入import Test1 from 'src/components/test1'import Test2 from 'src/components/test2'import Test3 from 'src/components/test3'Vue.use(Router)export default new Router(&#123; routes:[ &#123; path: '/', redirect: '/test1' // 重定向path'/test1' &#125;, &#123; path: '/test1', component: Test1 &#125;, &#123; path: '/test2', component: Test2 &#125;, &#123; path: '/test3', component: Test3 &#125; ]&#125;) 完成了基本的路由配置 App.vue里的router-view就会渲染对应path的component 最好是使用路由按需加载，请查看本站另一篇文章✌ 点击传送 7.router-link的使用12345&lt;router-link tag="div" class="tab-item" to="/test1"&gt; &lt;span class="tab-link"&gt;测试&lt;/span&gt;&lt;/router-link&gt;// tag是渲染的标签 to对应点击以后的path// router会默认有一个class router-link-active 可以覆盖自定义样式 8.子组件引入和使用的规范引入使用首字母大写加驼峰 使用小写 - 连接 12345// 父组件 test2中引入test1improt TestOne from 'components/test1'// template中使用时&lt;test-one&gt;&lt;/test-one&gt;// 尽量语义化 我这里随意写的就没有语义化... 9.jsonp的原理和使用 原理请查看本站另一篇文章✌点击传送 项目中引入了jsonp插件 1cnpm i jsonp --save 因多处会使用到jsonp对它进行一层封装 12345678910111213141516171819202122232425import originJSONP from 'jsonp'export default function jsonp(url, data, option) &#123;// url与处理后的data拼接 url += (url.indexOf('?') &lt; 0 ? '?' : '&amp;') + param(data) // 返回一个promise return new Promise((resolve, reject) =&gt; &#123; originJSONP(url, option, (err, data) =&gt; &#123; // 插件默认返回第一个参数为null第二个参数为数据 所以会接收两个参数 if (!err) &#123; resolve(data) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125;// 对data数据进行处理function param(data) &#123; let url = "" for (var k in data) &#123; let value = data[k] !== undefined ? data[k] : '' url += `&amp;$&#123;k&#125;=$&#123;encodeURIComponent(value)&#125;` &#125; return url ? url.substring(1) : ''&#125; 因为使用promise封装了 所以调用时要用到.then 12import jsonp from 'common/js/jsonp'jsonp(url, data, option).then((res) =&gt; &#123;console.log(res)&#125;) 那么问题来了 ↓ 10.为什么要使用promise对jsonp进行封装试想一种应用场景（回调地狱）A通过jsonp请求获取，B拿到A返回的数据作为参数通过jsonp请求获取，C拿到B返回的数据作为参数通过jsonp请求获取 我们的做法一般都是，执行jsonp({Aparams})并在A回调里拿到B需要的参数并且执行jsonp({Bparams})然后在B的回调里拿到C需要的参数并且执行jsonp({Cparams}) 一两层回调的嵌套其实也觉得还好，但如果业务逻辑复杂需要嵌套100层呢？这样就非常不便于阅读和维护，也就是常听到的“回调地狱” 以上promise封装是怎么做到解决回调地狱的呢？还是上面那个应用场景，我们用以上封装的jsonp怎么使用呢 jsonp({Aparams}).then(jsonp({Bparams})).then({jsonp(Cparams)})即可 当第一个jsonp执行后返回一个promise对象，promise对象状态发生改变就会触发then并且可以拿到A的resolve传递出去的数据,再执行第二个jsonp返回一个promise对象，让promise对象状态发生变化时触发then可以拿到B的resolve传递出去的数据再执行第三个jsonp，依次类推，非常清晰。 当然业务上其实有reject的情况，这时会执行.catch( // 进行错误处理) 那么问题来了，什么是promise状态发生改变时 promise的三种状态 pending(进行中)； fulfilled(已成功)； rejected(已失败)。 状态改变 当执行resolve时,promise对象的状态会从pending 变为 fulfilled； 当执行reject时,promise对象的状态会从pending 变为 rejected; 当然ajax也可以结合promise封装，axios已经结合了promise可以直接使用 11.better-scroll的使用 由于项目很多地方都需要滑动，所以我们对better-scroll进行封装 详见本站另一篇文章✌ 点击传送 12.图片懒加载: Vue-Lazyload 非常好用的一个优化插件 官方文档✌ 点击传送 使用步骤1.npm 安装 1cnpm install vue-lazyload --save 2.main.js中use 1234567import VueLazyLoad from 'vue-lazyload'Vue.use(VueLazyLoad, &#123; // loading图片 loading: require('本地图片路径')&#125;)// 页面中使用 只需要用v-lazy指令替换src就可以了// scr="imgUrl" =&gt; v-lazy="imgUrl" 更多属性请看官方文档，超超超好用 13.vuex的使用vuex帮助我们管理共享状态,多个没有什么关联性的组件想要共享状态可以通过vuex 详见本站另一篇文章 ✌ vuex的学习及使用 14.ES6 class类的基本使用 ES5中生成实例对象的方法–构造函数 12345678function Holly(x, y) &#123; this.x = x this.y = y&#125;Holly.protitype.connect = function() &#123; return (this.x + ',' + this.y )&#125;var hollyTree = new Holly('www.hollytree', '.top') ES6 中引入class这个概念,针对上面改写 123456789101112// 定义一个Holly的类class Holly &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; // 方法直接定义 不需要function关键字 也不需要逗号 connect() &#123; return (this.x + ',' + this.y ) &#125;&#125;var hollyTree = new Holly('www.hollytree', '.top') Holly类里有一个cunstructor方法，这就是构造方法this指向实例。 也就是说ES5中的构造函数Holly对应ES6中Holly类的构造方法 ES6的类可以看做构造函数的另一种写法，typeof 类 返回 ‘function’,数据类型为函数，类本身指向构造函数； 类所有的方法都定义在类的prototype（原型）上； 原型对象的constructor属性直接指向类本身与ES5一致 由于项目中多处用到歌曲的数据，并且数据需求的格式基本一样，所以这里选择用类来创建song实例12345678910111213141516171819202122// song.js// 定义一个Song类，类的构造函数接收一些参数并指向实例export default class Song &#123; constructor(&#123; id, mid, singer, name, album, duration, image, url &#125;) &#123; this.id = id this.mid = mid this.singer = singer this.name = name this.album = album this.duration = duration this.image = image this.url = url &#125; // 类的方法 实例可以直接调用 getLyric() &#123; if (this.lyric) &#123; return Promise.resolve(this.lyric) &#125; &#125;&#125;let songData = new Song(&#123;id: 22, mid:666, singer: 'holly'...&#125;)console.log(songData) // &#123;id: 22, mid: 666, singer: 'holly'...&#125; 15.HTML5 audio音频播放 简单应用 1&lt;audio ref="audio" :src="currentSong.url" @canplay="ready" @error="error" @timeupdate="updateTime"&gt; &lt;/audio&gt; play()方法 开始播放 canplay事件：当浏览器可以开始播放音频/视频时触发。 paly事件： 当音乐开始播放时触发（播放暂停有时因为业务逻辑可能需要将canplay换成play事件，控制切换以及ready触发时保证已经play()） error事件：当在音频/视频加载期间发生错误时触发。 timeupdate事件：在音频/视频（audio/video）的播放位置发生改变时触发。 以下代码实现功能： 当歌曲发生改变的时候播放也就是调用play() 在播放器切换歌曲时可以控制，当前歌曲已经ready时才能切换到下一首 实时获取播放时间 123456789101112131415161718192021222324252627282930313233343536data() &#123; return &#123; // 标识 songReady: false &#125;&#125;，methods: &#123;// 只有该歌曲已经ready时，赋值为true ready() &#123; this.songReady = true &#125;,// 然后在切换的方法里 例如next() 加一个判断就可以了 next() &#123; if(!this.songReady) &#123; return &#125; // 就不执行下面的了 ... // 最后在重置为false this.songReady = false &#125;， // 当资源加载失败时不影响切换操作 error() &#123; this.songReady = true &#125;&#125;，watch: &#123; // 当前歌曲变化时并且已经ready 开始播放 currentSong() &#123; if(!this.songReady) &#123; return &#125; this.$refs.audio.play() this.songReady = true &#125;&#125; 16. Vue的混入 Mixins 的使用 混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。 详见本站另一篇文章✌ 点击传送 Mixins的使用 17.带实时提示的搜索组件的节流 vue中一般是v-model绑定input值然后监听，一旦发生改变就发送请求； 例如我想搜索周杰伦，输入周时请求一次，杰时请求一次，伦时请求一次；或者删除伦时请求一次…. 频繁的发送请求，页面有可能造成卡顿，也增大了服务器的压力； 这个时候需要进行节流优化。 案例 传送门 18.Vue中常用的一些是事件修饰符项目中用到了.stop .prevent .stop 阻止事件冒泡 .prevent 取消浏览器默认行为（例如a标签的默认刷新页面） .capture 使用事件捕获模式 .self 只作用于元素本身，类似于已阻止事件冒泡 .once 只作用一次 修饰符可以串联 例如需要阻止冒泡并且只触发一次 .stop.once 19.打包1npm run build 打包以后的文件如下： 包含static静态资源文件夹 与 html 文件 由于是单页应用程序，进入首页时会加载所有的静态文件。项目比较大时会白屏很久。 这时推荐路由懒加载的模式进行优化，这样打包后会分模块，进入不同路由后加载对应静态资源 详见： 路由懒加载✌ 20.手机上调试推荐使用vConsole 一个由微信团队开发开源的插件 使用方法 点击传送✌]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中的节流控制案例]]></title>
    <url>%2F2018%2F05%2F10%2Fjavascript%E4%B8%AD%E7%9A%84%E8%8A%82%E6%B5%81%E6%8E%A7%E5%88%B6%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[节流控制频繁触发事件或频繁发送请求，避免页面卡顿，请求卡顿，简单来说就是在多次触发时有一个间隔时间，第n次触发事件和第n+1次触发事件之间必须保证间隔时间。 一个带提示的搜索案例（用vue写的）场景(如下图) 需要达到的效果 搜索输入内容时利用节流函数控制在一个指定的周期内才发送请求 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344// 搜索框&lt;template&gt; &lt;div&gt; &lt;input class="box" ref="querySearch" v-model="query" :placeholder="请输入"&gt; &lt;div&gt;提示层 请求返回的数据渲染的 这里我就不具体谢了&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; query: '' &#125; &#125;, watch: &#123; query(newVal) &#123; // 发送请求 //this.search(newVal) // 改为利用节流函数控制 this.throttle(this.search(newVal), 200) // 执行逻辑 当query改变时200ms后发送请求，当200ms内多次触发节流函数，会取消上一次200ms后执行func()的函数，继续新的一次200ms后执行 // 也就是每一次query发生改变都要等到200ms以后发送请求 &#125; &#125;， methods: &#123; //节流函数 第一个参数是要执行的函数 第二个是要延迟的时间 throttle(func, delay) &#123; let timer return function(...args)&#123; // 被执行了 取消执行 // 在delay时间内反复执行return的匿名函数会清除上一次继续延迟delay时间后执行func 达到节流的效果 if(timer) &#123; clearTimeout(timer) &#125; timer = setTimerout(() =&gt; &#123; func.apply(this, args) &#125;, delay) &#125; &#125; &#125; &#125;&lt;/script&gt; 减少请求 一定程度上优化了性能 节约流量 常见的应用场景 Dom元素的拖拽 射击游戏 （单位时间内只发射一颗子弹） 鼠标移动距离 搜索联想（也就是这个案例） 监听滚动事件]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>节流</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中混入的使用（Mixin）]]></title>
    <url>%2F2018%2F04%2F25%2FVue%E4%B8%AD%E6%B7%B7%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88Mixins%EF%BC%89%2F</url>
    <content type="text"><![CDATA[当出现类似组件，功能又有重叠的地方，但又具有比较大的差异时可以使用Mixin，只提取公共的部分。然后混入到多个组件中。（写法与组件非常类似，很容易上手） Mixin的基本用法现在的场景是 多个页面底部有A组件，多个页面内容都可滑动，滑动到最底部时一部分内容被A组件遮挡，（滑动用的scorll组件）这时需要在页面有数据时给scroll一个bottom等于A组件的高度再重新计算scroll scroll组件是利用better-scroll封装的一个组件 详见另一篇 点击传送 多个组件需要写相同逻辑,推荐使用Mixin12345678910111213141516171819202122232425// mixin.jsimport &#123;mapGetters&#125; from 'vuex'export const playlistMixin = &#123; computed: &#123; ...mapGetters(['playlist']) &#125;, mouted() &#123; this.handlePlaylist(this.playlist) &#125;, activated() &#123; this.handlePlaylist(this.playlist) &#125;, watch: &#123; playlist(newVal) &#123; this.handlePlaylist(this.playlist) &#125; &#125;, methods: &#123; // handlePlaylist需要被具体组件实现 当混入的组件中有这个方法时会覆盖mixin中的同名方法 handlePlaylist() &#123; // 没有时 我们手动抛一个error throw new Error ('error') &#125; &#125;&#125; 混入到组件中1234567891011121314151617181920212223// music-list.vue// 引入import &#123;playlistMixin&#125; from './mixin'// mixins属性混入export default &#123; // 可以混入多个 逗号隔开 mixins: [playlistMixin], data() &#123; return &#123; &#125; &#125;， methods: &#123; handlePlaylist(list) &#123; const bottom = list.length &gt; 0 ? '60px' : '' // scroll组件的dom this.$refs.list.$el.style.bottom = bottom // 重新计算高度，最大滑动高度也会被重新计算 达到内容不被A组件遮挡的效果 this.$refs.list.refresh() &#125; &#125;&#125;// 混入到其他页面写法也一样 只是handlePlaylist的方法体根据每个页面不同来写 已经在多个组件写了相同逻辑或功能 也可以提取出来再混入 减少代码量 也方便维护]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>mixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[better-scoll的封装与使用]]></title>
    <url>%2F2018%2F04%2F19%2Fbetter-scoll%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[better-scroll是解决各种滚动场景需求的插件，由于一般移动端项目滚动的场景特别多，所以会对其进行封装复用 Vue中的better-scroll学习及使用better-scroll 中文文档 ✌ 点击传送 首先大概了解一下该插件的滚动原理 父容器有一个固定高度 第一个子元素，高度会随内容进行变化 当内容高度不超过父容器不滚动,超过父容器就可以滚动 重点：better-scroll对外暴露了一个BScroll的类，我们初始化只需要neiw一个实例，第一个参数为父容器的DOM,第二个参数是一些配置。 初始化时会子酸父元素和子元素的高度和宽度，才能决定是否可以滚动，所以初始化时必须确保父元素与子元素已经渲染。否则会出现不可滚动的情况 当子元素或者父元素DOM结果发生变化（通常也就是数据发生变化）需要冲洗调用refresh()方法重新计算高度 写一个基础的scroll组件dom结构很简单 1234567&lt;template&gt; // 父容器 &lt;div ref="wrapper"&gt; // 插槽 &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;script&gt; // 先引入better-scroll improt Bscroll 'better-scroll' export default &#123; // 可接收的值 props: &#123; // 组件的一个属性可以看文档：为0时不派发scroll事件，1时滑动超过一定事件派发scroll事件，2时滑动过程中时时派发scroll事件，3时不仅滑动时时时派发，另一个属性momentum为true开启动画，动画也派发scroll事件 probeType: &#123; type: Number, default: 1 &#125;， click: &#123; type: Boolean, default: true &#125;， // 数据影响滑动，所以需要接收对应数据 data: &#123; type: Array, default: null &#125;， // 监听滚动 listenScroll: &#123; type: Boolean, default: false &#125; mounted() &#123; // 初始化时机 在dom已渲染 setTimeout(() =&gt; &#123; this._initScroll() &#125;, 20) &#125;, methods: &#123; // 初始化方法 _initScroll() &#123; // 防错 避免undefined if(!this.$refs.wrapper) &#123; return &#125; // 第一个参数为父容器dom 第二个参数为一些配置参数 this.scroll = new BScroll(this.$refs.wrapper, &#123; probeType: this.probeType， // 派发scroll的模式 click: this.click &#125;) // 如果有监听listenScroll // 记录Vue实例的this let me = this if(this.listenScroll) &#123; // 监听scroll事件并且派发scroll时间把pos位置传出去 // 触发时机：滚动过程中，具体时机取决于选项中的 probeType // 具体可以查阅官方文档 this.scroll.on('scroll', pos =&gt; &#123; // 这个回调里的this执行better-scroll 所以要记录Vue实例的this // pos是位置 me.$emit('scroll', pos) &#125;) &#125; &#125;, // 以下都是better-scroll的API // 启用 enable() &#123; this.scroll &amp;&amp; this.scroll.enable() &#125;, // 禁用 disable() &#123; this.scroll &amp;&amp; this.scroll.disable() &#125; // 刷新scroll 重新计算 refresh() &#123; this.scroll &amp;&amp; this.scroll.refresh() &#125;， // 滚动到指定位置 参数为x坐标(px)，y坐标(px)，滚动动画时长(ms),缓动函数，默认easing scrollTo() &#123; // apply是为了保证指向Vue实例 // scrollTo的this指向better-scroll this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments) &#125;, // 滚动到目标元素 参数：el滚动到的目标元素，滚动动画时长(ms),offsetX相对目标元素横向偏移量(px)如果直接设为true则中心，offsetY同理，缓动动画 默认easing scrollToElement() &#123; this.scroll &amp;&amp; this.scroll.scrollToElment.apply(this.scroll, arguments) &#125; &#125;， watch: &#123; // 当数据发生变化时重新计算scoll data() &#123; setTimeout(() =&gt; &#123; this.refresh() &#125;, 20) &#125; &#125; &#125; &#125;&lt;/script&gt; 使用上面封装的组件引入scroll组件 并在页面注册 然后在template中使用 test1 12345678910&lt;template&gt; &lt;scroll ref="listWrapper" :data="list"&gt; &lt;div class="content"&gt; &lt;div class="list1" v-for="item1 in list1"&gt; &lt;span&gt;item1&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroll&gt;&lt;/template&gt; 将获取到的list数据传入scroll组件，scroll组件watch到data变化会重新计算高度，这是如果内容超过父容器就可以正常滑动了 test2 123456789101112&lt;template&gt; &lt;scroll ref="listWrapper" :data="list"&gt; &lt;div class="content"&gt; &lt;div class="list1" v-for="item1 in list1"&gt; &lt;span&gt;item1&lt;/span&gt; &lt;/div&gt; &lt;div class="list2" v-for="item2 in list2"&gt; &lt;span&gt;item2&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroll&gt;&lt;/template&gt; 当一个滑动出现两个或两个以上由内容撑开高度异步获取的情况，要确保都获取到数据以后再传data，或者手动调用refresh方法 this.$refs.listWrapper.refresh()重新计算 test3 实现点击右侧字母左侧滑动到对应位置以及滑动右侧左侧滑动到对应位置效果图 首先引入上面封装的scroll组件 并在页面注册 然后在template中使用 左侧数据与右侧数据的索引是对应好的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&lt;template&gt; &lt;scroll @scroll="scroll" :listen-scroll="listenScroll" :probe-type="probeType" :data="data" class="listview" ref="listview"&gt; &lt;--左侧列表--&gt; &lt;ul&gt; &lt;li v-for="group in data" class="list-group" ref="listGroup"&gt; &lt;h2 class="list-group-title"&gt;&#123;&#123;group.title&#125;&#125;&lt;/h2&gt; &lt;uL&gt; &lt;li @click="selectItem(item)" v-for="item in group.items" class="list-group-item"&gt; &lt;img class="avatar" v-lazy="item.avatar"&gt; &lt;span class="name"&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/uL&gt; &lt;/li&gt; &lt;/ul&gt; &lt;--右侧字母--&gt; &lt;div class="list-shortcut" @touchstart.stop.prevent="onShortcutTouchStart" @touchmove.stop.prevent="onShortcutTouchMove" @touchend.stop&gt; &lt;ul&gt; &lt;--左侧滚动右侧实时高亮--&gt; &lt;li v-for="(item, index) in shortcutList" :data-index="index" class="item" :class="&#123;'current':currentIndex===index&#125;"&gt;&#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="list-fixed" ref="fixed" v-show="fixedTitle"&gt; &lt;div class="fixed-title"&gt;&#123;&#123;fixedTitle&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/scroll&gt;&lt;/template&gt; &lt;script type="text/ecmascript-6"&gt; import Scroll from 'src/base/scroll/scroll' // 左侧title高度 根据样式来的 const是为了以后有变化好统一处理 const TITLE_HEIGHT = 30 // 右侧每个li的高度 const ANCHOR_HEIGHT = 18 export default &#123; props: &#123; data: &#123; type: Array, default: [] &#125; &#125;, computed: &#123; shortcutList() &#123; return this.data.map((group) =&gt; &#123; return group.title.substr(0, 1) &#125;) &#125;, fixedTitle() &#123; if (this.scrollY &gt; 0) &#123; return '' &#125; return this.data[this.currentIndex] ? this.data[this.currentIndex].title : '' &#125; &#125;, data() &#123; return &#123; scrollY: -1, currentIndex: 0, diff: -1 &#125; &#125;, created() &#123; this.probeType = 3 this.listenScroll = true this.touch = &#123;&#125; this.listHeight = [] &#125;, methods: &#123; // 设置或获取自定义属性的方法 getData(el, name, val) &#123; const prefix = 'data-' if(val) &#123; //有第三个参数时set return el.setAttribute(prefix + name, val) &#125; else &#123; // 没有第三个参数时get return el.getAttribute(prefix + name) &#125; &#125;, selectItem(item) &#123; this.$emit('select', item) &#125;, // 点击右侧字母时 onShortcutTouchStart(e) &#123; // dom中已经设置了自定义属性 :data-index="index" 直接获取得到索引 let anchorIndex = this.getData(e.target, 'index') // 调用组件滚动到元素的方法 滚动到左侧列表对应的index Dom元素 // 由于比较长 多处会用到可以进行封装 见_scrollTo //this.$refs.listview.scrollToElement(this.$refs.listGroup[anchorIndex]) // 记录第一个touches手指的位置 let firstTouch = e.touches[0] // 记录start的Y值 this.touch.y1 = firstTouch.pageY // 记录index this.touch.anchorIndex = anchorIndex // 左侧列表滑动到指定元素位置 this._scrollTo(anchorIndex) &#125;, // 滑动过程中 列表跟随滚动 需要记录start的Y值计算差 onShortcutTouchMove(e) &#123; // 记录滑动第一个手指位置的Y值 let firstTouch = e.touches[0] this.touch.y2 = firstTouch.pageY // 获得start和move的Y值差 / 右侧每个li的高度（ANCHOR_HEIGHT）| 0 也就是向下取整 // 也就是获得了偏移了几个元素 let delta = (this.touch.y2 - this.touch.y1) / ANCHOR_HEIGHT | 0 // 新的元素位置就是start记录的索引+delta let anchorIndex = parseInt(this.touch.anchorIndex) + delta // 滑动到指定元素位置 this._scrollTo(anchorIndex) &#125;, refresh() &#123; this.$refs.listview.refresh() &#125;, // 记录实时滚动的Y值 scroll(pos) &#123; this.scrollY = pos.y &#125;, // 计算每个左侧列表的高度 _calculateHeight() &#123; this.listHeight = [] const list = this.$refs.listGroup let height = 0 this.listHeight.push(height) for (let i = 0; i &lt; list.length; i++) &#123; let item = list[i] height += item.clientHeight this.listHeight.push(height) &#125; &#125;, _scrollTo(index) &#123; if (!index &amp;&amp; index !== 0) &#123; return &#125; // 点击右侧时 scrollY赋值实现高亮 因为点击时左侧没有派发scroll事件没有更新scrollY // 需要根据逻辑手动给scrollY赋值 if (index &lt; 0) &#123; // 顶部 index = 0 &#125; else if (index &gt; this.listHeight.length - 2) &#123; // 底部 index = this.listHeight.length - 2 &#125; this.scrollY = -this.listHeight[index] // 左侧滚动到指定位置 this.$refs.listview.scrollToElement(this.$refs.listGroup[index], 0) &#125; &#125;, watch: &#123; data() &#123; // data发生改变时 重新计算左侧每个列表高度 setTimeout(() =&gt; &#123; this._calculateHeight() &#125;, 20) &#125;, // 滑动位置发生变化时 scrollY(newY) &#123; // 三种情况 顶部 中间 底部 const listHeight = this.listHeight // 当滚动到顶部，newY&gt;0 if (newY &gt; 0) &#123; this.currentIndex = 0 return &#125; // 在中间部分滚动 for (let i = 0; i &lt; listHeight.length - 1; i++) &#123; let height1 = listHeight[i] let height2 = listHeight[i + 1] // 两个元素之间 if (-newY &gt;= height1 &amp;&amp; -newY &lt; height2) &#123; this.currentIndex = i this.diff = height2 + newY return &#125; &#125; // 当滚动到底部，且-newY大于最后一个元素的上限 // 2的原因是 listHeight在创建时比元素多一个 并且底部以元素的上线位置为准 this.currentIndex = listHeight.length - 2 &#125;, diff(newVal) &#123; let fixedTop = (newVal &gt; 0 &amp;&amp; newVal &lt; TITLE_HEIGHT) ? newVal - TITLE_HEIGHT : 0 if (this.fixedTop === fixedTop) &#123; return &#125; // 当偏移量小于title的高度时才transfrom 其它情况不变依然fix在列表顶部 this.fixedTop = fixedTop this.$refs.fixed.style.transform = `translate3d(0,$&#123;fixedTop&#125;px,0)` &#125; &#125;, components: &#123; Scroll &#125;&lt;/script&gt; 达到左右互相联动的效果 右侧点击左侧滑动到对应元素，右侧滑动，根据偏移比例左侧滑动到对应位置 左侧滑动到某个区间，右侧高亮 顶部固定title，在滑动偏移差小于title高度时,fixed有个过渡效果。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>组件</tag>
        <tag>封装</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex的学习及使用]]></title>
    <url>%2F2018%2F03%2F24%2FVuex%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[解决多个组件的状态共享,解决路由间传递复杂数据,便于维护。 目录结构通常情况下 我们在src下建立一个store文件夹 具体如下图 state.js里是要用到的状态； getters.js是用来映射state里的状态； mutations.js是改变state里状态的一些方法，只能同步操作； mutations-types.js是统一管理mutaions方法名的一个文件（多人协作时方便管理，也可以不用）； actions.js 不直接改变state里的状态，通过commit mutations里的方法进行改变state,并且可以分发多个mutaitons并且可以进行异步操作； index.js 入口文件 例子：例子中用了export,export default 两种不同的导出语法 如果不清楚可以查阅另一篇文章 ✌ 点击进入 javascript的模块化 state.js 1234567891011121314const state = &#123; singer: &#123;&#125;, playing: false, fullScreen: false, playList: [], sequenceList: [], currentIndex: -1, //歌单详细列表 disc: &#123;&#125;, // 排行列表 topList: &#123;&#125;,&#125;export default state getters.js (进行映射state) 123456789101112131415export const singer = state =&gt; state.singerexport const playing = state =&gt; state.playingexport const fullScreen = state =&gt; state.fullScreenexport const playList = state =&gt; state.playListexport const sequenceList = state =&gt; state.sequenceListexport const currentIndex = state =&gt; state.currentIndexexport const disc = state =&gt; state.discexport const topList = state =&gt; state.topList mutations-types.js (统一管理mutations方法名称常量) 123456789101112131415export const SET_SINGER = 'SET_SINGER'export const SET_PLAYING_STATE = 'SET_PLAYING_STATE'export const SET_FULL_SCREEN = 'SET_FULL_SCREEN'export const SET_PLAYLIST = 'SET_PLAYLIST'export const SET_SEQUENCE_LIST = 'SET_SEQUENCE_LIST'export const SET_CURRENT_INDEX = 'SET_CURRENT_INDEX'export const SET_DISC = 'SET_DISC'export const SET_TOP_LIST = 'SET_TOP_LIST' mutations.js (改变state的一些方法) 123456789101112131415161718192021222324252627282930import * as types from './mutations-types' const mutations = &#123; [types.SET_SINGER] (state, singer) &#123; state.singer = singer &#125;, [types.SET_PLAYING_STATE](state, flag) &#123; state.playing = flag &#125;, [types.SET_FULL_SCREEN](state, flag) &#123; state.fullScreen = flag &#125;, [types.SET_PLAYLIST](state, list) &#123; state.playList = list &#125;, [types.SET_SEQUENCE_LIST](state, list) &#123; state.sequenceList = list &#125;, [types.SET_CURRENT_INDEX](state, index) &#123; state.currentIndex = index &#125;, [types.SET_DISC](state, disc) &#123; state.disc = disc &#125;, [types.SET_TOP_LIST](state, topList) &#123; state.topList = topList &#125;&#125;export default mutations actions.js(派发多个mutations或进行异步操作) 在 store 上注册 action。处理函数总是接受 context 作为第一个参数，payload 作为第二个参数（可选）。 context包含以下属性，第二个参数可选（调用时传入的参数） 12345678&#123; state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters // 等同于 `store.getters`，只存在于模块中&#125; 下面用了结构赋值 第一个参数只接收commit,有些场景也需要接收state {commit, state} 12345678import * as types from './mutations-types' // 清空播放列表 export const deleteSongLits = function(&#123;commit&#125;, val) &#123; commit(types.SET_PLAYLIST, []) commit(types.SET_SEQUENCE_LIST, []) commit(types.SET_CURRENT_INDEX, -1) commit(types.SET_PLAYING_STATE, false) &#125; index.js (vuex入口文件) 12345678910111213141516171819202122import Vue from 'vue'import Vuex from 'vuex'import * as actions from './actions'import * as getters from './getters'import state from './state'import mutations from './mutations'// 内置的logger插件 日志插件可以在控制台查看vuex的信息进行调试import createLogger from 'vuex/dist/logger'Vue.use(Vuex)// run dev时 debug为trueconst debug = process.env.NODE_EN !== 'production'export default new Vuex.Store(&#123; actions, getters, state, mutations, // strict 严格模式 true为开启 // 任何 mutation 处理函数以外修改 Vuex state 都会抛出错误 strict: debug, plugins: debug ? [createLogger()] : []&#125;) 在项目的入口文件main.js中将该 Store 实例添加到构造的 Vue 实例中main.js 12345678910111213141516171819202122import Vue from 'vue'import App from './App'import router from './router'import fastclick from 'fastclick'import 'babel-polyfill'import 'common/stylus/index.styl'import VueLazyLoad from 'vue-lazyload'import store from './store' // 引入storeVue.config.productionTip = falsefastclick.attach(document.body)Vue.use(VueLazyLoad, &#123; loading: require('common/image/logo@2x.png')&#125;)/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store,// 添加到Vue实例中 render: h =&gt; h(App)&#125;) 利用辅助函数在组件中获取state,映射getter,提交mutation,分发action1234567891011121314151617181920212223242526272829303132import &#123; mapState, mapMutations, mapActions &#125; from 'vuex'export default &#123; computed: &#123; ...mapState([ // 映射 this.singer 为 store.state.singer 'singer' ]), // 把 `this.playing` 映射为 `this.$store.getters.playing` ...mapGetters(['playing']) &#125;, methods: &#123; ...mapMutations([ 'SET_SINGER', // 将 `this.SET_SINGER()` 映射为 `this.$store.commit('SET_SINGER')` // `mapMutations` 也支持载荷： 'SET_SINGER' // 将 `this.SET_SINGER(amount)` 映射为 `this.$store.commit('SET_SINGER', amount)` ]), ...mapMutations(&#123; setSinger: 'SET_SINGER' // 将 `this.setSinger()` 映射为 `this.$store.commit('SET_SINGER')` &#125;) ...mapActions([ 'deleteSongLits', // 将 `this.deleteSongLits()` 映射为 `this.$store.dispatch('deleteSongLits')` // `mapActions` 也支持载荷： // 'deleteSongLits' // 将 `this.deleteSongLits(amount)` 映射为 `this.$store.dispatch('deleteSongLits', amount)` ]), ...mapActions(&#123; empty: 'deleteSongLits' // 将 `this.empty()` 映射为 `this.$store.dispatch('deleteSongLits')` &#125;) &#125;&#125; vuex的分割模块以vue-element-admin的store为例 ✌ 点击传送 目录结构: index.js 入口文件 getter.js state的映射 modules模块文件夹，里面为一个个vuex模块 以errorLog模块为例 123456789101112131415161718const errorLog = &#123; state: &#123; logs: [] &#125;, mutations: &#123; ADD_ERROR_LOG: (state, log) =&gt; &#123; state.logs.push(log) &#125; &#125;, actions: &#123; addErrorLog(&#123; commit &#125;, log) &#123; commit('ADD_ERROR_LOG', log) &#125; &#125;&#125;export default errorLog// 导出一个对象 有sate, mutations, actions的对象 getter.js state的映射 1234const getters = &#123; errorLogs: state =&gt; state.errorLog.logs&#125;export default getters index.js vuex入口文件 123456789101112131415161718192021222324import Vue from 'vue'import Vuex from 'vuex'import app from './modules/app'import errorLog from './modules/errorLog'import permission from './modules/permission'import tagsView from './modules/tagsView'import user from './modules/user'import getters from './getters'// 加载每一个模块Vue.use(Vuex)const store = new Vuex.Store(&#123; // 注入modules对象中 modules: &#123; app, errorLog, permission, tagsView, user &#125;, getters&#125;)export default store main.js 项目入口文件 12345678910import store from './store' // 加载storenew Vue(&#123; el: '#app', router, store, // 挂在到Vue实例 i18n, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 模块写法只是将state,mutations,actions写到了不同的功能模块中，并且分别加载并挂在到Vuex实例中，多人写作或者功能模块较多的项目推荐这种写法 Vuex数据持久化，结合localStoragevuex刷新后就会消失, 很多应用场景刷新要保留数据 结合本地存储只要不手动清除，就一直存在 思路 最好是写一个js文件,根据业务场景写localStorage的set和get和移除或清空 state里的数据直接获取localStorage存储的数据 mutaions或actions方法里调用js文件中是set get 移除 清空等方法 demo写set get方法的文件 cache.js 1234567891011121314151617181920212223242526272829303132333435import storage from 'good-storage'const SEARCH_KEY = '__search__'const SEARCH_MAX_LENGTH = 15// 保存搜索历史export function saveSearch(query) &#123; // 本地存储数组 let searches = storage.get(SEARCH_KEY, []) // 进行比较后插入 insertArray(searches, query, (item) =&gt; &#123; return item === query &#125;, SEARCH_MAX_LENGTH) // 保存 storage.set(SEARCH_KEY, searches) return searches&#125;export function loadSearch() &#123; return storage.get(SEARCH_KEY, [])&#125;// 删除一个export function deleteSearch(query) &#123; let searches = storage.get(SEARCH_KEY, []) deleteFromArray(searches, (item) =&gt; &#123; return item === query &#125;) storage.set(SEARCH_KEY, searches) return searches&#125;export function clearSearch() &#123; storage.remove(SEARCH_KEY) return []&#125; state.js (获取存储) 12345678import &#123;loadSearch&#125; from 'common/js/cache'const state = &#123; // 搜索历史 searchHistory: loadSearch(),&#125;export default state mutations.js 12345678910import * as types from './mutations-types' const mutations = &#123; [types.SET_SEARCH_HISTORY](state, history) &#123; state.searchHistory = history &#125;&#125;export default mutations actions.js (更新存储) 123456789101112131415import * as types from './mutations-types'import &#123;saveSearch, deleteSearch, clearSearch,&#125; from 'common/js/cache' // 搜索历史相关 export const saveSearchHistory = function(&#123;commit&#125;, query) &#123; commit(types.SET_SEARCH_HISTORY, saveSearch(query)) &#125; export const deleteSearchHistory = function(&#123;commit&#125;, query) &#123; commit(types.SET_SEARCH_HISTORY, deleteSearch(query)) &#125; export const clearSearchHistory = function(&#123;commit&#125;) &#123; commit(types.SET_SEARCH_HISTORY, clearSearch()) &#125; 当派发actions时会做对应的存储操作，state会拿到本地存储的数据]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp的原理和使用]]></title>
    <url>%2F2018%2F03%2F15%2Fjsonp%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[浏览器的同源策略不允许跨域，jsonp是解决跨域的一种方法。但也存在一些缺点，所以跨域最好还是后台进行设置. 原理 利用script标签的src属性不受同源策略影响（协议，端口，域名任何一个不同，同源策略都会禁止跨域） 通过前端方法作为参数传递到服务器，服务器注入参数后再返还，实现服务器向客户通信 只支持get方法 请求过程 请求前：创建一个script标签，并给src赋值 url+callback的方法名，并在window上注册这个方法 发送请求： 将script添加到页面中，浏览器会发起一个请求 数据响应：服务器将返回的数据作为参数和函数名拼接在一起 jsonpCbk({data:”data”})。当浏览器接收到响应数据，由于发起请求的是script，所以相当于直接调用jsonpCbk方法，并且给回调传入了一个参数。 原生js写一个jsonp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// url要请求的地址以及拼接的参数；opts&#123;param: 约定的函数参数，timeout:超时时间，name:指定的函数名，prefix:指定的函数名前缀&#125;；fn回调函数var count = 0function noop()&#123;&#125;function jsonp(url, opts, fn) &#123; // opts 如果是一个函数 赋值给fn 并重置opts为空对象 if('function' == typeof opts)&#123; fn = opts opts = &#123;&#125; &#125; // 如果没有opts 给opts赋值空对象 if(!opts) opts = &#123;&#125; var prefix = opts.prefix || '__jp' // id为opts的name或者prefix+计数（prefix为opts.prefix或__jp） var id = opts.name || (prefix + (count++)) var param = opts.param || 'callback' // 有opts.timeout 就取 没有就是60000ms var timeout = null != opts.timeout ? opts.timeout : 60000 var enc = encodeURIComponent // 第一个script或者head标签 var target = document.getElementsByTagName('script')[0] || document.head var script var timer // 如果有timeout就在timeout之后执行clean并抛出Error if (timeout) &#123; timer = setTimeout(function()&#123; cleanup() if(fn) fn(new Error('Timeout')) &#125;, timeout) &#125; function cleanup() &#123; // 移除创建的script 回调函数置空 清除定时器 if(script.parentNode) script.parentNode.removeChild(script) window[id] = noop if(timer) clearTimeout(timer) &#125; function cancel() &#123; if(window[id]) &#123; cleanup() &#125; &#125; // 全局挂载id window[id] = function(data) &#123; cleanup() // 请求返回后执行回调fn if(fn) fn(data) &#125; url += (~url.indexOf('?') ? '&amp;' : '?') + param + '=' + enc(id); url = url.replace('?&amp;', '?'); // 创建script标签src属性赋值url script = document.createElement('script') script.src = url; // 插入到head或script的前面 target.parentNode.insertBefore(script, target); return cancel; &#125; 以上是参照一个jsonp插件的源码写的 传送门 此方法在调用时需要自己拼接将参数拼接在url后面 opts如果跟后台有约定callback参数名就传{param: 约定参数名} ，没有默认callback]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue首屏优化之路由懒加载]]></title>
    <url>%2F2018%2F03%2F10%2FrouterLazy%2F</url>
    <content type="text"><![CDATA[项目比较大时build后首次加载会有很慢的问题,路由懒加载就是优化加载速度的方法之一 路由懒加载优化首屏加载速度首先贴个官方文档 1. 路由配置如下123456789101112131415161718192021222324252627282930// router 文件夹下的index.js文件import Vue from 'vue'improt VueRouter from 'vue-router'improt Holly from '@/pages/Holly' // 某页面Vue.use(VueRouter)// 非懒加载/* const routes = [ &#123; path: '/', name: 'holly', component: Holly &#125;] */// 懒加载const routes= [ &#123; path: '/', name: 'holly', componet: () =&gt; improt('@/pages/Holly') //其实就相当于按需加载 &#125;] //实例化const router = new VueRouter(&#123; routes&#125;)export default router 这就是将不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应组件。 2. main.js入口文件关于路由的配置1234567improt router from './router' //引入路由配置文件new Vue(&#123; el: '#app', router, // 注入到根实例中 render: h =&gt; h(App)&#125;) 今天把项目做了路由懒加载的优化，首屏快了几秒~ 😄]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用vue-cli初始化项目]]></title>
    <url>%2F2018%2F03%2F09%2Fvue-cli-init-project%2F</url>
    <content type="text"><![CDATA[可以快速初始化vue项目，提供一套本地node测试服务器，集成打包上线方案 利用vue-cli脚手架初始化项目1. 首先电脑需要安装好node和包管理工具 去官网下载node稳定版本 点击传送门 记得下载.msi格式的，可以避免配置环境变量 npm（node安装以后自带npm） 如果想使用cnpm 需要安装一下 12npm install -g cnpm --registry=https://registry.npm.taobao.org// 通常npm下载速度比较慢所以很多人会选择cnpm淘宝镜像 如果想使用yarn 需要安装一下 12npm install -g yarn// 只是命令上与npm和cnpm有些出入要看文档 具体的命令可以查看对应的官方文档 2.接下来是安装一个强大的编译工具 webpack和vue脚手架 我通常用cnpm装 12345678910// 全局安装webpackcnpm install webpack -g// 全局安装vue-clicnpm install vue-cli -g// 检测vue版本 -V大写vue -V// 检测node版本 -v小写node -v// npm 版本npm -v 3. 初始化项目 输入一些命令 12345678910111213141516vue init webpack myProject //myproject 为项目名称// 回车以后会询问几个简单的选项 我们进行填写 一路填写+回车Project name : myproject// 如果不需要更改直接回车就可以了。注意：这里不能使用大写，所以我把名称改成了myprojectProject description: // 项目描述 默认为A Vue.js project,直接回车，不用编写。Author：// 作者 如果你有配置git的作者，他会读取。Install vue-router ? // 是否安装vue的路由插件，我们这里需要安装，所以选择YUse ESLint to lint your code?// 是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n，如果你是大型团队开发，最好是进行配置。setup unit tests with Karma + Mocha? // 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。Setup e2e tests with Nightwatch?// 是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。 4. 下载依赖包及运行项目 cnpm i 包都下载好以后 npm run dev 项目就在本地跑起来了 浏览器中可以直接访问 5.有几个重要的文件,简单的认识一下 package.json scripts: 命令行里执行的命令具体做了什么，与这里一 一对应 例如npm run dev dependencies：生产环境以来的包，对应–save devDependencies: 开发环境中以来的包 对应–save-dev webpack.base.config.js webpack的基本配置文件 entry入口文件 output出口文件 babelrc es6转化为es5的配置 6. 项目打包上线 执行命令 12npm run build// 默认生产dist目录 里面是打包好的静态文件 可以部署到服务器 ​]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝与浅拷贝]]></title>
    <url>%2F2018%2F03%2F02%2FcopyDeep%2F</url>
    <content type="text"><![CDATA[最近工作中一个简单的赋值，引发了一个很奇怪的 bug。所以深拷贝和浅拷贝还是非常有必要弄清楚的。 1.首先看看 js 基本数据类型和引用类型的区别 基本数据类型：String , Number, Boolean, Null, Undefined 存放在栈内存中。直接按值存放，可以直接访问。 引用数据类型：Array, Object, Function 等；存放在堆内存中，变量实际保存是保存在栈中的一个地址，指向堆中具体的位置。从栈中获取地址再从堆内存中取到数据。 2.赋值，拷贝 基本数据类型拷贝的时候，在堆内存中开辟了新的空间，和原来的变量互不相干。不用考虑深拷贝浅拷贝的问题。 引用数据类型在用=号赋值时，实际上是将栈中的地址赋值给新的变量。所以当改变这个新的变量里的数据时，指向的堆中的数据也是会有变化的。（我那个 bug 也就是这个问题） 12345let a = 123let b = aa = 1234console.log(a) // 1234console.log(b) // 123 基本数据类型复制不会发生引用, 栈中会开辟新的空间存放 12345let arr = [1, 2, 3]let arr1 = arrarr[0] = 3console.log(arr) // [3, 2, 3]console.log(arr1) // [3, 2, 3] 引用数据类型复制是将栈中的地址赋值给变量，指向堆中的同一个空间，所以当改变其中一个时，其实是改变堆中的数据，所有指向这个空间的变量都会发生改变。 3.深拷贝和浅拷贝 上面的例子其实就是浅拷贝，引用类型的数据复制的是指向地址。 深拷贝，堆开辟一个新的空间存放复制的对象。 引用类型的浅拷贝会出现很多问题，那么下面来看看引用类型如何实现深拷贝。 4.实现深拷贝的方法 我最常用的一个是（简单粗暴）序列化反序列化法 1JSON.parse(JSON.stringify(obj)) 但这个方法存在一些问题 ： 无法复制正则表达式类型、函数类型 无论构造器是什么都会变成 Object undefined 无法复制 只能深拷贝对象和数组其他类型会失真 但实际开发中只是复制数据是够用的 迭代递归法 对对象进行迭代操作，对它的每个值进行递归深拷贝 1234567891011121314151617181920212223242526272829function deepClone(obj) &#123; let copy if (null == obj || 'object' != typeof obj) return obj // Date if (obj instanceof Date) &#123; copy = new Date() copy.setTime(obj.getTime()) return copy &#125; // Array if (obj instanceof Array) &#123; copy = [] for (var i = 0; i &lt; obj.length; i++) &#123; copy[i] = clone(obj[i]) &#125; return copy &#125; // Object if (obj instanceof Object) &#123; copy = &#123;&#125; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; copy[key] = clone(obj[key]) &#125; &#125; return copy &#125; throw new Error('error')&#125; Object.assign() ES6 的深拷贝方法 concat 对数组进行深拷贝 应该还有很多方法 或者更深入的思考 关于可枚举不可枚举这些概念我还不太清楚 有待进步]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>每日一坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ios系统与Date的Bug]]></title>
    <url>%2F2018%2F03%2F01%2FmoveIos-1%2F</url>
    <content type="text"><![CDATA[解决办法 （转化为/分隔的就可以） ios系统 Date.parse()获取时间戳时 ios系统只认得/分隔的时间 其它-分隔或者别的 ios获取的都是NaN123var resData = '2017-3-14 10:03:45'; resData=resData..replace(/-/g, '/'); console.log("返回时间：" + resData)]]></content>
      <categories>
        <category>每日一坑</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>移动</tag>
        <tag>踩坑记</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑Vue项目时服务突然停止(Node内存溢出)]]></title>
    <url>%2F2018%2F02%2F03%2FnodeFull%2F</url>
    <content type="text"><![CDATA[先描述下现象：vue项目在跑时偶尔出现webpack-dev-server服务停止,需要重新npm run dev. 1FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory 报错信息说堆内存溢出（其实就是node内存溢出） 解决办法： 如果是run dev时报错,在package.json文件里的scripts字段的 ‘dev’ : node 后面加上 –max_old_space_size=4096 这里的4096单位是M也就是4G（具体的大小根据实际情况而定） 如果是在打包时 就在build后面加上面的内容 原因 首先项目在跑时其实用的是用的webpack-dev-server工具，是一个小型的Node.js Express 服务器。 webpack在每次代码更改保存时都会进行编译然后实刷新页面得到最新的效果，但同时也会占用大量内存，也就是占用node内存。 node是基于V8构建的，V8对内存的使用是有限制的（老64位系统约1.4G，32位约0.7G，新生代内存64位约32M，32系统下约为16M）在这种限制下，如果不小心触碰到这个界限，就会造成进程退出。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>每日一坑</tag>
        <tag>Node</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的bus组件通信时多次触发的问题]]></title>
    <url>%2F2018%2F01%2F07%2FbusVue%2F</url>
    <content type="text"><![CDATA[解决办法 在组件中 beforeDestory周期 bus.$off(“emit的事件名”) 手动销毁事 Vue利用bus进行组件通信时，因为bus是全局的不受页面生命周期控制，所以会发生多次触发的问题。多个页面都用到同一个组件而组件又用到了bus，那么这个组件通过bus emit了多少次这个页面在on时就会触发多少次。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>组件通信</tag>
        <tag>bus</tag>
        <tag>每日一坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题梳理]]></title>
    <url>%2F2016%2F01%2F02%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[准备面试，个人梳理，比较乱； 如何实现图片懒加载 利用自定义属性data-imageUrl先存放图片地址，监听外层盒子滚动事件，遍历检测图片位置，若在可视区内，将data-imageUrl赋值给src显示图片； 可视区内： 方法1 const bound = el.getBoundingClientRect() 返回一个位置对象 const clientHeight = window.innerHeight 可视区高度 bound.top &lt;= clientHeight + 50 时在可视区内 （50是为了提前加载图片） 方法2 通过document.documentElement.clientHeight获取屏幕可视窗口高度 通过element.offsetTop获取元素相对于文档顶部的距离 通过document.documentElement.scrollTop获取浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离 2-3 &gt;0则在可视区内 ​ 优化： 滚动时不断遍历和赋值src，损耗性能，可以利用节流函数，在用户滚动某一个时间后才遍历和赋值。（效果看起来就像是用户停止滚动时加载图片） 设一个标识记录已加载图片的index，当滚动时就不遍历所有图片了。 前端性能优化 对高频触发的事件进行节流或消抖(debounce 和throttle 这两个函数),scroll事件及tochmove等高频事件； css避免使用通配符*（它会匹配所有元素） js放底部css放顶部（js会阻塞页面解析，css会阻塞页面呈现和js执行），但如今使用webpack等工具基本上不用考虑这种影响； 首屏: 减少网络请求次数，减小文件体积使用cdn加速（gulp、webpack、grunt等构件工具压缩合并） 以上参考链接：https://mp.weixin.qq.com/s/qglFD2nHFqFBivb8T23Qtg 浏览器缓存：服务器响应的header 信息 缓存策略 获取资源形式 状态码 发送请求到服务器 强缓存 从缓存取 200（from memory cache） 否，直接从缓存取 协商缓存 从缓存取 304（not modified） 是，通过服务器来告知缓存是否可用 Service worker 可以解决目前离线应用的问题，同时也可以做更多的事。 Service Worker 可以使你的应用先访问本地缓存资源，所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能（一般称之为 Offline First）。这是原生APP 本来就支持的功能，这也是相比于 web app ，原生 app 更受青睐的主要原因。 参考链接：https://juejin.im/post/5b0bff30f265da08f76cc6f0 如果需要动态改变css样式 尽量使用改变className 只触发一次reflow 慎用全局变量 全局变量需要搜索更长的作用域链。 全局变量的生命周期比局部变量长，不利于内存释放。 类型转换隐式转换要比api转换效率高 使用事件代理（事件委托）：当要对多个元素绑定事件时可以加将事件绑定到父元素然后通过判断e.target.nodeName执行 1234567891011121314151617&lt;ul id="parent-list"&gt; &lt;li id="post-1"&gt;Item 1 &lt;li id="post-2"&gt;Item 2 &lt;li id="post-3"&gt;Item 3 &lt;li id="post-4"&gt;Item 4 &lt;li id="post-5"&gt;Item 5 &lt;li id="post-6"&gt;Item 6 &lt;/li&gt;&lt;/ul&gt; // Get the element, add a click listener... document.getElementById("parent-list").addEventListener("click",function(e) &#123; // e.target is the clicked element! // If it was a list item if(e.target &amp;&amp; e.target.nodeName == "LI") &#123; // List item found! Output the ID! console.log("List item ",e.target.id.replace("post-")," was clicked!"); &#125; &#125;); 以上参考链接: https://segmentfault.com/a/1190000003646305 延迟加载 非首屏使用的数据样式脚本图片等，用户交互时才显示。（例如vue的路由懒加载） 减少iframe的使用:阻塞页面，缺乏语义； 首选get请求 post有两步先发送header再发送数据，而get只有一个步骤，tcp数据包发送数据； 减少cookie大小，cookie通过http投在服务器和浏览器间来回传送，减小可降低响应速度。 使用 DocumentFragment 暂存 DOM，整理好以后再插入 DOM 树 以上参考链接： https://csspod.com/frontend-performance-best-practices/ 什么是虚拟 DOM,为什么说虚拟dom比真实dom快 我的理解是 Virtual DOM也就是虚拟dom,其实是js对象模拟的dom树 js操作数据比真实dom要快很多 处理完以后再渲染成真实dom 谈一下你对 MVVM 的认识 首先说一下mvm：将软件分为三部分 视图（view）: 用户界面 控制器（controller）: 业务逻辑 模型（model）: 数据保存 他们之间的通信，view传达指令给controller，controller完成业务逻辑要求Model改变状态，Model将新的数据发送到view，用户得到反馈。单向 MVVM 模式将controller改名为viewModel 区别就是它采用双向数据绑定，view的变动自动反映在viewModel上，反之亦然 viewModel负责把model的数据同步到view显示出来，还负责把view的修改同步会model 写一个函数把url参数以键值对的方式放到一个对象里 1234567891011121314151617181920212223242526 let url = 'https://www.baid.com/s?edw=ddds&amp;ksjn54=546&amp;sdcnsl=5465&amp;cs=54'// 字符串切割处理 function params(url) &#123; if(url.indexOf('?') &lt; 0 ) return let arr = url.split('?') let arrL = arr[1].split('&amp;') let obj = &#123;&#125; for(let i=0;i&lt;arrL.length;i++)&#123; let cur = arrL[i].split('=') obj[cur[0]] = cur[1] &#125; return obj &#125; console.log(params(url)) // &#123;edw: "ddds", ksjn54: "546", sdcnsl: "5465", cs: "54"&#125;// 正则function paramsA(url)&#123; let reg = /([^&amp;?=]+)=([^&amp;?=]+)/g let obj = &#123;&#125; url.replace(reg, function()&#123; console.log(arguments) obj[arguments[1]] = arguments[2] &#125;) return obj&#125; 数组去重 12345678910111213141516171819202122// 利用indexOf返回第一个符合要求的index [256, 22, '11', 33, 22, 66, '11', '11'].filter((v, i, array) =&gt; &#123; return array.indexOf(v) === i&#125;) // [256, 22, "11", 33, 66]// 利用Set的唯一性let arr = [1,3,2,1,'1',3]let setArr = [...new Set(arr)] // [1, 3, 2, "1"]// 利用对象属性唯一 let arr = [256, 22, 33, 22, 66, '11', '11'] function arrS(arr) &#123; let obj = &#123;&#125; let result = [] for(let i=0;i&lt;arr.length ;i++)&#123; if(!obj[arr[i]]) &#123; obj[arr[i]] = i result.push(arr[i]) &#125; &#125; return result &#125; arrS(arr) // [256, 22, 33, 66, "11"] 取数组中最大值 1234567891011121314151617181920let arr = [1321,515,6,565,151,-85,55]// 扩展运算符Math.max(...arr)// applyMath.max.apply(null, arr)// for循环 每次循环取出较大的一个和后面一个对比 循环结束最终就是最大的let max = arr[0]for(let i = 0; i &lt; arr.length; i++) &#123; max = max &lt; arr[i+1] ? arr[i+1] : max&#125;// sort 降序排序取第一个arr.sort((num1, num2)) &#123; return num2 - num1&#125;arr[0]// reducearr.reduce((num1, num2) =&gt; &#123; return num1 &gt; num2 ? num1 : num2&#125;)// 这个方法类似于上面的for循环 不断对比返回较大的值 闭包的作用，优缺点 形成私有作用域保护私有变量不受外界干扰； 形成不销毁的栈内存，保存起来；（jq） 缺点：耗内存 数组的快速排序 定义一个中间基准比他小的在左边比他大的在右边直到只有一个停止递归 123456789101112131415161718let quickSort = function(arr)&#123; if(arr.length &lt;= 1) &#123;return arr&#125; let pivotIndex = Math.floor(arr.length / 2) // 定义一个基准 数组中间的那个数 var pivot = arr.splice(pivotIndex, 1)[0] var left = [] var right = [] // 循环数组 小于基准的放left 大于等于基准的放right for(let i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; pivot) &#123; left.push(arr[i]) &#125; else &#123; right.push(arr[i]) &#125; &#125; // 递归这个过程 return quickSort(left).concat([pivot], quickSort(right))&#125; 冒泡排序 比较两个相邻的大小如果第一个比第二个大就交换 12345678910111213function bubbleSort(arr)&#123; let len = arr.length for(let i = 0; i&lt; len; i++) &#123; for(let j = 0; j &lt; len -1 -i; j++) &#123; if(arr[j] &gt; arr[j+1])&#123; let temp = arr[j+1] arr[j+1] = arr[j] arr[j] = temp &#125; &#125; &#125; return arr&#125; 三栏布局 左右300px高固定中间自适应 浮动：左右各左右浮动宽度300px； 定位：外层容器相对定位，左中右绝对定位，左left0top0,中left300right300右right0top0; flex布局：外层容器display:flex；左右给width:300px;中flex:1;自适应 table布局：外层容器display:table;width：100%；height固定，左中右display:table-cell;左右宽度固定； grid布局(网格)；外层容器display:grid;witdth:100%;grid-template-rows:100px;gridtemplate-cloums:300px auto 300px; CSS盒模型 基本概念：标准模型+IE模型 标准模型的宽高就是content的宽高 IE模型宽高包含padding和border 设置两种模型 box-sizing: content-box;标准模型，浏览器默认 box-sizing:border-box;IE模型 获取盒模型对应的宽和高 dom.style.width/height只能取到内联样式 dom.currentStyle.width/heigt 最终渲染后的宽高（仅支持IE） window.getComputedStyle(dom).width/height 最终渲染后的宽高（通用性更好一些） dom.getBoundingClientRect().width/height 最终渲染的宽和高 BFC 边距重叠解决方案 基本概念：块级格式化上下文； 原理（渲染规则） BFC元素垂直方向边距会重叠 BFC的区域不会与浮动元素的box重叠（清除浮动） BFC在页面上是独立的容器不会与外面的元素互相影响 计算BFC高度时浮动元素也会参与计算 如何创建BFC overflow的值不为”visible float不为none; position值不为static 或 relative; display:table-cell”, “table-caption”, or “inline-block”中的任何一个; 解决边距问题 清除浮动对页面的影响 解决父元素没有被脱离标准流的子元素撑高为0 DOM事件相关 DOM事件类-事件级别 DOM0 element.onclick = function(){} DOM2 element.addEventListener(‘click’,function(){},false) DOM3 element.addEventListener(‘keyup’,function(){},false) 事件模型 冒泡 捕获 事件流 事件通过捕获到达目标元素，目标元素再上传到window 事件捕获具体流程 window=&gt;document=&gt;html=&gt;body=&gt;…=&gt;目标元素 Event对象的常见应用 event.preventDefault() 阻止默认行为 event.stopPropagation() 阻止冒泡 event.stoplmmediatePropagation() 事件优先级 event.currentTarget 当前绑定事件的元素 event.target 当前被点击的元素 自定义事件 12345var eve = new Event('custome')ev.addEventListener('custome',function()&#123; console.log('custome')&#125;)ev.dispatchEvent(eve) HTTP协议 http协议的主要特点：简单快速，灵活，无连接，无状态； 报文组成部分 请求报文：请求行（http方法，http协议，页面地址），请求头（key-value格式），空行（服务器区分请求头和请求体），请求体； 状态行，响应头，空行，响应体； http方法 GET 获取资源 POST 传输资源 PUT 更新资源 DELETE 删除资源 HEAD 获得报文首部 GET和POST的区别 GET请求在URL传递参数是有长度限制的，post没有 GET只接收ASCII字符而POST没有限制 GET请求通过URL传递参数POST放在Request body中 相对来说GET更不安全一些，不能传递敏感信息 GET请求浏览器主动缓存，POST不会 状态码 1XX ：指示信息-表示请求已接收，继续处理 2XX：成功-表示请求已被成功接收 3XX：重定向-要完成请求必须进行更进一步操作 4XX：客户端错误-请求有语法错误或请求无法实现 5XX：服务器错误-服务器未能实现合法的请求 常见的状态码：200 客户端请求成功，206客户发送了一个带有Range头的get请求，服务器完成了他，301所有请求的页面已经转移至新的url,302所请求页面已经临时转移新url304 客户端有缓存的文档并发出了一个条件性请求，服务器告诉客户端，原来缓存的文档还可以继续使用。400 客户端请求语法错误不能被服务器理解；401请求未经授权 403访问被禁止404请求不资源不存在500服务器发生不可预期错误503请求未完成服务器临时过载或当机一段时间后可能恢复 ​ 持久连接 keep-alive http版本1.1支持 非keep-alive模式，每个请求/应答客户和服务器都要新建立一个连接，完成之后立即断开连接（http协议为无连接的协议） 使用keep-alive模式时，keep-Alive功能使客户端到服务器端连接持续有效，当出现服务器的后续请求时，keep-alive功能避免了建立或者重新建立连接。 创建对象的几种方法 123456789101112// 字面量let obj = &#123;a:1&#125;// new运算符let obj1 = new Object(&#123;b:2)// 构造函数let Fn = function(num) &#123; this.c = num&#125;let CC = new Fn(3)// Object.createlet DD = &#123;d: 4&#125;let D4 = Object.create(DD) 原型、构造函数、实例 实例通过new构造函数创建 构造函数有prototype属性指向原型对象 原型对象constructor指向构造函数（构造器） 构造函数.prototype.constructor === 构造函数 实例.__proto_指向原型对象]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
