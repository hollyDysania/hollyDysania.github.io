<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javascript的模块化]]></title>
    <url>%2F2018%2F05%2F24%2Fjavascript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[由于现在的网页可以看作是一个功能丰富的应用，需要对代码进行分割、作用域隔离、模块之间的依赖管理以及发布到生产环境时的自动化打包与处理等。 ES6模块（Module）模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 export 与 import12345678910111213141516171819202122232425262728// test.jsexport const testName = 'Cindy'export const testAge = '15'// export 对外输出两个变量---------------------------------// 也可以这样写const testName = 'Cindy'const testAge = '15'export &#123;testName, testAge&#125;// 等价于上面那种写法，不过这样更清晰，底部可以看出对外输出了哪些变量---------------------------------// 也可以输出函数和类（class）export function fn(x, y) &#123; return x + y&#125;// 对外输出一个函数 fn===================================// 与其对应的加载这个模块 import (import是只读的)// testImport.jsimport &#123;testName, testAge，fn&#125; from './test.js'-----------------------------------// 如果加载时想换一个变量名 可以用as关键字import &#123;testName as firstName, testAge as egg&#125; from './test.js'-----------------------------------// 可以使用 * 指定一个对象，整体加载import * as test from './test.js'console.log(test.testName)test.fn(1, 2) export 不能直接 export 具体的数据或变量 ，变量声明语句或者{包裹的数据或变量} export输出的内容import时要对应名字，或者用as改变名字 export default 与 import12345678910// default.jsexport default function () &#123; console.log('foo');&#125;// 默认输出一个匿名函数// import命令可以为该函数指定任意名字import toName from './default'toName() // 'foo'// 即便不是匿名函数 import时也可以指定任意名字 因为export default只能使用一次 输出一个叫做default的变量或方法// export default 后面不能跟变量声明语句 export default 只能使用一次,默认输出一个叫做default的变量或方法，所以import时可以取任意名字 export default 后面不能跟变量声明语句，只能是变量名 其他的模块化方案 CommonJS基于Node.js （require(), module.exports） AMD 由RequireJS提出的，CMD 由 SeaJS提出的,两种用法基本相似（define）]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue音乐demo总结]]></title>
    <url>%2F2018%2F05%2F17%2Fvue%E9%9F%B3%E4%B9%90demo%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[很敬佩黄轶老师，涵盖了非常多的知识点。跟着敲还是需要一些vue基础的。 关于Vue开发音乐app的项目总结 我把它部署到了自己的服务器 可以扫码查看 左上角也可以下载我打包好的app ╮(╯▽╰)╭由于我没有备案 直接用的服务器ip 所以微信扫码请点击查看原网页,微信扫码请点击查看原网页, 微信扫码请点击查看原网页。重要的事情说三遍 1.利用vue-cli 初始化项目 请查看本站另一篇文章 ✌点击传送门 2.meta标签的移动端的自适应在index.js的head标签内写name为viewport的meta标签1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0, maximum-scale=1.0,minimum-scale=1.0, user-scalable=no"&gt; 了解一下viewport及相关属性设置 属性 值 width 设置layout viewport 的宽度，为一个正整数，或字符串”width-device”设备宽度 initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 height 设置layout viewport 的高度，这个属性并不重要，很少使用 user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许 根据上面这个表格不难看出：width为设备宽度，初始缩放为1，最大及最小缩放都为1，不允许缩放 3.添加依赖 babel-runtime和babel-polyfill实现ES6转ES5babel默认只换新的javascript语法，不转换新的api，所以要安装babel-polyfill，但是会污染全局变量 为了不污染全局变量和内置对象原型，又想使用ES6新语法和api就需要配合使用babel-runtime,可以避免重复代码 12cnpm i babel-runtime --savecnpm i babel-polyfill --save-dev 然后需要在入口文件main.js中 1imprort 'bable-polyfill' 4.引入fastclick解决移动端300ms点击延迟的问题1cnpm i fastclick --save fastclick的实现原理是在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后的click事件阻止掉。 然后在入口文件引入 12import fastclick from 'fatclick'fastclick.attach(document.body) 5.webpack.base.conf.js中可以配置别名1234567resolve: &#123; extensions: ['.js', '.vue', '.json'], alias: &#123; '@': resolve('src'), 'common': resolve('src/common') &#125;&#125; 这样页面import某个在src/common下的对象时可以直接写 import music from &#39;common/music&#39; 6.路由文件的配置1234567891011121314151617181920212223242526272829303132// 在router文件夹内的index.jsimport Vue from 'vue'import Router from 'vue-router'// 以上是脚手架搭建项目已经写好的// 假如现在有三个页面 先导入import Test1 from 'src/components/test1'import Test2 from 'src/components/test2'import Test3 from 'src/components/test3'Vue.use(Router)export default new Router(&#123; routes:[ &#123; path: '/', redirect: '/test1' // 重定向path'/test1' &#125;, &#123; path: '/test1', component: Test1 &#125;, &#123; path: '/test2', component: Test2 &#125;, &#123; path: '/test3', component: Test3 &#125; ]&#125;) 完成了基本的路由配置 App.vue里的router-view就会渲染对应path的component 最好是使用路由按需加载，请查看本站另一篇文章✌ 点击传送 7.router-link的使用12345&lt;router-link tag="div" class="tab-item" to="/test1"&gt; &lt;span class="tab-link"&gt;测试&lt;/span&gt;&lt;/router-link&gt;// tag是渲染的标签 to对应点击以后的path// router会默认有一个class router-link-active 可以覆盖自定义样式 8.子组件引入和使用的规范引入使用首字母大写加驼峰 使用小写 - 连接 12345// 父组件 test2中引入test1improt TestOne from 'components/test1'// template中使用时&lt;test-one&gt;&lt;/test-one&gt;// 尽量语义化 我这里随意写的就没有语义化... 9.jsonp的原理和使用 原理请查看本站另一篇文章✌点击传送 项目中引入了jsonp插件 1cnpm i jsonp --save 因多处会使用到jsonp对它进行一层封装 12345678910111213141516171819202122232425import originJSONP from 'jsonp'export default function jsonp(url, data, option) &#123;// url与处理后的data拼接 url += (url.indexOf('?') &lt; 0 ? '?' : '&amp;') + param(data) // 返回一个promise return new Promise((resolve, reject) =&gt; &#123; originJSONP(url, option, (err, data) =&gt; &#123; // 插件默认返回第一个参数为null第二个参数为数据 所以会接收两个参数 if (!err) &#123; resolve(data) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125;// 对data数据进行处理function param(data) &#123; let url = "" for (var k in data) &#123; let value = data[k] !== undefined ? data[k] : '' url += `&amp;$&#123;k&#125;=$&#123;encodeURIComponent(value)&#125;` &#125; return url ? url.substring(1) : ''&#125; 因为使用promise封装了 所以调用时要用到.then 12import jsonp from 'common/js/jsonp'jsonp(url, data, option).then((res) =&gt; &#123;console.log(res)&#125;) 那么问题来了 ↓ 10.为什么要使用promise对jsonp进行封装试想一种应用场景（回调地狱）A通过jsonp请求获取，B拿到A返回的数据作为参数通过jsonp请求获取，C拿到B返回的数据作为参数通过jsonp请求获取 我们的做法一般都是，执行jsonp({Aparams})并在A回调里拿到B需要的参数并且执行jsonp({Bparams})然后在B的回调里拿到C需要的参数并且执行jsonp({Cparams}) 一两层回调的嵌套其实也觉得还好，但如果业务逻辑复杂需要嵌套100层呢？这样就非常不便于阅读和维护，也就是常听到的“回调地狱” 以上promise封装是怎么做到解决回调地狱的呢？还是上面那个应用场景，我们用以上封装的jsonp怎么使用呢 jsonp({Aparams}).then(jsonp({Bparams})).then({jsonp(Cparams)})即可 当第一个jsonp执行后返回一个promise对象，promise对象状态发生改变就会触发then并且可以拿到A的resolve传递出去的数据,再执行第二个jsonp返回一个promise对象，让promise对象状态发生变化时触发then可以拿到B的resolve传递出去的数据再执行第三个jsonp，依次类推，非常清晰。 当然业务上其实有reject的情况，这时会执行.catch( // 进行错误处理) 那么问题来了，什么是promise状态发生改变时 promise的三种状态 pending(进行中)； fulfilled(已成功)； rejected(已失败)。 状态改变 当执行resolve时,promise对象的状态会从pending 变为 fulfilled； 当执行reject时,promise对象的状态会从pending 变为 rejected; 当然ajax也可以结合promise封装，axios已经结合了promise可以直接使用 11.better-scroll的使用 由于项目很多地方都需要滑动，所以我们对better-scroll进行封装 详见本站另一篇文章✌ 点击传送 12.图片懒加载: Vue-Lazyload 非常好用的一个优化插件 官方文档✌ 点击传送 使用步骤1.npm 安装 1cnpm install vue-lazyload --save 2.main.js中use 1234567import VueLazyLoad from 'vue-lazyload'Vue.use(VueLazyLoad, &#123; // loading图片 loading: require('本地图片路径')&#125;)// 页面中使用 只需要用v-lazy指令替换src就可以了// scr="imgUrl" =&gt; v-lazy="imgUrl" 更多属性请看官方文档，超超超好用 13.vuex的使用vuex帮助我们管理共享状态,多个没有什么关联性的组件想要共享状态可以通过vuex 详见本站另一篇文章 ✌ vuex的学习及使用 14.ES6 class类的基本使用 ES5中生成实例对象的方法–构造函数 12345678function Holly(x, y) &#123; this.x = x this.y = y&#125;Holly.protitype.connect = function() &#123; return (this.x + ',' + this.y )&#125;var hollyTree = new Holly('www.hollytree', '.top') ES6 中引入class这个概念,针对上面改写 123456789101112// 定义一个Holly的类class Holly &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; // 方法直接定义 不需要function关键字 也不需要逗号 connect() &#123; return (this.x + ',' + this.y ) &#125;&#125;var hollyTree = new Holly('www.hollytree', '.top') Holly类里有一个cunstructor方法，这就是构造方法this指向实例。 也就是说ES5中的构造函数Holly对应ES6中Holly类的构造方法 ES6的类可以看做构造函数的另一种写法，typeof 类 返回 ‘function’,数据类型为函数，类本身指向构造函数； 类所有的方法都定义在类的prototype（原型）上； 原型对象的constructor属性直接指向类本身与ES5一致 由于项目中多处用到歌曲的数据，并且数据需求的格式基本一样，所以这里选择用类来创建song实例12345678910111213141516171819202122// song.js// 定义一个Song类，类的构造函数接收一些参数并指向实例export default class Song &#123; constructor(&#123; id, mid, singer, name, album, duration, image, url &#125;) &#123; this.id = id this.mid = mid this.singer = singer this.name = name this.album = album this.duration = duration this.image = image this.url = url &#125; // 类的方法 实例可以直接调用 getLyric() &#123; if (this.lyric) &#123; return Promise.resolve(this.lyric) &#125; &#125;&#125;let songData = new Song(&#123;id: 22, mid:666, singer: 'holly'...&#125;)console.log(songData) // &#123;id: 22, mid: 666, singer: 'holly'...&#125; 15.HTML5 audio音频播放 简单应用 1&lt;audio ref="audio" :src="currentSong.url" @canplay="ready" @error="error" @timeupdate="updateTime"&gt; &lt;/audio&gt; play()方法 开始播放 canplay事件：当浏览器可以开始播放音频/视频时触发。 paly事件： 当音乐开始播放时触发（播放暂停有时因为业务逻辑可能需要将canplay换成play事件，控制切换以及ready触发时保证已经play()） error事件：当在音频/视频加载期间发生错误时触发。 timeupdate事件：在音频/视频（audio/video）的播放位置发生改变时触发。 以下代码实现功能： 当歌曲发生改变的时候播放也就是调用play() 在播放器切换歌曲时可以控制，当前歌曲已经ready时才能切换到下一首 实时获取播放时间 123456789101112131415161718192021222324252627282930313233343536data() &#123; return &#123; // 标识 songReady: false &#125;&#125;，methods: &#123;// 只有该歌曲已经ready时，赋值为true ready() &#123; this.songReady = true &#125;,// 然后在切换的方法里 例如next() 加一个判断就可以了 next() &#123; if(!this.songReady) &#123; return &#125; // 就不执行下面的了 ... // 最后在重置为false this.songReady = false &#125;， // 当资源加载失败时不影响切换操作 error() &#123; this.songReady = true &#125;&#125;，watch: &#123; // 当前歌曲变化时并且已经ready 开始播放 currentSong() &#123; if(!this.songReady) &#123; return &#125; this.$refs.audio.play() this.songReady = true &#125;&#125; 16. Vue的混入 Mixins 的使用 混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。 详见本站另一篇文章✌ 点击传送 Mixins的使用]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中混入的使用（Mixin）]]></title>
    <url>%2F2018%2F04%2F25%2FVue%E4%B8%AD%E6%B7%B7%E5%85%A5%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88Mixins%EF%BC%89%2F</url>
    <content type="text"><![CDATA[当出现类似组件，功能又有重叠的地方，但又具有比较大的差异时可以使用Mixin，只提取公共的部分。然后混入到多个组件中。（写法与组件非常类似，很容易上手） Mixin的基本用法现在的场景是 多个页面底部有A组件，多个页面内容都可滑动，滑动到最底部时一部分内容被A组件遮挡，（滑动用的scorll组件）这时需要在页面有数据时给scroll一个bottom等于A组件的高度再重新计算scroll scroll组件是利用better-scroll封装的一个组件 详见另一篇 点击传送 多个组件需要写相同逻辑,推荐使用Mixin12345678910111213141516171819202122232425// mixin.jsimport &#123;mapGetters&#125; from 'vuex'export const playlistMixin = &#123; computed: &#123; ...mapGetters(['playlist']) &#125;, mouted() &#123; this.handlePlaylist(this.playlist) &#125;, activated() &#123; this.handlePlaylist(this.playlist) &#125;, watch: &#123; playlist(newVal) &#123; this.handlePlaylist(this.playlist) &#125; &#125;, methods: &#123; // handlePlaylist需要被具体组件实现 当混入的组件中有这个方法时会覆盖mixin中的同名方法 handlePlaylist() &#123; // 没有时 我们手动抛一个error throw new Error ('error') &#125; &#125;&#125; 混入到组件中1234567891011121314151617181920212223// music-list.vue// 引入import &#123;playlistMixin&#125; from './mixin'// mixins属性混入export default &#123; // 可以混入多个 逗号隔开 mixins: [playlistMixin], data() &#123; return &#123; &#125; &#125;， methods: &#123; handlePlaylist(list) &#123; const bottom = list.length &gt; 0 ? '60px' : '' // scroll组件的dom this.$refs.list.$el.style.bottom = bottom // 重新计算高度，最大滑动高度也会被重新计算 达到内容不被A组件遮挡的效果 this.$refs.list.refresh() &#125; &#125;&#125;// 混入到其他页面写法也一样 只是handlePlaylist的方法体根据每个页面不同来写 已经在多个组件写了相同逻辑或功能 也可以提取出来再混入 减少代码量 也方便维护]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>mixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[better-scoll的封装与使用]]></title>
    <url>%2F2018%2F04%2F19%2Fbetter-scoll%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[better-scroll是解决各种滚动场景需求的插件，由于一般移动端项目滚动的场景特别多，所以会对其进行封装复用 Vue中的better-scroll学习及使用better-scroll 中文文档 ✌ 点击传送 首先大概了解一下该插件的滚动原理 父容器有一个固定高度 第一个子元素，高度会随内容进行变化 当内容高度不超过父容器不滚动,超过父容器就可以滚动 重点：better-scroll对外暴露了一个BScroll的类，我们初始化只需要neiw一个实例，第一个参数为父容器的DOM,第二个参数是一些配置。 初始化时会子酸父元素和子元素的高度和宽度，才能决定是否可以滚动，所以初始化时必须确保父元素与子元素已经渲染。否则会出现不可滚动的情况 当子元素或者父元素DOM结果发生变化（通常也就是数据发生变化）需要冲洗调用refresh()方法重新计算高度 写一个基础的scroll组件dom结构很简单 1234567&lt;template&gt; // 父容器 &lt;div ref="wrapper"&gt; // 插槽 &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;script&gt; // 先引入better-scroll improt Bscroll 'better-scroll' export default &#123; // 可接收的值 props: &#123; // 组件的一个属性可以看文档：为0时不派发scroll事件，1时滑动超过一定事件派发scroll事件，2时滑动过程中时时派发scroll事件，3时不仅滑动时时时派发，另一个属性momentum为true开启动画，动画也派发scroll事件 probeType: &#123; type: Number, default: 1 &#125;， click: &#123; type: Boolean, default: true &#125;， // 数据影响滑动，所以需要接收对应数据 data: &#123; type: Array, default: null &#125;， // 监听滚动 listenScroll: &#123; type: Boolean, default: false &#125; mounted() &#123; // 初始化时机 在dom已渲染 setTimeout(() =&gt; &#123; this._initScroll() &#125;, 20) &#125;, methods: &#123; // 初始化方法 _initScroll() &#123; // 防错 避免undefined if(!this.$refs.wrapper) &#123; return &#125; // 第一个参数为父容器dom 第二个参数为一些配置参数 this.scroll = new BScroll(this.$refs.wrapper, &#123; probeType: this.probeType， // 派发scroll的模式 click: this.click &#125;) // 如果有监听listenScroll // 记录Vue实例的this let me = this if(this.listenScroll) &#123; // 监听scroll事件并且派发scroll时间把pos位置传出去 // 触发时机：滚动过程中，具体时机取决于选项中的 probeType // 具体可以查阅官方文档 this.scroll.on('scroll', pos =&gt; &#123; // 这个回调里的this执行better-scroll 所以要记录Vue实例的this // pos是位置 me.$emit('scroll', pos) &#125;) &#125; &#125;, // 以下都是better-scroll的API // 启用 enable() &#123; this.scroll &amp;&amp; this.scroll.enable() &#125;, // 禁用 disable() &#123; this.scroll &amp;&amp; this.scroll.disable() &#125; // 刷新scroll 重新计算 refresh() &#123; this.scroll &amp;&amp; this.scroll.refresh() &#125;， // 滚动到指定位置 参数为x坐标(px)，y坐标(px)，滚动动画时长(ms),缓动函数，默认easing scrollTo() &#123; // apply是为了保证指向Vue实例 // scrollTo的this指向better-scroll this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments) &#125;, // 滚动到目标元素 参数：el滚动到的目标元素，滚动动画时长(ms),offsetX相对目标元素横向偏移量(px)如果直接设为true则中心，offsetY同理，缓动动画 默认easing scrollToElement() &#123; this.scroll &amp;&amp; this.scroll.scrollToElment.apply(this.scroll, arguments) &#125; &#125;， watch: &#123; // 当数据发生变化时重新计算scoll data() &#123; setTimeout(() =&gt; &#123; this.refresh() &#125;, 20) &#125; &#125; &#125; &#125;&lt;/script&gt; 使用上面封装的组件引入scroll组件 并在页面注册 然后在template中使用 test1 12345678910&lt;template&gt; &lt;scroll ref="listWrapper" :data="list"&gt; &lt;div class="content"&gt; &lt;div class="list1" v-for="item1 in list1"&gt; &lt;span&gt;item1&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroll&gt;&lt;/template&gt; 将获取到的list数据传入scroll组件，scroll组件watch到data变化会重新计算高度，这是如果内容超过父容器就可以正常滑动了 test2 123456789101112&lt;template&gt; &lt;scroll ref="listWrapper" :data="list"&gt; &lt;div class="content"&gt; &lt;div class="list1" v-for="item1 in list1"&gt; &lt;span&gt;item1&lt;/span&gt; &lt;/div&gt; &lt;div class="list2" v-for="item2 in list2"&gt; &lt;span&gt;item2&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/scroll&gt;&lt;/template&gt; 当一个滑动出现两个或两个以上由内容撑开高度异步获取的情况，要确保都获取到数据以后再传data，或者手动调用refresh方法 this.$refs.listWrapper.refresh()重新计算 test3 实现点击右侧字母左侧滑动到对应位置以及滑动右侧左侧滑动到对应位置效果图 首先引入上面封装的scroll组件 并在页面注册 然后在template中使用 左侧数据与右侧数据的索引是对应好的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&lt;template&gt; &lt;scroll @scroll="scroll" :listen-scroll="listenScroll" :probe-type="probeType" :data="data" class="listview" ref="listview"&gt; &lt;--左侧列表--&gt; &lt;ul&gt; &lt;li v-for="group in data" class="list-group" ref="listGroup"&gt; &lt;h2 class="list-group-title"&gt;&#123;&#123;group.title&#125;&#125;&lt;/h2&gt; &lt;uL&gt; &lt;li @click="selectItem(item)" v-for="item in group.items" class="list-group-item"&gt; &lt;img class="avatar" v-lazy="item.avatar"&gt; &lt;span class="name"&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/uL&gt; &lt;/li&gt; &lt;/ul&gt; &lt;--右侧字母--&gt; &lt;div class="list-shortcut" @touchstart.stop.prevent="onShortcutTouchStart" @touchmove.stop.prevent="onShortcutTouchMove" @touchend.stop&gt; &lt;ul&gt; &lt;--左侧滚动右侧实时高亮--&gt; &lt;li v-for="(item, index) in shortcutList" :data-index="index" class="item" :class="&#123;'current':currentIndex===index&#125;"&gt;&#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="list-fixed" ref="fixed" v-show="fixedTitle"&gt; &lt;div class="fixed-title"&gt;&#123;&#123;fixedTitle&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/scroll&gt;&lt;/template&gt; &lt;script type="text/ecmascript-6"&gt; import Scroll from 'src/base/scroll/scroll' // 左侧title高度 根据样式来的 const是为了以后有变化好统一处理 const TITLE_HEIGHT = 30 // 右侧每个li的高度 const ANCHOR_HEIGHT = 18 export default &#123; props: &#123; data: &#123; type: Array, default: [] &#125; &#125;, computed: &#123; shortcutList() &#123; return this.data.map((group) =&gt; &#123; return group.title.substr(0, 1) &#125;) &#125;, fixedTitle() &#123; if (this.scrollY &gt; 0) &#123; return '' &#125; return this.data[this.currentIndex] ? this.data[this.currentIndex].title : '' &#125; &#125;, data() &#123; return &#123; scrollY: -1, currentIndex: 0, diff: -1 &#125; &#125;, created() &#123; this.probeType = 3 this.listenScroll = true this.touch = &#123;&#125; this.listHeight = [] &#125;, methods: &#123; // 设置或获取自定义属性的方法 getData(el, name, val) &#123; const prefix = 'data-' if(val) &#123; //有第三个参数时set return el.setAttribute(prefix + name, val) &#125; else &#123; // 没有第三个参数时get return el.getAttribute(prefix + name) &#125; &#125;, selectItem(item) &#123; this.$emit('select', item) &#125;, // 点击右侧字母时 onShortcutTouchStart(e) &#123; // dom中已经设置了自定义属性 :data-index="index" 直接获取得到索引 let anchorIndex = this.getData(e.target, 'index') // 调用组件滚动到元素的方法 滚动到左侧列表对应的index Dom元素 // 由于比较长 多处会用到可以进行封装 见_scrollTo //this.$refs.listview.scrollToElement(this.$refs.listGroup[anchorIndex]) // 记录第一个touches手指的位置 let firstTouch = e.touches[0] // 记录start的Y值 this.touch.y1 = firstTouch.pageY // 记录index this.touch.anchorIndex = anchorIndex // 左侧列表滑动到指定元素位置 this._scrollTo(anchorIndex) &#125;, // 滑动过程中 列表跟随滚动 需要记录start的Y值计算差 onShortcutTouchMove(e) &#123; // 记录滑动第一个手指位置的Y值 let firstTouch = e.touches[0] this.touch.y2 = firstTouch.pageY // 获得start和move的Y值差 / 右侧每个li的高度（ANCHOR_HEIGHT）| 0 也就是向下取整 // 也就是获得了偏移了几个元素 let delta = (this.touch.y2 - this.touch.y1) / ANCHOR_HEIGHT | 0 // 新的元素位置就是start记录的索引+delta let anchorIndex = parseInt(this.touch.anchorIndex) + delta // 滑动到指定元素位置 this._scrollTo(anchorIndex) &#125;, refresh() &#123; this.$refs.listview.refresh() &#125;, // 记录实时滚动的Y值 scroll(pos) &#123; this.scrollY = pos.y &#125;, // 计算每个左侧列表的高度 _calculateHeight() &#123; this.listHeight = [] const list = this.$refs.listGroup let height = 0 this.listHeight.push(height) for (let i = 0; i &lt; list.length; i++) &#123; let item = list[i] height += item.clientHeight this.listHeight.push(height) &#125; &#125;, _scrollTo(index) &#123; if (!index &amp;&amp; index !== 0) &#123; return &#125; // 点击右侧时 scrollY赋值实现高亮 因为点击时左侧没有派发scroll事件没有更新scrollY // 需要根据逻辑手动给scrollY赋值 if (index &lt; 0) &#123; // 顶部 index = 0 &#125; else if (index &gt; this.listHeight.length - 2) &#123; // 底部 index = this.listHeight.length - 2 &#125; this.scrollY = -this.listHeight[index] // 左侧滚动到指定位置 this.$refs.listview.scrollToElement(this.$refs.listGroup[index], 0) &#125; &#125;, watch: &#123; data() &#123; // data发生改变时 重新计算左侧每个列表高度 setTimeout(() =&gt; &#123; this._calculateHeight() &#125;, 20) &#125;, // 滑动位置发生变化时 scrollY(newY) &#123; // 三种情况 顶部 中间 底部 const listHeight = this.listHeight // 当滚动到顶部，newY&gt;0 if (newY &gt; 0) &#123; this.currentIndex = 0 return &#125; // 在中间部分滚动 for (let i = 0; i &lt; listHeight.length - 1; i++) &#123; let height1 = listHeight[i] let height2 = listHeight[i + 1] // 两个元素之间 if (-newY &gt;= height1 &amp;&amp; -newY &lt; height2) &#123; this.currentIndex = i this.diff = height2 + newY return &#125; &#125; // 当滚动到底部，且-newY大于最后一个元素的上限 // 2的原因是 listHeight在创建时比元素多一个 并且底部以元素的上线位置为准 this.currentIndex = listHeight.length - 2 &#125;, diff(newVal) &#123; let fixedTop = (newVal &gt; 0 &amp;&amp; newVal &lt; TITLE_HEIGHT) ? newVal - TITLE_HEIGHT : 0 if (this.fixedTop === fixedTop) &#123; return &#125; // 当偏移量小于title的高度时才transfrom 其它情况不变依然fix在列表顶部 this.fixedTop = fixedTop this.$refs.fixed.style.transform = `translate3d(0,$&#123;fixedTop&#125;px,0)` &#125; &#125;, components: &#123; Scroll &#125;&lt;/script&gt; 达到左右互相联动的效果 右侧点击左侧滑动到对应元素，右侧滑动，根据偏移比例左侧滑动到对应位置 左侧滑动到某个区间，右侧高亮 顶部固定title，在滑动偏移差小于title高度时,fixed有个过渡效果。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>组件</tag>
        <tag>封装</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex的学习及使用]]></title>
    <url>%2F2018%2F03%2F24%2FVuex%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[解决多个组件的状态共享,解决路由间传递复杂数据,便于维护。 目录结构通常情况下 我们在src下建立一个store文件夹 具体如下图 state.js里是要用到的状态； getters.js是用来映射state里的状态； mutations.js是改变state里状态的一些方法，只能同步操作； mutations-types.js是统一管理mutaions方法名的一个文件（多人协作时方便管理，也可以不用）； actions.js 不直接改变state里的状态，通过commit mutations里的方法进行改变state,并且可以分发多个mutaitons并且可以进行异步操作； index.js 入口文件 例子：例子中用了export,export default 两种不同的导出语法 如果不清楚可以查阅另一篇文章 ✌ 点击进入 javascript的模块化 state.js 1234567891011121314const state = &#123; singer: &#123;&#125;, playing: false, fullScreen: false, playList: [], sequenceList: [], currentIndex: -1, //歌单详细列表 disc: &#123;&#125;, // 排行列表 topList: &#123;&#125;,&#125;export default state getters.js (进行映射state) 123456789101112131415export const singer = state =&gt; state.singerexport const playing = state =&gt; state.playingexport const fullScreen = state =&gt; state.fullScreenexport const playList = state =&gt; state.playListexport const sequenceList = state =&gt; state.sequenceListexport const currentIndex = state =&gt; state.currentIndexexport const disc = state =&gt; state.discexport const topList = state =&gt; state.topList mutations-types.js (统一管理mutations方法名称常量) 123456789101112131415export const SET_SINGER = 'SET_SINGER'export const SET_PLAYING_STATE = 'SET_PLAYING_STATE'export const SET_FULL_SCREEN = 'SET_FULL_SCREEN'export const SET_PLAYLIST = 'SET_PLAYLIST'export const SET_SEQUENCE_LIST = 'SET_SEQUENCE_LIST'export const SET_CURRENT_INDEX = 'SET_CURRENT_INDEX'export const SET_DISC = 'SET_DISC'export const SET_TOP_LIST = 'SET_TOP_LIST' mutations.js (改变state的一些方法) 123456789101112131415161718192021222324252627282930import * as types from './mutations-types' const mutations = &#123; [types.SET_SINGER] (state, singer) &#123; state.singer = singer &#125;, [types.SET_PLAYING_STATE](state, flag) &#123; state.playing = flag &#125;, [types.SET_FULL_SCREEN](state, flag) &#123; state.fullScreen = flag &#125;, [types.SET_PLAYLIST](state, list) &#123; state.playList = list &#125;, [types.SET_SEQUENCE_LIST](state, list) &#123; state.sequenceList = list &#125;, [types.SET_CURRENT_INDEX](state, index) &#123; state.currentIndex = index &#125;, [types.SET_DISC](state, disc) &#123; state.disc = disc &#125;, [types.SET_TOP_LIST](state, topList) &#123; state.topList = topList &#125;&#125;export default mutations actions.js(派发多个mutations或进行异步操作) 在 store 上注册 action。处理函数总是接受 context 作为第一个参数，payload 作为第二个参数（可选）。 context包含以下属性，第二个参数可选（调用时传入的参数） 12345678&#123; state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters // 等同于 `store.getters`，只存在于模块中&#125; 下面用了结构赋值 第一个参数只接收commit,有些场景也需要接收state {commit, state} 12345678import * as types from './mutations-types' // 清空播放列表 export const deleteSongLits = function(&#123;commit&#125;, val) &#123; commit(types.SET_PLAYLIST, []) commit(types.SET_SEQUENCE_LIST, []) commit(types.SET_CURRENT_INDEX, -1) commit(types.SET_PLAYING_STATE, false) &#125; index.js (vuex入口文件) 12345678910111213141516171819202122import Vue from 'vue'import Vuex from 'vuex'import * as actions from './actions'import * as getters from './getters'import state from './state'import mutations from './mutations'// 内置的logger插件 日志插件可以在控制台查看vuex的信息进行调试import createLogger from 'vuex/dist/logger'Vue.use(Vuex)// run dev时 debug为trueconst debug = process.env.NODE_EN !== 'production'export default new Vuex.Store(&#123; actions, getters, state, mutations, // strict 严格模式 true为开启 // 任何 mutation 处理函数以外修改 Vuex state 都会抛出错误 strict: debug, plugins: debug ? [createLogger()] : []&#125;) 在项目的入口文件main.js中将该 Store 实例添加到构造的 Vue 实例中main.js 12345678910111213141516171819202122import Vue from 'vue'import App from './App'import router from './router'import fastclick from 'fastclick'import 'babel-polyfill'import 'common/stylus/index.styl'import VueLazyLoad from 'vue-lazyload'import store from './store' // 引入storeVue.config.productionTip = falsefastclick.attach(document.body)Vue.use(VueLazyLoad, &#123; loading: require('common/image/logo@2x.png')&#125;)/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store,// 添加到Vue实例中 render: h =&gt; h(App)&#125;) 利用辅助函数在组件中获取state,映射getter,提交mutation,分发action1234567891011121314151617181920212223242526272829303132import &#123; mapState, mapMutations, mapActions &#125; from 'vuex'export default &#123; computed: &#123; ...mapState([ // 映射 this.singer 为 store.state.singer 'singer' ]), // 把 `this.playing` 映射为 `this.$store.getters.playing` ...mapGetters(['playing']) &#125;, methods: &#123; ...mapMutations([ 'SET_SINGER', // 将 `this.SET_SINGER()` 映射为 `this.$store.commit('SET_SINGER')` // `mapMutations` 也支持载荷： 'SET_SINGER' // 将 `this.SET_SINGER(amount)` 映射为 `this.$store.commit('SET_SINGER', amount)` ]), ...mapMutations(&#123; setSinger: 'SET_SINGER' // 将 `this.setSinger()` 映射为 `this.$store.commit('SET_SINGER')` &#125;) ...mapActions([ 'deleteSongLits', // 将 `this.deleteSongLits()` 映射为 `this.$store.dispatch('deleteSongLits')` // `mapActions` 也支持载荷： // 'deleteSongLits' // 将 `this.deleteSongLits(amount)` 映射为 `this.$store.dispatch('deleteSongLits', amount)` ]), ...mapActions(&#123; empty: 'deleteSongLits' // 将 `this.empty()` 映射为 `this.$store.dispatch('deleteSongLits')` &#125;) &#125;&#125; vuex的分割模块以vue-element-admin的store为例 ✌ 点击传送 目录结构: index.js 入口文件 getter.js state的映射 modules模块文件夹，里面为一个个vuex模块 以errorLog模块为例 123456789101112131415161718const errorLog = &#123; state: &#123; logs: [] &#125;, mutations: &#123; ADD_ERROR_LOG: (state, log) =&gt; &#123; state.logs.push(log) &#125; &#125;, actions: &#123; addErrorLog(&#123; commit &#125;, log) &#123; commit('ADD_ERROR_LOG', log) &#125; &#125;&#125;export default errorLog// 导出一个对象 有sate, mutations, actions的对象 getter.js state的映射 1234const getters = &#123; errorLogs: state =&gt; state.errorLog.logs&#125;export default getters index.js vuex入口文件 123456789101112131415161718192021222324import Vue from 'vue'import Vuex from 'vuex'import app from './modules/app'import errorLog from './modules/errorLog'import permission from './modules/permission'import tagsView from './modules/tagsView'import user from './modules/user'import getters from './getters'// 加载每一个模块Vue.use(Vuex)const store = new Vuex.Store(&#123; // 注入modules对象中 modules: &#123; app, errorLog, permission, tagsView, user &#125;, getters&#125;)export default store main.js 项目入口文件 12345678910import store from './store' // 加载storenew Vue(&#123; el: '#app', router, store, // 挂在到Vue实例 i18n, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 模块写法只是将state,mutations,actions写到了不同的功能模块中，并且分别加载并挂在到Vuex实例中，多人写作或者功能模块较多的项目推荐这种写法 Vuex数据持久化，结合localStoragevuex刷新后就会消失, 很多应用场景刷新要保留数据 结合本地存储只要不手动清除，就一直存在 思路 最好是写一个js文件,根据业务场景写localStorage的set和get和移除或清空 state里的数据直接获取localStorage存储的数据 mutaions或actions方法里调用js文件中是set get 移除 清空等方法 demo写set get方法的文件 cache.js 1234567891011121314151617181920212223242526272829303132333435import storage from 'good-storage'const SEARCH_KEY = '__search__'const SEARCH_MAX_LENGTH = 15// 保存搜索历史export function saveSearch(query) &#123; // 本地存储数组 let searches = storage.get(SEARCH_KEY, []) // 进行比较后插入 insertArray(searches, query, (item) =&gt; &#123; return item === query &#125;, SEARCH_MAX_LENGTH) // 保存 storage.set(SEARCH_KEY, searches) return searches&#125;export function loadSearch() &#123; return storage.get(SEARCH_KEY, [])&#125;// 删除一个export function deleteSearch(query) &#123; let searches = storage.get(SEARCH_KEY, []) deleteFromArray(searches, (item) =&gt; &#123; return item === query &#125;) storage.set(SEARCH_KEY, searches) return searches&#125;export function clearSearch() &#123; storage.remove(SEARCH_KEY) return []&#125; state.js (获取存储) 12345678import &#123;loadSearch&#125; from 'common/js/cache'const state = &#123; // 搜索历史 searchHistory: loadSearch(),&#125;export default state mutations.js 12345678910import * as types from './mutations-types' const mutations = &#123; [types.SET_SEARCH_HISTORY](state, history) &#123; state.searchHistory = history &#125;&#125;export default mutations actions.js (更新存储) 123456789101112131415import * as types from './mutations-types'import &#123;saveSearch, deleteSearch, clearSearch,&#125; from 'common/js/cache' // 搜索历史相关 export const saveSearchHistory = function(&#123;commit&#125;, query) &#123; commit(types.SET_SEARCH_HISTORY, saveSearch(query)) &#125; export const deleteSearchHistory = function(&#123;commit&#125;, query) &#123; commit(types.SET_SEARCH_HISTORY, deleteSearch(query)) &#125; export const clearSearchHistory = function(&#123;commit&#125;) &#123; commit(types.SET_SEARCH_HISTORY, clearSearch()) &#125; 当派发actions时会做对应的存储操作，state会拿到本地存储的数据]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp的原理和使用]]></title>
    <url>%2F2018%2F03%2F15%2Fjsonp%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[浏览器的同源策略不允许跨域，jsonp是解决跨域的一种方法。但也存在一些缺点，所以跨域最好还是后台进行设置. 原理 利用script标签的src属性不受同源策略影响（协议，端口，域名任何一个不同，同源策略都会禁止跨域） 通过前端方法作为参数传递到服务器，服务器注入参数后再返还，实现服务器向客户通信 只支持get方法 请求过程 请求前：创建一个script标签，并给src赋值 url+callback的方法名，并在window上注册这个方法 发送请求： 将script添加到页面中，浏览器会发起一个请求 数据响应：服务器将返回的数据作为参数和函数名拼接在一起 jsonpCbk({data:”data”})。当浏览器接收到响应数据，由于发起请求的是script，所以相当于直接调用jsonpCbk方法，并且给回调传入了一个参数。 原生js写一个jsonp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// url要请求的地址以及拼接的参数；opts&#123;param: 约定的函数参数，timeout:超时时间，name:指定的函数名，prefix:指定的函数名前缀&#125;；fn回调函数var count = 0function noop()&#123;&#125;function jsonp(url, opts, fn) &#123; // opts 如果是一个函数 赋值给fn 并重置opts为空对象 if('function' == typeof opts)&#123; fn = opts opts = &#123;&#125; &#125; // 如果没有opts 给opts赋值空对象 if(!opts) opts = &#123;&#125; var prefix = opts.prefix || '__jp' // id为opts的name或者prefix+计数（prefix为opts.prefix或__jp） var id = opts.name || (prefix + (count++)) var param = opts.param || 'callback' // 有opts.timeout 就取 没有就是60000ms var timeout = null != opts.timeout ? opts.timeout : 60000 var enc = encodeURIComponent // 第一个script或者head标签 var target = document.getElementsByTagName('script')[0] || document.head var script var timer // 如果有timeout就在timeout之后执行clean并抛出Error if (timeout) &#123; timer = setTimeout(function()&#123; cleanup() if(fn) fn(new Error('Timeout')) &#125;, timeout) &#125; function cleanup() &#123; // 移除创建的script 回调函数置空 清除定时器 if(script.parentNode) script.parentNode.removeChild(script) window[id] = noop if(timer) clearTimeout(timer) &#125; function cancel() &#123; if(window[id]) &#123; cleanup() &#125; &#125; // 全局挂载id window[id] = function(data) &#123; cleanup() // 请求返回后执行回调fn if(fn) fn(data) &#125; url += (~url.indexOf('?') ? '&amp;' : '?') + param + '=' + enc(id); url = url.replace('?&amp;', '?'); // 创建script标签src属性赋值url script = document.createElement('script') script.src = url; // 插入到head或script的前面 target.parentNode.insertBefore(script, target); return cancel; &#125; 以上是参照一个jsonp插件的源码写的 传送门 此方法在调用时需要自己拼接将参数拼接在url后面 opts如果跟后台有约定callback参数名就传{param: 约定参数名} ，没有默认callback]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue首屏优化之路由懒加载]]></title>
    <url>%2F2018%2F03%2F10%2FrouterLazy%2F</url>
    <content type="text"><![CDATA[项目比较大时build后首次加载会有很慢的问题,路由懒加载就是优化加载速度的方法之一 路由懒加载优化首屏加载速度首先贴个官方文档 1. 路由配置如下123456789101112131415161718192021222324252627282930// router 文件夹下的index.js文件import Vue from 'vue'improt VueRouter from 'vue-router'improt Holly from '@/pages/Holly' // 某页面Vue.use(VueRouter)// 非懒加载/* const routes = [ &#123; path: '/', name: 'holly', component: Holly &#125;] */// 懒加载const routes= [ &#123; path: '/', name: 'holly', componet: () =&gt; improt('@/pages/Holly') //其实就相当于按需加载 &#125;] //实例化const router = new VueRouter(&#123; routes&#125;)export default router 这就是将不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应组件。 2. main.js入口文件关于路由的配置1234567improt router from './router' //引入路由配置文件new Vue(&#123; el: '#app', router, // 注入到根实例中 render: h =&gt; h(App)&#125;) 今天把项目做了路由懒加载的优化，首屏快了几秒~ 😄]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用vue-cli初始化项目]]></title>
    <url>%2F2018%2F03%2F09%2Fvue-cli-init-project%2F</url>
    <content type="text"><![CDATA[可以快速初始化vue项目，提供一套本地node测试服务器，集成打包上线方案 利用vue-cli脚手架初始化项目1. 首先电脑需要安装好node和包管理工具 去官网下载node稳定版本 点击传送门 记得下载.msi格式的，可以避免配置环境变量 npm（node安装以后自带npm） 如果想使用cnpm 需要安装一下 12npm install -g cnpm --registry=https://registry.npm.taobao.org// 通常npm下载速度比较慢所以很多人会选择cnpm淘宝镜像 如果想使用yarn 需要安装一下 12npm install -g yarn// 只是命令上与npm和cnpm有些出入要看文档 具体的命令可以查看对应的官方文档 2.接下来是安装一个强大的编译工具 webpack和vue脚手架 我通常用cnpm装 12345678910// 全局安装webpackcnpm install webpack -g// 全局安装vue-clicnpm install vue-cli -g// 检测vue版本 -V大写vue -V// 检测node版本 -v小写node -v// npm 版本npm -v 3. 初始化项目 输入一些命令 12345678910111213141516vue init webpack myProject //myproject 为项目名称// 回车以后会询问几个简单的选项 我们进行填写 一路填写+回车Project name : myproject// 如果不需要更改直接回车就可以了。注意：这里不能使用大写，所以我把名称改成了myprojectProject description: // 项目描述 默认为A Vue.js project,直接回车，不用编写。Author：// 作者 如果你有配置git的作者，他会读取。Install vue-router ? // 是否安装vue的路由插件，我们这里需要安装，所以选择YUse ESLint to lint your code?// 是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n，如果你是大型团队开发，最好是进行配置。setup unit tests with Karma + Mocha? // 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。Setup e2e tests with Nightwatch?// 是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。 4. 下载依赖包及运行项目 cnpm i 包都下载好以后 npm run dev 项目就在本地跑起来了 浏览器中可以直接访问 5.有几个重要的文件,简单的认识一下 package.json scripts: 命令行里执行的命令具体做了什么，与这里一 一对应 例如npm run dev dependencies：生产环境以来的包，对应–save devDependencies: 开发环境中以来的包 对应–save-dev webpack.base.config.js webpack的基本配置文件 entry入口文件 output出口文件 babelrc es6转化为es5的配置 6. 项目打包上线 执行命令 12npm run build// 默认生产dist目录 里面是打包好的静态文件 可以部署到服务器 ​]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝与浅拷贝]]></title>
    <url>%2F2018%2F03%2F02%2FcopyDeep%2F</url>
    <content type="text"><![CDATA[最近工作中一个简单的赋值，引发了一个很奇怪的 bug。所以深拷贝和浅拷贝还是非常有必要弄清楚的。 1.首先看看 js 基本数据类型和引用类型的区别 基本数据类型：String , Number, Boolean, Null, Undefined 存放在栈内存中。直接按值存放，可以直接访问。 引用数据类型：Array, Object, Function 等；存放在堆内存中，变量实际保存是保存在栈中的一个地址，指向堆中具体的位置。从栈中获取地址再从堆内存中取到数据。 2.赋值，拷贝 基本数据类型拷贝的时候，在堆内存中开辟了新的空间，和原来的变量互不相干。不用考虑深拷贝浅拷贝的问题。 引用数据类型在用=号赋值时，实际上是将栈中的地址赋值给新的变量。所以当改变这个新的变量里的数据时，指向的堆中的数据也是会有变化的。（我那个 bug 也就是这个问题） 12345let a = 123let b = aa = 1234console.log(a) // 1234console.log(b) // 123 基本数据类型复制不会发生引用, 栈中会开辟新的空间存放 12345let arr = [1, 2, 3]let arr1 = arrarr[0] = 3console.log(arr) // [3, 2, 3]console.log(arr1) // [3, 2, 3] 引用数据类型复制是将栈中的地址赋值给变量，指向堆中的同一个空间，所以当改变其中一个时，其实是改变堆中的数据，所有指向这个空间的变量都会发生改变。 3.深拷贝和浅拷贝 上面的例子其实就是浅拷贝，引用类型的数据复制的是指向地址。 深拷贝，堆开辟一个新的空间存放复制的对象。 引用类型的浅拷贝会出现很多问题，那么下面来看看引用类型如何实现深拷贝。 4.实现深拷贝的方法 我最常用的一个是（简单粗暴）序列化反序列化法 1JSON.parse(JSON.stringify(obj)) 但这个方法存在一些问题 ： 无法复制正则表达式类型、函数类型 无论构造器是什么都会变成 Object undefined 无法复制 只能深拷贝对象和数组其他类型会失真 但实际开发中只是复制数据是够用的 迭代递归法 对对象进行迭代操作，对它的每个值进行递归深拷贝 1234567891011121314151617181920212223242526272829function deepClone(obj) &#123; let copy if (null == obj || 'object' != typeof obj) return obj // Date if (obj instanceof Date) &#123; copy = new Date() copy.setTime(obj.getTime()) return copy &#125; // Array if (obj instanceof Array) &#123; copy = [] for (var i = 0; i &lt; obj.length; i++) &#123; copy[i] = clone(obj[i]) &#125; return copy &#125; // Object if (obj instanceof Object) &#123; copy = &#123;&#125; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; copy[key] = clone(obj[key]) &#125; &#125; return copy &#125; throw new Error('error')&#125; Object.assign() ES6 的深拷贝方法 concat 对数组进行深拷贝 应该还有很多方法 或者更深入的思考 关于可枚举不可枚举这些概念我还不太清楚 有待进步]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>每日一坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ios系统与Date的Bug]]></title>
    <url>%2F2018%2F03%2F01%2FmoveIos-1%2F</url>
    <content type="text"><![CDATA[解决办法 （转化为/分隔的就可以） ios系统 Date.parse()获取时间戳时 ios系统只认得/分隔的时间 其它-分隔或者别的 ios获取的都是NaN123var resData = '2017-3-14 10:03:45'; resData=resData..replace(/-/g, '/'); console.log("返回时间：" + resData)]]></content>
      <categories>
        <category>每日一坑</category>
      </categories>
      <tags>
        <tag>移动</tag>
        <tag>踩坑记</tag>
        <tag>ios</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑Vue项目时服务突然停止(Node内存溢出)]]></title>
    <url>%2F2018%2F02%2F03%2FnodeFull%2F</url>
    <content type="text"><![CDATA[先描述下现象：vue项目在跑时偶尔出现webpack-dev-server服务停止,需要重新npm run dev. 1FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory 报错信息说堆内存溢出（其实就是node内存溢出） 解决办法： 如果是run dev时报错,在package.json文件里的scripts字段的 ‘dev’ : node 后面加上 –max_old_space_size=4096 这里的4096单位是M也就是4G（具体的大小根据实际情况而定） 如果是在打包时 就在build后面加上面的内容 原因 首先项目在跑时其实用的是用的webpack-dev-server工具，是一个小型的Node.js Express 服务器。 webpack在每次代码更改保存时都会进行编译然后实刷新页面得到最新的效果，但同时也会占用大量内存，也就是占用node内存。 node是基于V8构建的，V8对内存的使用是有限制的（老64位系统约1.4G，32位约0.7G，新生代内存64位约32M，32系统下约为16M）在这种限制下，如果不小心触碰到这个界限，就会造成进程退出。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>每日一坑</tag>
        <tag>Node</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的bus组件通信时多次触发的问题]]></title>
    <url>%2F2018%2F01%2F07%2FbusVue%2F</url>
    <content type="text"><![CDATA[解决办法 在组件中 beforeDestory周期 bus.$off(“emit的事件名”) 手动销毁事 Vue利用bus进行组件通信时，因为bus是全局的不受页面生命周期控制，所以会发生多次触发的问题。多个页面都用到同一个组件而组件又用到了bus，那么这个组件通过bus emit了多少次这个页面在on时就会触发多少次。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>每日一坑</tag>
        <tag>组件通信</tag>
        <tag>bus</tag>
      </tags>
  </entry>
</search>
